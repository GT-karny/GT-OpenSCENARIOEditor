/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
import * as $protobuf from "protobufjs/minimal";

// Common aliases
const $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

// Exported root namespace
const $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

export const gt_sim = $root.gt_sim = (() => {

    /**
     * Namespace gt_sim.
     * @exports gt_sim
     * @namespace
     */
    const gt_sim = {};

    gt_sim.GroundTruthService = (function() {

        /**
         * Constructs a new GroundTruthService service.
         * @memberof gt_sim
         * @classdesc Represents a GroundTruthService
         * @extends $protobuf.rpc.Service
         * @constructor
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         */
        function GroundTruthService(rpcImpl, requestDelimited, responseDelimited) {
            $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
        }

        (GroundTruthService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = GroundTruthService;

        /**
         * Creates new GroundTruthService service using the specified rpc implementation.
         * @function create
         * @memberof gt_sim.GroundTruthService
         * @static
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         * @returns {GroundTruthService} RPC service. Useful where requests and/or responses are streamed.
         */
        GroundTruthService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
            return new this(rpcImpl, requestDelimited, responseDelimited);
        };

        /**
         * Callback as used by {@link gt_sim.GroundTruthService#streamGroundTruth}.
         * @memberof gt_sim.GroundTruthService
         * @typedef StreamGroundTruthCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {osi3.GroundTruth} [response] GroundTruth
         */

        /**
         * Calls StreamGroundTruth.
         * @function streamGroundTruth
         * @memberof gt_sim.GroundTruthService
         * @instance
         * @param {google.protobuf.IEmpty} request Empty message or plain object
         * @param {gt_sim.GroundTruthService.StreamGroundTruthCallback} callback Node-style callback called with the error, if any, and GroundTruth
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(GroundTruthService.prototype.streamGroundTruth = function streamGroundTruth(request, callback) {
            return this.rpcCall(streamGroundTruth, $root.google.protobuf.Empty, $root.osi3.GroundTruth, request, callback);
        }, "name", { value: "StreamGroundTruth" });

        /**
         * Calls StreamGroundTruth.
         * @function streamGroundTruth
         * @memberof gt_sim.GroundTruthService
         * @instance
         * @param {google.protobuf.IEmpty} request Empty message or plain object
         * @returns {Promise<osi3.GroundTruth>} Promise
         * @variation 2
         */

        return GroundTruthService;
    })();

    return gt_sim;
})();

export const osi3 = $root.osi3 = (() => {

    /**
     * Namespace osi3.
     * @exports osi3
     * @namespace
     */
    const osi3 = {};

    osi3.GroundTruth = (function() {

        /**
         * Properties of a GroundTruth.
         * @memberof osi3
         * @interface IGroundTruth
         * @property {osi3.IInterfaceVersion|null} [version] GroundTruth version
         * @property {osi3.ITimestamp|null} [timestamp] GroundTruth timestamp
         * @property {osi3.IIdentifier|null} [hostVehicleId] GroundTruth hostVehicleId
         * @property {Array.<osi3.IStationaryObject>|null} [stationaryObject] GroundTruth stationaryObject
         * @property {Array.<osi3.IMovingObject>|null} [movingObject] GroundTruth movingObject
         * @property {Array.<osi3.ITrafficSign>|null} [trafficSign] GroundTruth trafficSign
         * @property {Array.<osi3.ITrafficLight>|null} [trafficLight] GroundTruth trafficLight
         * @property {Array.<osi3.IRoadMarking>|null} [roadMarking] GroundTruth roadMarking
         * @property {Array.<osi3.ILaneBoundary>|null} [laneBoundary] GroundTruth laneBoundary
         * @property {Array.<osi3.ILane>|null} [lane] GroundTruth lane
         * @property {Array.<osi3.IOccupant>|null} [occupant] GroundTruth occupant
         * @property {osi3.IEnvironmentalConditions|null} [environmentalConditions] GroundTruth environmentalConditions
         * @property {number|null} [countryCode] GroundTruth countryCode
         * @property {string|null} [projString] GroundTruth projString
         * @property {string|null} [mapReference] GroundTruth mapReference
         * @property {string|null} [modelReference] GroundTruth modelReference
         * @property {Array.<osi3.IReferenceLine>|null} [referenceLine] GroundTruth referenceLine
         * @property {Array.<osi3.ILogicalLaneBoundary>|null} [logicalLaneBoundary] GroundTruth logicalLaneBoundary
         * @property {Array.<osi3.ILogicalLane>|null} [logicalLane] GroundTruth logicalLane
         * @property {osi3.GroundTruth.IProjFrameOffset|null} [projFrameOffset] GroundTruth projFrameOffset
         */

        /**
         * Constructs a new GroundTruth.
         * @memberof osi3
         * @classdesc Represents a GroundTruth.
         * @implements IGroundTruth
         * @constructor
         * @param {osi3.IGroundTruth=} [properties] Properties to set
         */
        function GroundTruth(properties) {
            this.stationaryObject = [];
            this.movingObject = [];
            this.trafficSign = [];
            this.trafficLight = [];
            this.roadMarking = [];
            this.laneBoundary = [];
            this.lane = [];
            this.occupant = [];
            this.referenceLine = [];
            this.logicalLaneBoundary = [];
            this.logicalLane = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GroundTruth version.
         * @member {osi3.IInterfaceVersion|null|undefined} version
         * @memberof osi3.GroundTruth
         * @instance
         */
        GroundTruth.prototype.version = null;

        /**
         * GroundTruth timestamp.
         * @member {osi3.ITimestamp|null|undefined} timestamp
         * @memberof osi3.GroundTruth
         * @instance
         */
        GroundTruth.prototype.timestamp = null;

        /**
         * GroundTruth hostVehicleId.
         * @member {osi3.IIdentifier|null|undefined} hostVehicleId
         * @memberof osi3.GroundTruth
         * @instance
         */
        GroundTruth.prototype.hostVehicleId = null;

        /**
         * GroundTruth stationaryObject.
         * @member {Array.<osi3.IStationaryObject>} stationaryObject
         * @memberof osi3.GroundTruth
         * @instance
         */
        GroundTruth.prototype.stationaryObject = $util.emptyArray;

        /**
         * GroundTruth movingObject.
         * @member {Array.<osi3.IMovingObject>} movingObject
         * @memberof osi3.GroundTruth
         * @instance
         */
        GroundTruth.prototype.movingObject = $util.emptyArray;

        /**
         * GroundTruth trafficSign.
         * @member {Array.<osi3.ITrafficSign>} trafficSign
         * @memberof osi3.GroundTruth
         * @instance
         */
        GroundTruth.prototype.trafficSign = $util.emptyArray;

        /**
         * GroundTruth trafficLight.
         * @member {Array.<osi3.ITrafficLight>} trafficLight
         * @memberof osi3.GroundTruth
         * @instance
         */
        GroundTruth.prototype.trafficLight = $util.emptyArray;

        /**
         * GroundTruth roadMarking.
         * @member {Array.<osi3.IRoadMarking>} roadMarking
         * @memberof osi3.GroundTruth
         * @instance
         */
        GroundTruth.prototype.roadMarking = $util.emptyArray;

        /**
         * GroundTruth laneBoundary.
         * @member {Array.<osi3.ILaneBoundary>} laneBoundary
         * @memberof osi3.GroundTruth
         * @instance
         */
        GroundTruth.prototype.laneBoundary = $util.emptyArray;

        /**
         * GroundTruth lane.
         * @member {Array.<osi3.ILane>} lane
         * @memberof osi3.GroundTruth
         * @instance
         */
        GroundTruth.prototype.lane = $util.emptyArray;

        /**
         * GroundTruth occupant.
         * @member {Array.<osi3.IOccupant>} occupant
         * @memberof osi3.GroundTruth
         * @instance
         */
        GroundTruth.prototype.occupant = $util.emptyArray;

        /**
         * GroundTruth environmentalConditions.
         * @member {osi3.IEnvironmentalConditions|null|undefined} environmentalConditions
         * @memberof osi3.GroundTruth
         * @instance
         */
        GroundTruth.prototype.environmentalConditions = null;

        /**
         * GroundTruth countryCode.
         * @member {number} countryCode
         * @memberof osi3.GroundTruth
         * @instance
         */
        GroundTruth.prototype.countryCode = 0;

        /**
         * GroundTruth projString.
         * @member {string} projString
         * @memberof osi3.GroundTruth
         * @instance
         */
        GroundTruth.prototype.projString = "";

        /**
         * GroundTruth mapReference.
         * @member {string} mapReference
         * @memberof osi3.GroundTruth
         * @instance
         */
        GroundTruth.prototype.mapReference = "";

        /**
         * GroundTruth modelReference.
         * @member {string} modelReference
         * @memberof osi3.GroundTruth
         * @instance
         */
        GroundTruth.prototype.modelReference = "";

        /**
         * GroundTruth referenceLine.
         * @member {Array.<osi3.IReferenceLine>} referenceLine
         * @memberof osi3.GroundTruth
         * @instance
         */
        GroundTruth.prototype.referenceLine = $util.emptyArray;

        /**
         * GroundTruth logicalLaneBoundary.
         * @member {Array.<osi3.ILogicalLaneBoundary>} logicalLaneBoundary
         * @memberof osi3.GroundTruth
         * @instance
         */
        GroundTruth.prototype.logicalLaneBoundary = $util.emptyArray;

        /**
         * GroundTruth logicalLane.
         * @member {Array.<osi3.ILogicalLane>} logicalLane
         * @memberof osi3.GroundTruth
         * @instance
         */
        GroundTruth.prototype.logicalLane = $util.emptyArray;

        /**
         * GroundTruth projFrameOffset.
         * @member {osi3.GroundTruth.IProjFrameOffset|null|undefined} projFrameOffset
         * @memberof osi3.GroundTruth
         * @instance
         */
        GroundTruth.prototype.projFrameOffset = null;

        /**
         * Creates a new GroundTruth instance using the specified properties.
         * @function create
         * @memberof osi3.GroundTruth
         * @static
         * @param {osi3.IGroundTruth=} [properties] Properties to set
         * @returns {osi3.GroundTruth} GroundTruth instance
         */
        GroundTruth.create = function create(properties) {
            return new GroundTruth(properties);
        };

        /**
         * Encodes the specified GroundTruth message. Does not implicitly {@link osi3.GroundTruth.verify|verify} messages.
         * @function encode
         * @memberof osi3.GroundTruth
         * @static
         * @param {osi3.IGroundTruth} message GroundTruth message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GroundTruth.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                $root.osi3.InterfaceVersion.encode(message.version, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                $root.osi3.Timestamp.encode(message.timestamp, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.hostVehicleId != null && Object.hasOwnProperty.call(message, "hostVehicleId"))
                $root.osi3.Identifier.encode(message.hostVehicleId, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.stationaryObject != null && message.stationaryObject.length)
                for (let i = 0; i < message.stationaryObject.length; ++i)
                    $root.osi3.StationaryObject.encode(message.stationaryObject[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.movingObject != null && message.movingObject.length)
                for (let i = 0; i < message.movingObject.length; ++i)
                    $root.osi3.MovingObject.encode(message.movingObject[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.trafficSign != null && message.trafficSign.length)
                for (let i = 0; i < message.trafficSign.length; ++i)
                    $root.osi3.TrafficSign.encode(message.trafficSign[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.trafficLight != null && message.trafficLight.length)
                for (let i = 0; i < message.trafficLight.length; ++i)
                    $root.osi3.TrafficLight.encode(message.trafficLight[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.roadMarking != null && message.roadMarking.length)
                for (let i = 0; i < message.roadMarking.length; ++i)
                    $root.osi3.RoadMarking.encode(message.roadMarking[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.laneBoundary != null && message.laneBoundary.length)
                for (let i = 0; i < message.laneBoundary.length; ++i)
                    $root.osi3.LaneBoundary.encode(message.laneBoundary[i], writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            if (message.lane != null && message.lane.length)
                for (let i = 0; i < message.lane.length; ++i)
                    $root.osi3.Lane.encode(message.lane[i], writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            if (message.occupant != null && message.occupant.length)
                for (let i = 0; i < message.occupant.length; ++i)
                    $root.osi3.Occupant.encode(message.occupant[i], writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
            if (message.environmentalConditions != null && Object.hasOwnProperty.call(message, "environmentalConditions"))
                $root.osi3.EnvironmentalConditions.encode(message.environmentalConditions, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
            if (message.countryCode != null && Object.hasOwnProperty.call(message, "countryCode"))
                writer.uint32(/* id 13, wireType 0 =*/104).uint32(message.countryCode);
            if (message.projString != null && Object.hasOwnProperty.call(message, "projString"))
                writer.uint32(/* id 14, wireType 2 =*/114).string(message.projString);
            if (message.mapReference != null && Object.hasOwnProperty.call(message, "mapReference"))
                writer.uint32(/* id 15, wireType 2 =*/122).string(message.mapReference);
            if (message.modelReference != null && Object.hasOwnProperty.call(message, "modelReference"))
                writer.uint32(/* id 16, wireType 2 =*/130).string(message.modelReference);
            if (message.referenceLine != null && message.referenceLine.length)
                for (let i = 0; i < message.referenceLine.length; ++i)
                    $root.osi3.ReferenceLine.encode(message.referenceLine[i], writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
            if (message.logicalLaneBoundary != null && message.logicalLaneBoundary.length)
                for (let i = 0; i < message.logicalLaneBoundary.length; ++i)
                    $root.osi3.LogicalLaneBoundary.encode(message.logicalLaneBoundary[i], writer.uint32(/* id 18, wireType 2 =*/146).fork()).ldelim();
            if (message.logicalLane != null && message.logicalLane.length)
                for (let i = 0; i < message.logicalLane.length; ++i)
                    $root.osi3.LogicalLane.encode(message.logicalLane[i], writer.uint32(/* id 19, wireType 2 =*/154).fork()).ldelim();
            if (message.projFrameOffset != null && Object.hasOwnProperty.call(message, "projFrameOffset"))
                $root.osi3.GroundTruth.ProjFrameOffset.encode(message.projFrameOffset, writer.uint32(/* id 20, wireType 2 =*/162).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GroundTruth message, length delimited. Does not implicitly {@link osi3.GroundTruth.verify|verify} messages.
         * @function encodeDelimited
         * @memberof osi3.GroundTruth
         * @static
         * @param {osi3.IGroundTruth} message GroundTruth message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GroundTruth.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GroundTruth message from the specified reader or buffer.
         * @function decode
         * @memberof osi3.GroundTruth
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {osi3.GroundTruth} GroundTruth
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GroundTruth.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.osi3.GroundTruth();
            while (reader.pos < end) {
                let tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.version = $root.osi3.InterfaceVersion.decode(reader, reader.uint32());
                        break;
                    }
                case 2: {
                        message.timestamp = $root.osi3.Timestamp.decode(reader, reader.uint32());
                        break;
                    }
                case 3: {
                        message.hostVehicleId = $root.osi3.Identifier.decode(reader, reader.uint32());
                        break;
                    }
                case 4: {
                        if (!(message.stationaryObject && message.stationaryObject.length))
                            message.stationaryObject = [];
                        message.stationaryObject.push($root.osi3.StationaryObject.decode(reader, reader.uint32()));
                        break;
                    }
                case 5: {
                        if (!(message.movingObject && message.movingObject.length))
                            message.movingObject = [];
                        message.movingObject.push($root.osi3.MovingObject.decode(reader, reader.uint32()));
                        break;
                    }
                case 6: {
                        if (!(message.trafficSign && message.trafficSign.length))
                            message.trafficSign = [];
                        message.trafficSign.push($root.osi3.TrafficSign.decode(reader, reader.uint32()));
                        break;
                    }
                case 7: {
                        if (!(message.trafficLight && message.trafficLight.length))
                            message.trafficLight = [];
                        message.trafficLight.push($root.osi3.TrafficLight.decode(reader, reader.uint32()));
                        break;
                    }
                case 8: {
                        if (!(message.roadMarking && message.roadMarking.length))
                            message.roadMarking = [];
                        message.roadMarking.push($root.osi3.RoadMarking.decode(reader, reader.uint32()));
                        break;
                    }
                case 9: {
                        if (!(message.laneBoundary && message.laneBoundary.length))
                            message.laneBoundary = [];
                        message.laneBoundary.push($root.osi3.LaneBoundary.decode(reader, reader.uint32()));
                        break;
                    }
                case 10: {
                        if (!(message.lane && message.lane.length))
                            message.lane = [];
                        message.lane.push($root.osi3.Lane.decode(reader, reader.uint32()));
                        break;
                    }
                case 11: {
                        if (!(message.occupant && message.occupant.length))
                            message.occupant = [];
                        message.occupant.push($root.osi3.Occupant.decode(reader, reader.uint32()));
                        break;
                    }
                case 12: {
                        message.environmentalConditions = $root.osi3.EnvironmentalConditions.decode(reader, reader.uint32());
                        break;
                    }
                case 13: {
                        message.countryCode = reader.uint32();
                        break;
                    }
                case 14: {
                        message.projString = reader.string();
                        break;
                    }
                case 15: {
                        message.mapReference = reader.string();
                        break;
                    }
                case 16: {
                        message.modelReference = reader.string();
                        break;
                    }
                case 17: {
                        if (!(message.referenceLine && message.referenceLine.length))
                            message.referenceLine = [];
                        message.referenceLine.push($root.osi3.ReferenceLine.decode(reader, reader.uint32()));
                        break;
                    }
                case 18: {
                        if (!(message.logicalLaneBoundary && message.logicalLaneBoundary.length))
                            message.logicalLaneBoundary = [];
                        message.logicalLaneBoundary.push($root.osi3.LogicalLaneBoundary.decode(reader, reader.uint32()));
                        break;
                    }
                case 19: {
                        if (!(message.logicalLane && message.logicalLane.length))
                            message.logicalLane = [];
                        message.logicalLane.push($root.osi3.LogicalLane.decode(reader, reader.uint32()));
                        break;
                    }
                case 20: {
                        message.projFrameOffset = $root.osi3.GroundTruth.ProjFrameOffset.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GroundTruth message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof osi3.GroundTruth
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {osi3.GroundTruth} GroundTruth
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GroundTruth.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GroundTruth message.
         * @function verify
         * @memberof osi3.GroundTruth
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GroundTruth.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.version != null && message.hasOwnProperty("version")) {
                let error = $root.osi3.InterfaceVersion.verify(message.version);
                if (error)
                    return "version." + error;
            }
            if (message.timestamp != null && message.hasOwnProperty("timestamp")) {
                let error = $root.osi3.Timestamp.verify(message.timestamp);
                if (error)
                    return "timestamp." + error;
            }
            if (message.hostVehicleId != null && message.hasOwnProperty("hostVehicleId")) {
                let error = $root.osi3.Identifier.verify(message.hostVehicleId);
                if (error)
                    return "hostVehicleId." + error;
            }
            if (message.stationaryObject != null && message.hasOwnProperty("stationaryObject")) {
                if (!Array.isArray(message.stationaryObject))
                    return "stationaryObject: array expected";
                for (let i = 0; i < message.stationaryObject.length; ++i) {
                    let error = $root.osi3.StationaryObject.verify(message.stationaryObject[i]);
                    if (error)
                        return "stationaryObject." + error;
                }
            }
            if (message.movingObject != null && message.hasOwnProperty("movingObject")) {
                if (!Array.isArray(message.movingObject))
                    return "movingObject: array expected";
                for (let i = 0; i < message.movingObject.length; ++i) {
                    let error = $root.osi3.MovingObject.verify(message.movingObject[i]);
                    if (error)
                        return "movingObject." + error;
                }
            }
            if (message.trafficSign != null && message.hasOwnProperty("trafficSign")) {
                if (!Array.isArray(message.trafficSign))
                    return "trafficSign: array expected";
                for (let i = 0; i < message.trafficSign.length; ++i) {
                    let error = $root.osi3.TrafficSign.verify(message.trafficSign[i]);
                    if (error)
                        return "trafficSign." + error;
                }
            }
            if (message.trafficLight != null && message.hasOwnProperty("trafficLight")) {
                if (!Array.isArray(message.trafficLight))
                    return "trafficLight: array expected";
                for (let i = 0; i < message.trafficLight.length; ++i) {
                    let error = $root.osi3.TrafficLight.verify(message.trafficLight[i]);
                    if (error)
                        return "trafficLight." + error;
                }
            }
            if (message.roadMarking != null && message.hasOwnProperty("roadMarking")) {
                if (!Array.isArray(message.roadMarking))
                    return "roadMarking: array expected";
                for (let i = 0; i < message.roadMarking.length; ++i) {
                    let error = $root.osi3.RoadMarking.verify(message.roadMarking[i]);
                    if (error)
                        return "roadMarking." + error;
                }
            }
            if (message.laneBoundary != null && message.hasOwnProperty("laneBoundary")) {
                if (!Array.isArray(message.laneBoundary))
                    return "laneBoundary: array expected";
                for (let i = 0; i < message.laneBoundary.length; ++i) {
                    let error = $root.osi3.LaneBoundary.verify(message.laneBoundary[i]);
                    if (error)
                        return "laneBoundary." + error;
                }
            }
            if (message.lane != null && message.hasOwnProperty("lane")) {
                if (!Array.isArray(message.lane))
                    return "lane: array expected";
                for (let i = 0; i < message.lane.length; ++i) {
                    let error = $root.osi3.Lane.verify(message.lane[i]);
                    if (error)
                        return "lane." + error;
                }
            }
            if (message.occupant != null && message.hasOwnProperty("occupant")) {
                if (!Array.isArray(message.occupant))
                    return "occupant: array expected";
                for (let i = 0; i < message.occupant.length; ++i) {
                    let error = $root.osi3.Occupant.verify(message.occupant[i]);
                    if (error)
                        return "occupant." + error;
                }
            }
            if (message.environmentalConditions != null && message.hasOwnProperty("environmentalConditions")) {
                let error = $root.osi3.EnvironmentalConditions.verify(message.environmentalConditions);
                if (error)
                    return "environmentalConditions." + error;
            }
            if (message.countryCode != null && message.hasOwnProperty("countryCode"))
                if (!$util.isInteger(message.countryCode))
                    return "countryCode: integer expected";
            if (message.projString != null && message.hasOwnProperty("projString"))
                if (!$util.isString(message.projString))
                    return "projString: string expected";
            if (message.mapReference != null && message.hasOwnProperty("mapReference"))
                if (!$util.isString(message.mapReference))
                    return "mapReference: string expected";
            if (message.modelReference != null && message.hasOwnProperty("modelReference"))
                if (!$util.isString(message.modelReference))
                    return "modelReference: string expected";
            if (message.referenceLine != null && message.hasOwnProperty("referenceLine")) {
                if (!Array.isArray(message.referenceLine))
                    return "referenceLine: array expected";
                for (let i = 0; i < message.referenceLine.length; ++i) {
                    let error = $root.osi3.ReferenceLine.verify(message.referenceLine[i]);
                    if (error)
                        return "referenceLine." + error;
                }
            }
            if (message.logicalLaneBoundary != null && message.hasOwnProperty("logicalLaneBoundary")) {
                if (!Array.isArray(message.logicalLaneBoundary))
                    return "logicalLaneBoundary: array expected";
                for (let i = 0; i < message.logicalLaneBoundary.length; ++i) {
                    let error = $root.osi3.LogicalLaneBoundary.verify(message.logicalLaneBoundary[i]);
                    if (error)
                        return "logicalLaneBoundary." + error;
                }
            }
            if (message.logicalLane != null && message.hasOwnProperty("logicalLane")) {
                if (!Array.isArray(message.logicalLane))
                    return "logicalLane: array expected";
                for (let i = 0; i < message.logicalLane.length; ++i) {
                    let error = $root.osi3.LogicalLane.verify(message.logicalLane[i]);
                    if (error)
                        return "logicalLane." + error;
                }
            }
            if (message.projFrameOffset != null && message.hasOwnProperty("projFrameOffset")) {
                let error = $root.osi3.GroundTruth.ProjFrameOffset.verify(message.projFrameOffset);
                if (error)
                    return "projFrameOffset." + error;
            }
            return null;
        };

        /**
         * Creates a GroundTruth message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof osi3.GroundTruth
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {osi3.GroundTruth} GroundTruth
         */
        GroundTruth.fromObject = function fromObject(object) {
            if (object instanceof $root.osi3.GroundTruth)
                return object;
            let message = new $root.osi3.GroundTruth();
            if (object.version != null) {
                if (typeof object.version !== "object")
                    throw TypeError(".osi3.GroundTruth.version: object expected");
                message.version = $root.osi3.InterfaceVersion.fromObject(object.version);
            }
            if (object.timestamp != null) {
                if (typeof object.timestamp !== "object")
                    throw TypeError(".osi3.GroundTruth.timestamp: object expected");
                message.timestamp = $root.osi3.Timestamp.fromObject(object.timestamp);
            }
            if (object.hostVehicleId != null) {
                if (typeof object.hostVehicleId !== "object")
                    throw TypeError(".osi3.GroundTruth.hostVehicleId: object expected");
                message.hostVehicleId = $root.osi3.Identifier.fromObject(object.hostVehicleId);
            }
            if (object.stationaryObject) {
                if (!Array.isArray(object.stationaryObject))
                    throw TypeError(".osi3.GroundTruth.stationaryObject: array expected");
                message.stationaryObject = [];
                for (let i = 0; i < object.stationaryObject.length; ++i) {
                    if (typeof object.stationaryObject[i] !== "object")
                        throw TypeError(".osi3.GroundTruth.stationaryObject: object expected");
                    message.stationaryObject[i] = $root.osi3.StationaryObject.fromObject(object.stationaryObject[i]);
                }
            }
            if (object.movingObject) {
                if (!Array.isArray(object.movingObject))
                    throw TypeError(".osi3.GroundTruth.movingObject: array expected");
                message.movingObject = [];
                for (let i = 0; i < object.movingObject.length; ++i) {
                    if (typeof object.movingObject[i] !== "object")
                        throw TypeError(".osi3.GroundTruth.movingObject: object expected");
                    message.movingObject[i] = $root.osi3.MovingObject.fromObject(object.movingObject[i]);
                }
            }
            if (object.trafficSign) {
                if (!Array.isArray(object.trafficSign))
                    throw TypeError(".osi3.GroundTruth.trafficSign: array expected");
                message.trafficSign = [];
                for (let i = 0; i < object.trafficSign.length; ++i) {
                    if (typeof object.trafficSign[i] !== "object")
                        throw TypeError(".osi3.GroundTruth.trafficSign: object expected");
                    message.trafficSign[i] = $root.osi3.TrafficSign.fromObject(object.trafficSign[i]);
                }
            }
            if (object.trafficLight) {
                if (!Array.isArray(object.trafficLight))
                    throw TypeError(".osi3.GroundTruth.trafficLight: array expected");
                message.trafficLight = [];
                for (let i = 0; i < object.trafficLight.length; ++i) {
                    if (typeof object.trafficLight[i] !== "object")
                        throw TypeError(".osi3.GroundTruth.trafficLight: object expected");
                    message.trafficLight[i] = $root.osi3.TrafficLight.fromObject(object.trafficLight[i]);
                }
            }
            if (object.roadMarking) {
                if (!Array.isArray(object.roadMarking))
                    throw TypeError(".osi3.GroundTruth.roadMarking: array expected");
                message.roadMarking = [];
                for (let i = 0; i < object.roadMarking.length; ++i) {
                    if (typeof object.roadMarking[i] !== "object")
                        throw TypeError(".osi3.GroundTruth.roadMarking: object expected");
                    message.roadMarking[i] = $root.osi3.RoadMarking.fromObject(object.roadMarking[i]);
                }
            }
            if (object.laneBoundary) {
                if (!Array.isArray(object.laneBoundary))
                    throw TypeError(".osi3.GroundTruth.laneBoundary: array expected");
                message.laneBoundary = [];
                for (let i = 0; i < object.laneBoundary.length; ++i) {
                    if (typeof object.laneBoundary[i] !== "object")
                        throw TypeError(".osi3.GroundTruth.laneBoundary: object expected");
                    message.laneBoundary[i] = $root.osi3.LaneBoundary.fromObject(object.laneBoundary[i]);
                }
            }
            if (object.lane) {
                if (!Array.isArray(object.lane))
                    throw TypeError(".osi3.GroundTruth.lane: array expected");
                message.lane = [];
                for (let i = 0; i < object.lane.length; ++i) {
                    if (typeof object.lane[i] !== "object")
                        throw TypeError(".osi3.GroundTruth.lane: object expected");
                    message.lane[i] = $root.osi3.Lane.fromObject(object.lane[i]);
                }
            }
            if (object.occupant) {
                if (!Array.isArray(object.occupant))
                    throw TypeError(".osi3.GroundTruth.occupant: array expected");
                message.occupant = [];
                for (let i = 0; i < object.occupant.length; ++i) {
                    if (typeof object.occupant[i] !== "object")
                        throw TypeError(".osi3.GroundTruth.occupant: object expected");
                    message.occupant[i] = $root.osi3.Occupant.fromObject(object.occupant[i]);
                }
            }
            if (object.environmentalConditions != null) {
                if (typeof object.environmentalConditions !== "object")
                    throw TypeError(".osi3.GroundTruth.environmentalConditions: object expected");
                message.environmentalConditions = $root.osi3.EnvironmentalConditions.fromObject(object.environmentalConditions);
            }
            if (object.countryCode != null)
                message.countryCode = object.countryCode >>> 0;
            if (object.projString != null)
                message.projString = String(object.projString);
            if (object.mapReference != null)
                message.mapReference = String(object.mapReference);
            if (object.modelReference != null)
                message.modelReference = String(object.modelReference);
            if (object.referenceLine) {
                if (!Array.isArray(object.referenceLine))
                    throw TypeError(".osi3.GroundTruth.referenceLine: array expected");
                message.referenceLine = [];
                for (let i = 0; i < object.referenceLine.length; ++i) {
                    if (typeof object.referenceLine[i] !== "object")
                        throw TypeError(".osi3.GroundTruth.referenceLine: object expected");
                    message.referenceLine[i] = $root.osi3.ReferenceLine.fromObject(object.referenceLine[i]);
                }
            }
            if (object.logicalLaneBoundary) {
                if (!Array.isArray(object.logicalLaneBoundary))
                    throw TypeError(".osi3.GroundTruth.logicalLaneBoundary: array expected");
                message.logicalLaneBoundary = [];
                for (let i = 0; i < object.logicalLaneBoundary.length; ++i) {
                    if (typeof object.logicalLaneBoundary[i] !== "object")
                        throw TypeError(".osi3.GroundTruth.logicalLaneBoundary: object expected");
                    message.logicalLaneBoundary[i] = $root.osi3.LogicalLaneBoundary.fromObject(object.logicalLaneBoundary[i]);
                }
            }
            if (object.logicalLane) {
                if (!Array.isArray(object.logicalLane))
                    throw TypeError(".osi3.GroundTruth.logicalLane: array expected");
                message.logicalLane = [];
                for (let i = 0; i < object.logicalLane.length; ++i) {
                    if (typeof object.logicalLane[i] !== "object")
                        throw TypeError(".osi3.GroundTruth.logicalLane: object expected");
                    message.logicalLane[i] = $root.osi3.LogicalLane.fromObject(object.logicalLane[i]);
                }
            }
            if (object.projFrameOffset != null) {
                if (typeof object.projFrameOffset !== "object")
                    throw TypeError(".osi3.GroundTruth.projFrameOffset: object expected");
                message.projFrameOffset = $root.osi3.GroundTruth.ProjFrameOffset.fromObject(object.projFrameOffset);
            }
            return message;
        };

        /**
         * Creates a plain object from a GroundTruth message. Also converts values to other types if specified.
         * @function toObject
         * @memberof osi3.GroundTruth
         * @static
         * @param {osi3.GroundTruth} message GroundTruth
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GroundTruth.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.stationaryObject = [];
                object.movingObject = [];
                object.trafficSign = [];
                object.trafficLight = [];
                object.roadMarking = [];
                object.laneBoundary = [];
                object.lane = [];
                object.occupant = [];
                object.referenceLine = [];
                object.logicalLaneBoundary = [];
                object.logicalLane = [];
            }
            if (options.defaults) {
                object.version = null;
                object.timestamp = null;
                object.hostVehicleId = null;
                object.environmentalConditions = null;
                object.countryCode = 0;
                object.projString = "";
                object.mapReference = "";
                object.modelReference = "";
                object.projFrameOffset = null;
            }
            if (message.version != null && message.hasOwnProperty("version"))
                object.version = $root.osi3.InterfaceVersion.toObject(message.version, options);
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                object.timestamp = $root.osi3.Timestamp.toObject(message.timestamp, options);
            if (message.hostVehicleId != null && message.hasOwnProperty("hostVehicleId"))
                object.hostVehicleId = $root.osi3.Identifier.toObject(message.hostVehicleId, options);
            if (message.stationaryObject && message.stationaryObject.length) {
                object.stationaryObject = [];
                for (let j = 0; j < message.stationaryObject.length; ++j)
                    object.stationaryObject[j] = $root.osi3.StationaryObject.toObject(message.stationaryObject[j], options);
            }
            if (message.movingObject && message.movingObject.length) {
                object.movingObject = [];
                for (let j = 0; j < message.movingObject.length; ++j)
                    object.movingObject[j] = $root.osi3.MovingObject.toObject(message.movingObject[j], options);
            }
            if (message.trafficSign && message.trafficSign.length) {
                object.trafficSign = [];
                for (let j = 0; j < message.trafficSign.length; ++j)
                    object.trafficSign[j] = $root.osi3.TrafficSign.toObject(message.trafficSign[j], options);
            }
            if (message.trafficLight && message.trafficLight.length) {
                object.trafficLight = [];
                for (let j = 0; j < message.trafficLight.length; ++j)
                    object.trafficLight[j] = $root.osi3.TrafficLight.toObject(message.trafficLight[j], options);
            }
            if (message.roadMarking && message.roadMarking.length) {
                object.roadMarking = [];
                for (let j = 0; j < message.roadMarking.length; ++j)
                    object.roadMarking[j] = $root.osi3.RoadMarking.toObject(message.roadMarking[j], options);
            }
            if (message.laneBoundary && message.laneBoundary.length) {
                object.laneBoundary = [];
                for (let j = 0; j < message.laneBoundary.length; ++j)
                    object.laneBoundary[j] = $root.osi3.LaneBoundary.toObject(message.laneBoundary[j], options);
            }
            if (message.lane && message.lane.length) {
                object.lane = [];
                for (let j = 0; j < message.lane.length; ++j)
                    object.lane[j] = $root.osi3.Lane.toObject(message.lane[j], options);
            }
            if (message.occupant && message.occupant.length) {
                object.occupant = [];
                for (let j = 0; j < message.occupant.length; ++j)
                    object.occupant[j] = $root.osi3.Occupant.toObject(message.occupant[j], options);
            }
            if (message.environmentalConditions != null && message.hasOwnProperty("environmentalConditions"))
                object.environmentalConditions = $root.osi3.EnvironmentalConditions.toObject(message.environmentalConditions, options);
            if (message.countryCode != null && message.hasOwnProperty("countryCode"))
                object.countryCode = message.countryCode;
            if (message.projString != null && message.hasOwnProperty("projString"))
                object.projString = message.projString;
            if (message.mapReference != null && message.hasOwnProperty("mapReference"))
                object.mapReference = message.mapReference;
            if (message.modelReference != null && message.hasOwnProperty("modelReference"))
                object.modelReference = message.modelReference;
            if (message.referenceLine && message.referenceLine.length) {
                object.referenceLine = [];
                for (let j = 0; j < message.referenceLine.length; ++j)
                    object.referenceLine[j] = $root.osi3.ReferenceLine.toObject(message.referenceLine[j], options);
            }
            if (message.logicalLaneBoundary && message.logicalLaneBoundary.length) {
                object.logicalLaneBoundary = [];
                for (let j = 0; j < message.logicalLaneBoundary.length; ++j)
                    object.logicalLaneBoundary[j] = $root.osi3.LogicalLaneBoundary.toObject(message.logicalLaneBoundary[j], options);
            }
            if (message.logicalLane && message.logicalLane.length) {
                object.logicalLane = [];
                for (let j = 0; j < message.logicalLane.length; ++j)
                    object.logicalLane[j] = $root.osi3.LogicalLane.toObject(message.logicalLane[j], options);
            }
            if (message.projFrameOffset != null && message.hasOwnProperty("projFrameOffset"))
                object.projFrameOffset = $root.osi3.GroundTruth.ProjFrameOffset.toObject(message.projFrameOffset, options);
            return object;
        };

        /**
         * Converts this GroundTruth to JSON.
         * @function toJSON
         * @memberof osi3.GroundTruth
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GroundTruth.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for GroundTruth
         * @function getTypeUrl
         * @memberof osi3.GroundTruth
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        GroundTruth.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/osi3.GroundTruth";
        };

        GroundTruth.ProjFrameOffset = (function() {

            /**
             * Properties of a ProjFrameOffset.
             * @memberof osi3.GroundTruth
             * @interface IProjFrameOffset
             * @property {osi3.IVector3d|null} [position] ProjFrameOffset position
             * @property {number|null} [yaw] ProjFrameOffset yaw
             */

            /**
             * Constructs a new ProjFrameOffset.
             * @memberof osi3.GroundTruth
             * @classdesc Represents a ProjFrameOffset.
             * @implements IProjFrameOffset
             * @constructor
             * @param {osi3.GroundTruth.IProjFrameOffset=} [properties] Properties to set
             */
            function ProjFrameOffset(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ProjFrameOffset position.
             * @member {osi3.IVector3d|null|undefined} position
             * @memberof osi3.GroundTruth.ProjFrameOffset
             * @instance
             */
            ProjFrameOffset.prototype.position = null;

            /**
             * ProjFrameOffset yaw.
             * @member {number} yaw
             * @memberof osi3.GroundTruth.ProjFrameOffset
             * @instance
             */
            ProjFrameOffset.prototype.yaw = 0;

            /**
             * Creates a new ProjFrameOffset instance using the specified properties.
             * @function create
             * @memberof osi3.GroundTruth.ProjFrameOffset
             * @static
             * @param {osi3.GroundTruth.IProjFrameOffset=} [properties] Properties to set
             * @returns {osi3.GroundTruth.ProjFrameOffset} ProjFrameOffset instance
             */
            ProjFrameOffset.create = function create(properties) {
                return new ProjFrameOffset(properties);
            };

            /**
             * Encodes the specified ProjFrameOffset message. Does not implicitly {@link osi3.GroundTruth.ProjFrameOffset.verify|verify} messages.
             * @function encode
             * @memberof osi3.GroundTruth.ProjFrameOffset
             * @static
             * @param {osi3.GroundTruth.IProjFrameOffset} message ProjFrameOffset message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ProjFrameOffset.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.position != null && Object.hasOwnProperty.call(message, "position"))
                    $root.osi3.Vector3d.encode(message.position, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.yaw != null && Object.hasOwnProperty.call(message, "yaw"))
                    writer.uint32(/* id 2, wireType 1 =*/17).double(message.yaw);
                return writer;
            };

            /**
             * Encodes the specified ProjFrameOffset message, length delimited. Does not implicitly {@link osi3.GroundTruth.ProjFrameOffset.verify|verify} messages.
             * @function encodeDelimited
             * @memberof osi3.GroundTruth.ProjFrameOffset
             * @static
             * @param {osi3.GroundTruth.IProjFrameOffset} message ProjFrameOffset message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ProjFrameOffset.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ProjFrameOffset message from the specified reader or buffer.
             * @function decode
             * @memberof osi3.GroundTruth.ProjFrameOffset
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {osi3.GroundTruth.ProjFrameOffset} ProjFrameOffset
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ProjFrameOffset.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.osi3.GroundTruth.ProjFrameOffset();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.position = $root.osi3.Vector3d.decode(reader, reader.uint32());
                            break;
                        }
                    case 2: {
                            message.yaw = reader.double();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ProjFrameOffset message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof osi3.GroundTruth.ProjFrameOffset
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {osi3.GroundTruth.ProjFrameOffset} ProjFrameOffset
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ProjFrameOffset.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ProjFrameOffset message.
             * @function verify
             * @memberof osi3.GroundTruth.ProjFrameOffset
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ProjFrameOffset.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.position != null && message.hasOwnProperty("position")) {
                    let error = $root.osi3.Vector3d.verify(message.position);
                    if (error)
                        return "position." + error;
                }
                if (message.yaw != null && message.hasOwnProperty("yaw"))
                    if (typeof message.yaw !== "number")
                        return "yaw: number expected";
                return null;
            };

            /**
             * Creates a ProjFrameOffset message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof osi3.GroundTruth.ProjFrameOffset
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {osi3.GroundTruth.ProjFrameOffset} ProjFrameOffset
             */
            ProjFrameOffset.fromObject = function fromObject(object) {
                if (object instanceof $root.osi3.GroundTruth.ProjFrameOffset)
                    return object;
                let message = new $root.osi3.GroundTruth.ProjFrameOffset();
                if (object.position != null) {
                    if (typeof object.position !== "object")
                        throw TypeError(".osi3.GroundTruth.ProjFrameOffset.position: object expected");
                    message.position = $root.osi3.Vector3d.fromObject(object.position);
                }
                if (object.yaw != null)
                    message.yaw = Number(object.yaw);
                return message;
            };

            /**
             * Creates a plain object from a ProjFrameOffset message. Also converts values to other types if specified.
             * @function toObject
             * @memberof osi3.GroundTruth.ProjFrameOffset
             * @static
             * @param {osi3.GroundTruth.ProjFrameOffset} message ProjFrameOffset
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ProjFrameOffset.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.position = null;
                    object.yaw = 0;
                }
                if (message.position != null && message.hasOwnProperty("position"))
                    object.position = $root.osi3.Vector3d.toObject(message.position, options);
                if (message.yaw != null && message.hasOwnProperty("yaw"))
                    object.yaw = options.json && !isFinite(message.yaw) ? String(message.yaw) : message.yaw;
                return object;
            };

            /**
             * Converts this ProjFrameOffset to JSON.
             * @function toJSON
             * @memberof osi3.GroundTruth.ProjFrameOffset
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ProjFrameOffset.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ProjFrameOffset
             * @function getTypeUrl
             * @memberof osi3.GroundTruth.ProjFrameOffset
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ProjFrameOffset.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/osi3.GroundTruth.ProjFrameOffset";
            };

            return ProjFrameOffset;
        })();

        return GroundTruth;
    })();

    osi3.InterfaceVersion = (function() {

        /**
         * Properties of an InterfaceVersion.
         * @memberof osi3
         * @interface IInterfaceVersion
         * @property {number|null} [versionMajor] InterfaceVersion versionMajor
         * @property {number|null} [versionMinor] InterfaceVersion versionMinor
         * @property {number|null} [versionPatch] InterfaceVersion versionPatch
         */

        /**
         * Constructs a new InterfaceVersion.
         * @memberof osi3
         * @classdesc Represents an InterfaceVersion.
         * @implements IInterfaceVersion
         * @constructor
         * @param {osi3.IInterfaceVersion=} [properties] Properties to set
         */
        function InterfaceVersion(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * InterfaceVersion versionMajor.
         * @member {number} versionMajor
         * @memberof osi3.InterfaceVersion
         * @instance
         */
        InterfaceVersion.prototype.versionMajor = 0;

        /**
         * InterfaceVersion versionMinor.
         * @member {number} versionMinor
         * @memberof osi3.InterfaceVersion
         * @instance
         */
        InterfaceVersion.prototype.versionMinor = 0;

        /**
         * InterfaceVersion versionPatch.
         * @member {number} versionPatch
         * @memberof osi3.InterfaceVersion
         * @instance
         */
        InterfaceVersion.prototype.versionPatch = 0;

        /**
         * Creates a new InterfaceVersion instance using the specified properties.
         * @function create
         * @memberof osi3.InterfaceVersion
         * @static
         * @param {osi3.IInterfaceVersion=} [properties] Properties to set
         * @returns {osi3.InterfaceVersion} InterfaceVersion instance
         */
        InterfaceVersion.create = function create(properties) {
            return new InterfaceVersion(properties);
        };

        /**
         * Encodes the specified InterfaceVersion message. Does not implicitly {@link osi3.InterfaceVersion.verify|verify} messages.
         * @function encode
         * @memberof osi3.InterfaceVersion
         * @static
         * @param {osi3.IInterfaceVersion} message InterfaceVersion message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        InterfaceVersion.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.versionMajor != null && Object.hasOwnProperty.call(message, "versionMajor"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.versionMajor);
            if (message.versionMinor != null && Object.hasOwnProperty.call(message, "versionMinor"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.versionMinor);
            if (message.versionPatch != null && Object.hasOwnProperty.call(message, "versionPatch"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.versionPatch);
            return writer;
        };

        /**
         * Encodes the specified InterfaceVersion message, length delimited. Does not implicitly {@link osi3.InterfaceVersion.verify|verify} messages.
         * @function encodeDelimited
         * @memberof osi3.InterfaceVersion
         * @static
         * @param {osi3.IInterfaceVersion} message InterfaceVersion message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        InterfaceVersion.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an InterfaceVersion message from the specified reader or buffer.
         * @function decode
         * @memberof osi3.InterfaceVersion
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {osi3.InterfaceVersion} InterfaceVersion
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InterfaceVersion.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.osi3.InterfaceVersion();
            while (reader.pos < end) {
                let tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.versionMajor = reader.uint32();
                        break;
                    }
                case 2: {
                        message.versionMinor = reader.uint32();
                        break;
                    }
                case 3: {
                        message.versionPatch = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an InterfaceVersion message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof osi3.InterfaceVersion
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {osi3.InterfaceVersion} InterfaceVersion
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InterfaceVersion.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an InterfaceVersion message.
         * @function verify
         * @memberof osi3.InterfaceVersion
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        InterfaceVersion.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.versionMajor != null && message.hasOwnProperty("versionMajor"))
                if (!$util.isInteger(message.versionMajor))
                    return "versionMajor: integer expected";
            if (message.versionMinor != null && message.hasOwnProperty("versionMinor"))
                if (!$util.isInteger(message.versionMinor))
                    return "versionMinor: integer expected";
            if (message.versionPatch != null && message.hasOwnProperty("versionPatch"))
                if (!$util.isInteger(message.versionPatch))
                    return "versionPatch: integer expected";
            return null;
        };

        /**
         * Creates an InterfaceVersion message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof osi3.InterfaceVersion
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {osi3.InterfaceVersion} InterfaceVersion
         */
        InterfaceVersion.fromObject = function fromObject(object) {
            if (object instanceof $root.osi3.InterfaceVersion)
                return object;
            let message = new $root.osi3.InterfaceVersion();
            if (object.versionMajor != null)
                message.versionMajor = object.versionMajor >>> 0;
            if (object.versionMinor != null)
                message.versionMinor = object.versionMinor >>> 0;
            if (object.versionPatch != null)
                message.versionPatch = object.versionPatch >>> 0;
            return message;
        };

        /**
         * Creates a plain object from an InterfaceVersion message. Also converts values to other types if specified.
         * @function toObject
         * @memberof osi3.InterfaceVersion
         * @static
         * @param {osi3.InterfaceVersion} message InterfaceVersion
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        InterfaceVersion.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.versionMajor = 0;
                object.versionMinor = 0;
                object.versionPatch = 0;
            }
            if (message.versionMajor != null && message.hasOwnProperty("versionMajor"))
                object.versionMajor = message.versionMajor;
            if (message.versionMinor != null && message.hasOwnProperty("versionMinor"))
                object.versionMinor = message.versionMinor;
            if (message.versionPatch != null && message.hasOwnProperty("versionPatch"))
                object.versionPatch = message.versionPatch;
            return object;
        };

        /**
         * Converts this InterfaceVersion to JSON.
         * @function toJSON
         * @memberof osi3.InterfaceVersion
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        InterfaceVersion.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for InterfaceVersion
         * @function getTypeUrl
         * @memberof osi3.InterfaceVersion
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        InterfaceVersion.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/osi3.InterfaceVersion";
        };

        return InterfaceVersion;
    })();

    osi3.Vector3d = (function() {

        /**
         * Properties of a Vector3d.
         * @memberof osi3
         * @interface IVector3d
         * @property {number|null} [x] Vector3d x
         * @property {number|null} [y] Vector3d y
         * @property {number|null} [z] Vector3d z
         */

        /**
         * Constructs a new Vector3d.
         * @memberof osi3
         * @classdesc Represents a Vector3d.
         * @implements IVector3d
         * @constructor
         * @param {osi3.IVector3d=} [properties] Properties to set
         */
        function Vector3d(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Vector3d x.
         * @member {number} x
         * @memberof osi3.Vector3d
         * @instance
         */
        Vector3d.prototype.x = 0;

        /**
         * Vector3d y.
         * @member {number} y
         * @memberof osi3.Vector3d
         * @instance
         */
        Vector3d.prototype.y = 0;

        /**
         * Vector3d z.
         * @member {number} z
         * @memberof osi3.Vector3d
         * @instance
         */
        Vector3d.prototype.z = 0;

        /**
         * Creates a new Vector3d instance using the specified properties.
         * @function create
         * @memberof osi3.Vector3d
         * @static
         * @param {osi3.IVector3d=} [properties] Properties to set
         * @returns {osi3.Vector3d} Vector3d instance
         */
        Vector3d.create = function create(properties) {
            return new Vector3d(properties);
        };

        /**
         * Encodes the specified Vector3d message. Does not implicitly {@link osi3.Vector3d.verify|verify} messages.
         * @function encode
         * @memberof osi3.Vector3d
         * @static
         * @param {osi3.IVector3d} message Vector3d message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Vector3d.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.x != null && Object.hasOwnProperty.call(message, "x"))
                writer.uint32(/* id 1, wireType 1 =*/9).double(message.x);
            if (message.y != null && Object.hasOwnProperty.call(message, "y"))
                writer.uint32(/* id 2, wireType 1 =*/17).double(message.y);
            if (message.z != null && Object.hasOwnProperty.call(message, "z"))
                writer.uint32(/* id 3, wireType 1 =*/25).double(message.z);
            return writer;
        };

        /**
         * Encodes the specified Vector3d message, length delimited. Does not implicitly {@link osi3.Vector3d.verify|verify} messages.
         * @function encodeDelimited
         * @memberof osi3.Vector3d
         * @static
         * @param {osi3.IVector3d} message Vector3d message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Vector3d.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Vector3d message from the specified reader or buffer.
         * @function decode
         * @memberof osi3.Vector3d
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {osi3.Vector3d} Vector3d
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Vector3d.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.osi3.Vector3d();
            while (reader.pos < end) {
                let tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.x = reader.double();
                        break;
                    }
                case 2: {
                        message.y = reader.double();
                        break;
                    }
                case 3: {
                        message.z = reader.double();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Vector3d message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof osi3.Vector3d
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {osi3.Vector3d} Vector3d
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Vector3d.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Vector3d message.
         * @function verify
         * @memberof osi3.Vector3d
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Vector3d.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.x != null && message.hasOwnProperty("x"))
                if (typeof message.x !== "number")
                    return "x: number expected";
            if (message.y != null && message.hasOwnProperty("y"))
                if (typeof message.y !== "number")
                    return "y: number expected";
            if (message.z != null && message.hasOwnProperty("z"))
                if (typeof message.z !== "number")
                    return "z: number expected";
            return null;
        };

        /**
         * Creates a Vector3d message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof osi3.Vector3d
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {osi3.Vector3d} Vector3d
         */
        Vector3d.fromObject = function fromObject(object) {
            if (object instanceof $root.osi3.Vector3d)
                return object;
            let message = new $root.osi3.Vector3d();
            if (object.x != null)
                message.x = Number(object.x);
            if (object.y != null)
                message.y = Number(object.y);
            if (object.z != null)
                message.z = Number(object.z);
            return message;
        };

        /**
         * Creates a plain object from a Vector3d message. Also converts values to other types if specified.
         * @function toObject
         * @memberof osi3.Vector3d
         * @static
         * @param {osi3.Vector3d} message Vector3d
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Vector3d.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.x = 0;
                object.y = 0;
                object.z = 0;
            }
            if (message.x != null && message.hasOwnProperty("x"))
                object.x = options.json && !isFinite(message.x) ? String(message.x) : message.x;
            if (message.y != null && message.hasOwnProperty("y"))
                object.y = options.json && !isFinite(message.y) ? String(message.y) : message.y;
            if (message.z != null && message.hasOwnProperty("z"))
                object.z = options.json && !isFinite(message.z) ? String(message.z) : message.z;
            return object;
        };

        /**
         * Converts this Vector3d to JSON.
         * @function toJSON
         * @memberof osi3.Vector3d
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Vector3d.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Vector3d
         * @function getTypeUrl
         * @memberof osi3.Vector3d
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Vector3d.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/osi3.Vector3d";
        };

        return Vector3d;
    })();

    osi3.Vector2d = (function() {

        /**
         * Properties of a Vector2d.
         * @memberof osi3
         * @interface IVector2d
         * @property {number|null} [x] Vector2d x
         * @property {number|null} [y] Vector2d y
         */

        /**
         * Constructs a new Vector2d.
         * @memberof osi3
         * @classdesc Represents a Vector2d.
         * @implements IVector2d
         * @constructor
         * @param {osi3.IVector2d=} [properties] Properties to set
         */
        function Vector2d(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Vector2d x.
         * @member {number} x
         * @memberof osi3.Vector2d
         * @instance
         */
        Vector2d.prototype.x = 0;

        /**
         * Vector2d y.
         * @member {number} y
         * @memberof osi3.Vector2d
         * @instance
         */
        Vector2d.prototype.y = 0;

        /**
         * Creates a new Vector2d instance using the specified properties.
         * @function create
         * @memberof osi3.Vector2d
         * @static
         * @param {osi3.IVector2d=} [properties] Properties to set
         * @returns {osi3.Vector2d} Vector2d instance
         */
        Vector2d.create = function create(properties) {
            return new Vector2d(properties);
        };

        /**
         * Encodes the specified Vector2d message. Does not implicitly {@link osi3.Vector2d.verify|verify} messages.
         * @function encode
         * @memberof osi3.Vector2d
         * @static
         * @param {osi3.IVector2d} message Vector2d message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Vector2d.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.x != null && Object.hasOwnProperty.call(message, "x"))
                writer.uint32(/* id 1, wireType 1 =*/9).double(message.x);
            if (message.y != null && Object.hasOwnProperty.call(message, "y"))
                writer.uint32(/* id 2, wireType 1 =*/17).double(message.y);
            return writer;
        };

        /**
         * Encodes the specified Vector2d message, length delimited. Does not implicitly {@link osi3.Vector2d.verify|verify} messages.
         * @function encodeDelimited
         * @memberof osi3.Vector2d
         * @static
         * @param {osi3.IVector2d} message Vector2d message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Vector2d.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Vector2d message from the specified reader or buffer.
         * @function decode
         * @memberof osi3.Vector2d
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {osi3.Vector2d} Vector2d
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Vector2d.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.osi3.Vector2d();
            while (reader.pos < end) {
                let tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.x = reader.double();
                        break;
                    }
                case 2: {
                        message.y = reader.double();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Vector2d message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof osi3.Vector2d
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {osi3.Vector2d} Vector2d
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Vector2d.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Vector2d message.
         * @function verify
         * @memberof osi3.Vector2d
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Vector2d.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.x != null && message.hasOwnProperty("x"))
                if (typeof message.x !== "number")
                    return "x: number expected";
            if (message.y != null && message.hasOwnProperty("y"))
                if (typeof message.y !== "number")
                    return "y: number expected";
            return null;
        };

        /**
         * Creates a Vector2d message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof osi3.Vector2d
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {osi3.Vector2d} Vector2d
         */
        Vector2d.fromObject = function fromObject(object) {
            if (object instanceof $root.osi3.Vector2d)
                return object;
            let message = new $root.osi3.Vector2d();
            if (object.x != null)
                message.x = Number(object.x);
            if (object.y != null)
                message.y = Number(object.y);
            return message;
        };

        /**
         * Creates a plain object from a Vector2d message. Also converts values to other types if specified.
         * @function toObject
         * @memberof osi3.Vector2d
         * @static
         * @param {osi3.Vector2d} message Vector2d
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Vector2d.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.x = 0;
                object.y = 0;
            }
            if (message.x != null && message.hasOwnProperty("x"))
                object.x = options.json && !isFinite(message.x) ? String(message.x) : message.x;
            if (message.y != null && message.hasOwnProperty("y"))
                object.y = options.json && !isFinite(message.y) ? String(message.y) : message.y;
            return object;
        };

        /**
         * Converts this Vector2d to JSON.
         * @function toJSON
         * @memberof osi3.Vector2d
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Vector2d.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Vector2d
         * @function getTypeUrl
         * @memberof osi3.Vector2d
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Vector2d.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/osi3.Vector2d";
        };

        return Vector2d;
    })();

    osi3.Timestamp = (function() {

        /**
         * Properties of a Timestamp.
         * @memberof osi3
         * @interface ITimestamp
         * @property {number|Long|null} [seconds] Timestamp seconds
         * @property {number|null} [nanos] Timestamp nanos
         */

        /**
         * Constructs a new Timestamp.
         * @memberof osi3
         * @classdesc Represents a Timestamp.
         * @implements ITimestamp
         * @constructor
         * @param {osi3.ITimestamp=} [properties] Properties to set
         */
        function Timestamp(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Timestamp seconds.
         * @member {number|Long} seconds
         * @memberof osi3.Timestamp
         * @instance
         */
        Timestamp.prototype.seconds = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Timestamp nanos.
         * @member {number} nanos
         * @memberof osi3.Timestamp
         * @instance
         */
        Timestamp.prototype.nanos = 0;

        /**
         * Creates a new Timestamp instance using the specified properties.
         * @function create
         * @memberof osi3.Timestamp
         * @static
         * @param {osi3.ITimestamp=} [properties] Properties to set
         * @returns {osi3.Timestamp} Timestamp instance
         */
        Timestamp.create = function create(properties) {
            return new Timestamp(properties);
        };

        /**
         * Encodes the specified Timestamp message. Does not implicitly {@link osi3.Timestamp.verify|verify} messages.
         * @function encode
         * @memberof osi3.Timestamp
         * @static
         * @param {osi3.ITimestamp} message Timestamp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Timestamp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.seconds != null && Object.hasOwnProperty.call(message, "seconds"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.seconds);
            if (message.nanos != null && Object.hasOwnProperty.call(message, "nanos"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.nanos);
            return writer;
        };

        /**
         * Encodes the specified Timestamp message, length delimited. Does not implicitly {@link osi3.Timestamp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof osi3.Timestamp
         * @static
         * @param {osi3.ITimestamp} message Timestamp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Timestamp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Timestamp message from the specified reader or buffer.
         * @function decode
         * @memberof osi3.Timestamp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {osi3.Timestamp} Timestamp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Timestamp.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.osi3.Timestamp();
            while (reader.pos < end) {
                let tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.seconds = reader.int64();
                        break;
                    }
                case 2: {
                        message.nanos = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Timestamp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof osi3.Timestamp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {osi3.Timestamp} Timestamp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Timestamp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Timestamp message.
         * @function verify
         * @memberof osi3.Timestamp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Timestamp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.seconds != null && message.hasOwnProperty("seconds"))
                if (!$util.isInteger(message.seconds) && !(message.seconds && $util.isInteger(message.seconds.low) && $util.isInteger(message.seconds.high)))
                    return "seconds: integer|Long expected";
            if (message.nanos != null && message.hasOwnProperty("nanos"))
                if (!$util.isInteger(message.nanos))
                    return "nanos: integer expected";
            return null;
        };

        /**
         * Creates a Timestamp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof osi3.Timestamp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {osi3.Timestamp} Timestamp
         */
        Timestamp.fromObject = function fromObject(object) {
            if (object instanceof $root.osi3.Timestamp)
                return object;
            let message = new $root.osi3.Timestamp();
            if (object.seconds != null)
                if ($util.Long)
                    (message.seconds = $util.Long.fromValue(object.seconds)).unsigned = false;
                else if (typeof object.seconds === "string")
                    message.seconds = parseInt(object.seconds, 10);
                else if (typeof object.seconds === "number")
                    message.seconds = object.seconds;
                else if (typeof object.seconds === "object")
                    message.seconds = new $util.LongBits(object.seconds.low >>> 0, object.seconds.high >>> 0).toNumber();
            if (object.nanos != null)
                message.nanos = object.nanos >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a Timestamp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof osi3.Timestamp
         * @static
         * @param {osi3.Timestamp} message Timestamp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Timestamp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.seconds = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.seconds = options.longs === String ? "0" : 0;
                object.nanos = 0;
            }
            if (message.seconds != null && message.hasOwnProperty("seconds"))
                if (typeof message.seconds === "number")
                    object.seconds = options.longs === String ? String(message.seconds) : message.seconds;
                else
                    object.seconds = options.longs === String ? $util.Long.prototype.toString.call(message.seconds) : options.longs === Number ? new $util.LongBits(message.seconds.low >>> 0, message.seconds.high >>> 0).toNumber() : message.seconds;
            if (message.nanos != null && message.hasOwnProperty("nanos"))
                object.nanos = message.nanos;
            return object;
        };

        /**
         * Converts this Timestamp to JSON.
         * @function toJSON
         * @memberof osi3.Timestamp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Timestamp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Timestamp
         * @function getTypeUrl
         * @memberof osi3.Timestamp
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Timestamp.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/osi3.Timestamp";
        };

        return Timestamp;
    })();

    osi3.Dimension3d = (function() {

        /**
         * Properties of a Dimension3d.
         * @memberof osi3
         * @interface IDimension3d
         * @property {number|null} [length] Dimension3d length
         * @property {number|null} [width] Dimension3d width
         * @property {number|null} [height] Dimension3d height
         */

        /**
         * Constructs a new Dimension3d.
         * @memberof osi3
         * @classdesc Represents a Dimension3d.
         * @implements IDimension3d
         * @constructor
         * @param {osi3.IDimension3d=} [properties] Properties to set
         */
        function Dimension3d(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Dimension3d length.
         * @member {number} length
         * @memberof osi3.Dimension3d
         * @instance
         */
        Dimension3d.prototype.length = 0;

        /**
         * Dimension3d width.
         * @member {number} width
         * @memberof osi3.Dimension3d
         * @instance
         */
        Dimension3d.prototype.width = 0;

        /**
         * Dimension3d height.
         * @member {number} height
         * @memberof osi3.Dimension3d
         * @instance
         */
        Dimension3d.prototype.height = 0;

        /**
         * Creates a new Dimension3d instance using the specified properties.
         * @function create
         * @memberof osi3.Dimension3d
         * @static
         * @param {osi3.IDimension3d=} [properties] Properties to set
         * @returns {osi3.Dimension3d} Dimension3d instance
         */
        Dimension3d.create = function create(properties) {
            return new Dimension3d(properties);
        };

        /**
         * Encodes the specified Dimension3d message. Does not implicitly {@link osi3.Dimension3d.verify|verify} messages.
         * @function encode
         * @memberof osi3.Dimension3d
         * @static
         * @param {osi3.IDimension3d} message Dimension3d message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Dimension3d.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.length != null && Object.hasOwnProperty.call(message, "length"))
                writer.uint32(/* id 1, wireType 1 =*/9).double(message.length);
            if (message.width != null && Object.hasOwnProperty.call(message, "width"))
                writer.uint32(/* id 2, wireType 1 =*/17).double(message.width);
            if (message.height != null && Object.hasOwnProperty.call(message, "height"))
                writer.uint32(/* id 3, wireType 1 =*/25).double(message.height);
            return writer;
        };

        /**
         * Encodes the specified Dimension3d message, length delimited. Does not implicitly {@link osi3.Dimension3d.verify|verify} messages.
         * @function encodeDelimited
         * @memberof osi3.Dimension3d
         * @static
         * @param {osi3.IDimension3d} message Dimension3d message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Dimension3d.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Dimension3d message from the specified reader or buffer.
         * @function decode
         * @memberof osi3.Dimension3d
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {osi3.Dimension3d} Dimension3d
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Dimension3d.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.osi3.Dimension3d();
            while (reader.pos < end) {
                let tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.length = reader.double();
                        break;
                    }
                case 2: {
                        message.width = reader.double();
                        break;
                    }
                case 3: {
                        message.height = reader.double();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Dimension3d message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof osi3.Dimension3d
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {osi3.Dimension3d} Dimension3d
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Dimension3d.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Dimension3d message.
         * @function verify
         * @memberof osi3.Dimension3d
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Dimension3d.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.length != null && message.hasOwnProperty("length"))
                if (typeof message.length !== "number")
                    return "length: number expected";
            if (message.width != null && message.hasOwnProperty("width"))
                if (typeof message.width !== "number")
                    return "width: number expected";
            if (message.height != null && message.hasOwnProperty("height"))
                if (typeof message.height !== "number")
                    return "height: number expected";
            return null;
        };

        /**
         * Creates a Dimension3d message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof osi3.Dimension3d
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {osi3.Dimension3d} Dimension3d
         */
        Dimension3d.fromObject = function fromObject(object) {
            if (object instanceof $root.osi3.Dimension3d)
                return object;
            let message = new $root.osi3.Dimension3d();
            if (object.length != null)
                message.length = Number(object.length);
            if (object.width != null)
                message.width = Number(object.width);
            if (object.height != null)
                message.height = Number(object.height);
            return message;
        };

        /**
         * Creates a plain object from a Dimension3d message. Also converts values to other types if specified.
         * @function toObject
         * @memberof osi3.Dimension3d
         * @static
         * @param {osi3.Dimension3d} message Dimension3d
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Dimension3d.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.length = 0;
                object.width = 0;
                object.height = 0;
            }
            if (message.length != null && message.hasOwnProperty("length"))
                object.length = options.json && !isFinite(message.length) ? String(message.length) : message.length;
            if (message.width != null && message.hasOwnProperty("width"))
                object.width = options.json && !isFinite(message.width) ? String(message.width) : message.width;
            if (message.height != null && message.hasOwnProperty("height"))
                object.height = options.json && !isFinite(message.height) ? String(message.height) : message.height;
            return object;
        };

        /**
         * Converts this Dimension3d to JSON.
         * @function toJSON
         * @memberof osi3.Dimension3d
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Dimension3d.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Dimension3d
         * @function getTypeUrl
         * @memberof osi3.Dimension3d
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Dimension3d.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/osi3.Dimension3d";
        };

        return Dimension3d;
    })();

    osi3.Orientation3d = (function() {

        /**
         * Properties of an Orientation3d.
         * @memberof osi3
         * @interface IOrientation3d
         * @property {number|null} [roll] Orientation3d roll
         * @property {number|null} [pitch] Orientation3d pitch
         * @property {number|null} [yaw] Orientation3d yaw
         */

        /**
         * Constructs a new Orientation3d.
         * @memberof osi3
         * @classdesc Represents an Orientation3d.
         * @implements IOrientation3d
         * @constructor
         * @param {osi3.IOrientation3d=} [properties] Properties to set
         */
        function Orientation3d(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Orientation3d roll.
         * @member {number} roll
         * @memberof osi3.Orientation3d
         * @instance
         */
        Orientation3d.prototype.roll = 0;

        /**
         * Orientation3d pitch.
         * @member {number} pitch
         * @memberof osi3.Orientation3d
         * @instance
         */
        Orientation3d.prototype.pitch = 0;

        /**
         * Orientation3d yaw.
         * @member {number} yaw
         * @memberof osi3.Orientation3d
         * @instance
         */
        Orientation3d.prototype.yaw = 0;

        /**
         * Creates a new Orientation3d instance using the specified properties.
         * @function create
         * @memberof osi3.Orientation3d
         * @static
         * @param {osi3.IOrientation3d=} [properties] Properties to set
         * @returns {osi3.Orientation3d} Orientation3d instance
         */
        Orientation3d.create = function create(properties) {
            return new Orientation3d(properties);
        };

        /**
         * Encodes the specified Orientation3d message. Does not implicitly {@link osi3.Orientation3d.verify|verify} messages.
         * @function encode
         * @memberof osi3.Orientation3d
         * @static
         * @param {osi3.IOrientation3d} message Orientation3d message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Orientation3d.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.roll != null && Object.hasOwnProperty.call(message, "roll"))
                writer.uint32(/* id 1, wireType 1 =*/9).double(message.roll);
            if (message.pitch != null && Object.hasOwnProperty.call(message, "pitch"))
                writer.uint32(/* id 2, wireType 1 =*/17).double(message.pitch);
            if (message.yaw != null && Object.hasOwnProperty.call(message, "yaw"))
                writer.uint32(/* id 3, wireType 1 =*/25).double(message.yaw);
            return writer;
        };

        /**
         * Encodes the specified Orientation3d message, length delimited. Does not implicitly {@link osi3.Orientation3d.verify|verify} messages.
         * @function encodeDelimited
         * @memberof osi3.Orientation3d
         * @static
         * @param {osi3.IOrientation3d} message Orientation3d message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Orientation3d.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Orientation3d message from the specified reader or buffer.
         * @function decode
         * @memberof osi3.Orientation3d
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {osi3.Orientation3d} Orientation3d
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Orientation3d.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.osi3.Orientation3d();
            while (reader.pos < end) {
                let tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.roll = reader.double();
                        break;
                    }
                case 2: {
                        message.pitch = reader.double();
                        break;
                    }
                case 3: {
                        message.yaw = reader.double();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Orientation3d message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof osi3.Orientation3d
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {osi3.Orientation3d} Orientation3d
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Orientation3d.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Orientation3d message.
         * @function verify
         * @memberof osi3.Orientation3d
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Orientation3d.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.roll != null && message.hasOwnProperty("roll"))
                if (typeof message.roll !== "number")
                    return "roll: number expected";
            if (message.pitch != null && message.hasOwnProperty("pitch"))
                if (typeof message.pitch !== "number")
                    return "pitch: number expected";
            if (message.yaw != null && message.hasOwnProperty("yaw"))
                if (typeof message.yaw !== "number")
                    return "yaw: number expected";
            return null;
        };

        /**
         * Creates an Orientation3d message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof osi3.Orientation3d
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {osi3.Orientation3d} Orientation3d
         */
        Orientation3d.fromObject = function fromObject(object) {
            if (object instanceof $root.osi3.Orientation3d)
                return object;
            let message = new $root.osi3.Orientation3d();
            if (object.roll != null)
                message.roll = Number(object.roll);
            if (object.pitch != null)
                message.pitch = Number(object.pitch);
            if (object.yaw != null)
                message.yaw = Number(object.yaw);
            return message;
        };

        /**
         * Creates a plain object from an Orientation3d message. Also converts values to other types if specified.
         * @function toObject
         * @memberof osi3.Orientation3d
         * @static
         * @param {osi3.Orientation3d} message Orientation3d
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Orientation3d.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.roll = 0;
                object.pitch = 0;
                object.yaw = 0;
            }
            if (message.roll != null && message.hasOwnProperty("roll"))
                object.roll = options.json && !isFinite(message.roll) ? String(message.roll) : message.roll;
            if (message.pitch != null && message.hasOwnProperty("pitch"))
                object.pitch = options.json && !isFinite(message.pitch) ? String(message.pitch) : message.pitch;
            if (message.yaw != null && message.hasOwnProperty("yaw"))
                object.yaw = options.json && !isFinite(message.yaw) ? String(message.yaw) : message.yaw;
            return object;
        };

        /**
         * Converts this Orientation3d to JSON.
         * @function toJSON
         * @memberof osi3.Orientation3d
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Orientation3d.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Orientation3d
         * @function getTypeUrl
         * @memberof osi3.Orientation3d
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Orientation3d.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/osi3.Orientation3d";
        };

        return Orientation3d;
    })();

    osi3.Identifier = (function() {

        /**
         * Properties of an Identifier.
         * @memberof osi3
         * @interface IIdentifier
         * @property {number|Long|null} [value] Identifier value
         */

        /**
         * Constructs a new Identifier.
         * @memberof osi3
         * @classdesc Represents an Identifier.
         * @implements IIdentifier
         * @constructor
         * @param {osi3.IIdentifier=} [properties] Properties to set
         */
        function Identifier(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Identifier value.
         * @member {number|Long} value
         * @memberof osi3.Identifier
         * @instance
         */
        Identifier.prototype.value = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new Identifier instance using the specified properties.
         * @function create
         * @memberof osi3.Identifier
         * @static
         * @param {osi3.IIdentifier=} [properties] Properties to set
         * @returns {osi3.Identifier} Identifier instance
         */
        Identifier.create = function create(properties) {
            return new Identifier(properties);
        };

        /**
         * Encodes the specified Identifier message. Does not implicitly {@link osi3.Identifier.verify|verify} messages.
         * @function encode
         * @memberof osi3.Identifier
         * @static
         * @param {osi3.IIdentifier} message Identifier message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Identifier.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.value);
            return writer;
        };

        /**
         * Encodes the specified Identifier message, length delimited. Does not implicitly {@link osi3.Identifier.verify|verify} messages.
         * @function encodeDelimited
         * @memberof osi3.Identifier
         * @static
         * @param {osi3.IIdentifier} message Identifier message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Identifier.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Identifier message from the specified reader or buffer.
         * @function decode
         * @memberof osi3.Identifier
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {osi3.Identifier} Identifier
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Identifier.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.osi3.Identifier();
            while (reader.pos < end) {
                let tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.value = reader.uint64();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Identifier message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof osi3.Identifier
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {osi3.Identifier} Identifier
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Identifier.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Identifier message.
         * @function verify
         * @memberof osi3.Identifier
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Identifier.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.value != null && message.hasOwnProperty("value"))
                if (!$util.isInteger(message.value) && !(message.value && $util.isInteger(message.value.low) && $util.isInteger(message.value.high)))
                    return "value: integer|Long expected";
            return null;
        };

        /**
         * Creates an Identifier message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof osi3.Identifier
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {osi3.Identifier} Identifier
         */
        Identifier.fromObject = function fromObject(object) {
            if (object instanceof $root.osi3.Identifier)
                return object;
            let message = new $root.osi3.Identifier();
            if (object.value != null)
                if ($util.Long)
                    (message.value = $util.Long.fromValue(object.value)).unsigned = true;
                else if (typeof object.value === "string")
                    message.value = parseInt(object.value, 10);
                else if (typeof object.value === "number")
                    message.value = object.value;
                else if (typeof object.value === "object")
                    message.value = new $util.LongBits(object.value.low >>> 0, object.value.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from an Identifier message. Also converts values to other types if specified.
         * @function toObject
         * @memberof osi3.Identifier
         * @static
         * @param {osi3.Identifier} message Identifier
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Identifier.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.value = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.value = options.longs === String ? "0" : 0;
            if (message.value != null && message.hasOwnProperty("value"))
                if (typeof message.value === "number")
                    object.value = options.longs === String ? String(message.value) : message.value;
                else
                    object.value = options.longs === String ? $util.Long.prototype.toString.call(message.value) : options.longs === Number ? new $util.LongBits(message.value.low >>> 0, message.value.high >>> 0).toNumber(true) : message.value;
            return object;
        };

        /**
         * Converts this Identifier to JSON.
         * @function toJSON
         * @memberof osi3.Identifier
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Identifier.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Identifier
         * @function getTypeUrl
         * @memberof osi3.Identifier
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Identifier.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/osi3.Identifier";
        };

        return Identifier;
    })();

    osi3.ExternalReference = (function() {

        /**
         * Properties of an ExternalReference.
         * @memberof osi3
         * @interface IExternalReference
         * @property {string|null} [reference] ExternalReference reference
         * @property {string|null} [type] ExternalReference type
         * @property {Array.<string>|null} [identifier] ExternalReference identifier
         */

        /**
         * Constructs a new ExternalReference.
         * @memberof osi3
         * @classdesc Represents an ExternalReference.
         * @implements IExternalReference
         * @constructor
         * @param {osi3.IExternalReference=} [properties] Properties to set
         */
        function ExternalReference(properties) {
            this.identifier = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ExternalReference reference.
         * @member {string} reference
         * @memberof osi3.ExternalReference
         * @instance
         */
        ExternalReference.prototype.reference = "";

        /**
         * ExternalReference type.
         * @member {string} type
         * @memberof osi3.ExternalReference
         * @instance
         */
        ExternalReference.prototype.type = "";

        /**
         * ExternalReference identifier.
         * @member {Array.<string>} identifier
         * @memberof osi3.ExternalReference
         * @instance
         */
        ExternalReference.prototype.identifier = $util.emptyArray;

        /**
         * Creates a new ExternalReference instance using the specified properties.
         * @function create
         * @memberof osi3.ExternalReference
         * @static
         * @param {osi3.IExternalReference=} [properties] Properties to set
         * @returns {osi3.ExternalReference} ExternalReference instance
         */
        ExternalReference.create = function create(properties) {
            return new ExternalReference(properties);
        };

        /**
         * Encodes the specified ExternalReference message. Does not implicitly {@link osi3.ExternalReference.verify|verify} messages.
         * @function encode
         * @memberof osi3.ExternalReference
         * @static
         * @param {osi3.IExternalReference} message ExternalReference message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExternalReference.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.reference != null && Object.hasOwnProperty.call(message, "reference"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.reference);
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.type);
            if (message.identifier != null && message.identifier.length)
                for (let i = 0; i < message.identifier.length; ++i)
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.identifier[i]);
            return writer;
        };

        /**
         * Encodes the specified ExternalReference message, length delimited. Does not implicitly {@link osi3.ExternalReference.verify|verify} messages.
         * @function encodeDelimited
         * @memberof osi3.ExternalReference
         * @static
         * @param {osi3.IExternalReference} message ExternalReference message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExternalReference.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ExternalReference message from the specified reader or buffer.
         * @function decode
         * @memberof osi3.ExternalReference
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {osi3.ExternalReference} ExternalReference
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExternalReference.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.osi3.ExternalReference();
            while (reader.pos < end) {
                let tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.reference = reader.string();
                        break;
                    }
                case 2: {
                        message.type = reader.string();
                        break;
                    }
                case 3: {
                        if (!(message.identifier && message.identifier.length))
                            message.identifier = [];
                        message.identifier.push(reader.string());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ExternalReference message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof osi3.ExternalReference
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {osi3.ExternalReference} ExternalReference
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExternalReference.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ExternalReference message.
         * @function verify
         * @memberof osi3.ExternalReference
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ExternalReference.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.reference != null && message.hasOwnProperty("reference"))
                if (!$util.isString(message.reference))
                    return "reference: string expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isString(message.type))
                    return "type: string expected";
            if (message.identifier != null && message.hasOwnProperty("identifier")) {
                if (!Array.isArray(message.identifier))
                    return "identifier: array expected";
                for (let i = 0; i < message.identifier.length; ++i)
                    if (!$util.isString(message.identifier[i]))
                        return "identifier: string[] expected";
            }
            return null;
        };

        /**
         * Creates an ExternalReference message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof osi3.ExternalReference
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {osi3.ExternalReference} ExternalReference
         */
        ExternalReference.fromObject = function fromObject(object) {
            if (object instanceof $root.osi3.ExternalReference)
                return object;
            let message = new $root.osi3.ExternalReference();
            if (object.reference != null)
                message.reference = String(object.reference);
            if (object.type != null)
                message.type = String(object.type);
            if (object.identifier) {
                if (!Array.isArray(object.identifier))
                    throw TypeError(".osi3.ExternalReference.identifier: array expected");
                message.identifier = [];
                for (let i = 0; i < object.identifier.length; ++i)
                    message.identifier[i] = String(object.identifier[i]);
            }
            return message;
        };

        /**
         * Creates a plain object from an ExternalReference message. Also converts values to other types if specified.
         * @function toObject
         * @memberof osi3.ExternalReference
         * @static
         * @param {osi3.ExternalReference} message ExternalReference
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ExternalReference.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.identifier = [];
            if (options.defaults) {
                object.reference = "";
                object.type = "";
            }
            if (message.reference != null && message.hasOwnProperty("reference"))
                object.reference = message.reference;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.identifier && message.identifier.length) {
                object.identifier = [];
                for (let j = 0; j < message.identifier.length; ++j)
                    object.identifier[j] = message.identifier[j];
            }
            return object;
        };

        /**
         * Converts this ExternalReference to JSON.
         * @function toJSON
         * @memberof osi3.ExternalReference
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ExternalReference.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ExternalReference
         * @function getTypeUrl
         * @memberof osi3.ExternalReference
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ExternalReference.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/osi3.ExternalReference";
        };

        return ExternalReference;
    })();

    osi3.MountingPosition = (function() {

        /**
         * Properties of a MountingPosition.
         * @memberof osi3
         * @interface IMountingPosition
         * @property {osi3.IVector3d|null} [position] MountingPosition position
         * @property {osi3.IOrientation3d|null} [orientation] MountingPosition orientation
         */

        /**
         * Constructs a new MountingPosition.
         * @memberof osi3
         * @classdesc Represents a MountingPosition.
         * @implements IMountingPosition
         * @constructor
         * @param {osi3.IMountingPosition=} [properties] Properties to set
         */
        function MountingPosition(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MountingPosition position.
         * @member {osi3.IVector3d|null|undefined} position
         * @memberof osi3.MountingPosition
         * @instance
         */
        MountingPosition.prototype.position = null;

        /**
         * MountingPosition orientation.
         * @member {osi3.IOrientation3d|null|undefined} orientation
         * @memberof osi3.MountingPosition
         * @instance
         */
        MountingPosition.prototype.orientation = null;

        /**
         * Creates a new MountingPosition instance using the specified properties.
         * @function create
         * @memberof osi3.MountingPosition
         * @static
         * @param {osi3.IMountingPosition=} [properties] Properties to set
         * @returns {osi3.MountingPosition} MountingPosition instance
         */
        MountingPosition.create = function create(properties) {
            return new MountingPosition(properties);
        };

        /**
         * Encodes the specified MountingPosition message. Does not implicitly {@link osi3.MountingPosition.verify|verify} messages.
         * @function encode
         * @memberof osi3.MountingPosition
         * @static
         * @param {osi3.IMountingPosition} message MountingPosition message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MountingPosition.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.position != null && Object.hasOwnProperty.call(message, "position"))
                $root.osi3.Vector3d.encode(message.position, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.orientation != null && Object.hasOwnProperty.call(message, "orientation"))
                $root.osi3.Orientation3d.encode(message.orientation, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified MountingPosition message, length delimited. Does not implicitly {@link osi3.MountingPosition.verify|verify} messages.
         * @function encodeDelimited
         * @memberof osi3.MountingPosition
         * @static
         * @param {osi3.IMountingPosition} message MountingPosition message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MountingPosition.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MountingPosition message from the specified reader or buffer.
         * @function decode
         * @memberof osi3.MountingPosition
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {osi3.MountingPosition} MountingPosition
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MountingPosition.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.osi3.MountingPosition();
            while (reader.pos < end) {
                let tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.position = $root.osi3.Vector3d.decode(reader, reader.uint32());
                        break;
                    }
                case 2: {
                        message.orientation = $root.osi3.Orientation3d.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MountingPosition message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof osi3.MountingPosition
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {osi3.MountingPosition} MountingPosition
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MountingPosition.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MountingPosition message.
         * @function verify
         * @memberof osi3.MountingPosition
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MountingPosition.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.position != null && message.hasOwnProperty("position")) {
                let error = $root.osi3.Vector3d.verify(message.position);
                if (error)
                    return "position." + error;
            }
            if (message.orientation != null && message.hasOwnProperty("orientation")) {
                let error = $root.osi3.Orientation3d.verify(message.orientation);
                if (error)
                    return "orientation." + error;
            }
            return null;
        };

        /**
         * Creates a MountingPosition message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof osi3.MountingPosition
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {osi3.MountingPosition} MountingPosition
         */
        MountingPosition.fromObject = function fromObject(object) {
            if (object instanceof $root.osi3.MountingPosition)
                return object;
            let message = new $root.osi3.MountingPosition();
            if (object.position != null) {
                if (typeof object.position !== "object")
                    throw TypeError(".osi3.MountingPosition.position: object expected");
                message.position = $root.osi3.Vector3d.fromObject(object.position);
            }
            if (object.orientation != null) {
                if (typeof object.orientation !== "object")
                    throw TypeError(".osi3.MountingPosition.orientation: object expected");
                message.orientation = $root.osi3.Orientation3d.fromObject(object.orientation);
            }
            return message;
        };

        /**
         * Creates a plain object from a MountingPosition message. Also converts values to other types if specified.
         * @function toObject
         * @memberof osi3.MountingPosition
         * @static
         * @param {osi3.MountingPosition} message MountingPosition
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MountingPosition.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.position = null;
                object.orientation = null;
            }
            if (message.position != null && message.hasOwnProperty("position"))
                object.position = $root.osi3.Vector3d.toObject(message.position, options);
            if (message.orientation != null && message.hasOwnProperty("orientation"))
                object.orientation = $root.osi3.Orientation3d.toObject(message.orientation, options);
            return object;
        };

        /**
         * Converts this MountingPosition to JSON.
         * @function toJSON
         * @memberof osi3.MountingPosition
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MountingPosition.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for MountingPosition
         * @function getTypeUrl
         * @memberof osi3.MountingPosition
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        MountingPosition.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/osi3.MountingPosition";
        };

        return MountingPosition;
    })();

    osi3.Spherical3d = (function() {

        /**
         * Properties of a Spherical3d.
         * @memberof osi3
         * @interface ISpherical3d
         * @property {number|null} [distance] Spherical3d distance
         * @property {number|null} [azimuth] Spherical3d azimuth
         * @property {number|null} [elevation] Spherical3d elevation
         */

        /**
         * Constructs a new Spherical3d.
         * @memberof osi3
         * @classdesc Represents a Spherical3d.
         * @implements ISpherical3d
         * @constructor
         * @param {osi3.ISpherical3d=} [properties] Properties to set
         */
        function Spherical3d(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Spherical3d distance.
         * @member {number} distance
         * @memberof osi3.Spherical3d
         * @instance
         */
        Spherical3d.prototype.distance = 0;

        /**
         * Spherical3d azimuth.
         * @member {number} azimuth
         * @memberof osi3.Spherical3d
         * @instance
         */
        Spherical3d.prototype.azimuth = 0;

        /**
         * Spherical3d elevation.
         * @member {number} elevation
         * @memberof osi3.Spherical3d
         * @instance
         */
        Spherical3d.prototype.elevation = 0;

        /**
         * Creates a new Spherical3d instance using the specified properties.
         * @function create
         * @memberof osi3.Spherical3d
         * @static
         * @param {osi3.ISpherical3d=} [properties] Properties to set
         * @returns {osi3.Spherical3d} Spherical3d instance
         */
        Spherical3d.create = function create(properties) {
            return new Spherical3d(properties);
        };

        /**
         * Encodes the specified Spherical3d message. Does not implicitly {@link osi3.Spherical3d.verify|verify} messages.
         * @function encode
         * @memberof osi3.Spherical3d
         * @static
         * @param {osi3.ISpherical3d} message Spherical3d message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Spherical3d.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.distance != null && Object.hasOwnProperty.call(message, "distance"))
                writer.uint32(/* id 1, wireType 1 =*/9).double(message.distance);
            if (message.azimuth != null && Object.hasOwnProperty.call(message, "azimuth"))
                writer.uint32(/* id 2, wireType 1 =*/17).double(message.azimuth);
            if (message.elevation != null && Object.hasOwnProperty.call(message, "elevation"))
                writer.uint32(/* id 3, wireType 1 =*/25).double(message.elevation);
            return writer;
        };

        /**
         * Encodes the specified Spherical3d message, length delimited. Does not implicitly {@link osi3.Spherical3d.verify|verify} messages.
         * @function encodeDelimited
         * @memberof osi3.Spherical3d
         * @static
         * @param {osi3.ISpherical3d} message Spherical3d message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Spherical3d.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Spherical3d message from the specified reader or buffer.
         * @function decode
         * @memberof osi3.Spherical3d
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {osi3.Spherical3d} Spherical3d
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Spherical3d.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.osi3.Spherical3d();
            while (reader.pos < end) {
                let tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.distance = reader.double();
                        break;
                    }
                case 2: {
                        message.azimuth = reader.double();
                        break;
                    }
                case 3: {
                        message.elevation = reader.double();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Spherical3d message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof osi3.Spherical3d
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {osi3.Spherical3d} Spherical3d
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Spherical3d.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Spherical3d message.
         * @function verify
         * @memberof osi3.Spherical3d
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Spherical3d.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.distance != null && message.hasOwnProperty("distance"))
                if (typeof message.distance !== "number")
                    return "distance: number expected";
            if (message.azimuth != null && message.hasOwnProperty("azimuth"))
                if (typeof message.azimuth !== "number")
                    return "azimuth: number expected";
            if (message.elevation != null && message.hasOwnProperty("elevation"))
                if (typeof message.elevation !== "number")
                    return "elevation: number expected";
            return null;
        };

        /**
         * Creates a Spherical3d message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof osi3.Spherical3d
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {osi3.Spherical3d} Spherical3d
         */
        Spherical3d.fromObject = function fromObject(object) {
            if (object instanceof $root.osi3.Spherical3d)
                return object;
            let message = new $root.osi3.Spherical3d();
            if (object.distance != null)
                message.distance = Number(object.distance);
            if (object.azimuth != null)
                message.azimuth = Number(object.azimuth);
            if (object.elevation != null)
                message.elevation = Number(object.elevation);
            return message;
        };

        /**
         * Creates a plain object from a Spherical3d message. Also converts values to other types if specified.
         * @function toObject
         * @memberof osi3.Spherical3d
         * @static
         * @param {osi3.Spherical3d} message Spherical3d
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Spherical3d.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.distance = 0;
                object.azimuth = 0;
                object.elevation = 0;
            }
            if (message.distance != null && message.hasOwnProperty("distance"))
                object.distance = options.json && !isFinite(message.distance) ? String(message.distance) : message.distance;
            if (message.azimuth != null && message.hasOwnProperty("azimuth"))
                object.azimuth = options.json && !isFinite(message.azimuth) ? String(message.azimuth) : message.azimuth;
            if (message.elevation != null && message.hasOwnProperty("elevation"))
                object.elevation = options.json && !isFinite(message.elevation) ? String(message.elevation) : message.elevation;
            return object;
        };

        /**
         * Converts this Spherical3d to JSON.
         * @function toJSON
         * @memberof osi3.Spherical3d
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Spherical3d.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Spherical3d
         * @function getTypeUrl
         * @memberof osi3.Spherical3d
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Spherical3d.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/osi3.Spherical3d";
        };

        return Spherical3d;
    })();

    osi3.LogicalLaneAssignment = (function() {

        /**
         * Properties of a LogicalLaneAssignment.
         * @memberof osi3
         * @interface ILogicalLaneAssignment
         * @property {osi3.IIdentifier|null} [assignedLaneId] LogicalLaneAssignment assignedLaneId
         * @property {number|null} [sPosition] LogicalLaneAssignment sPosition
         * @property {number|null} [tPosition] LogicalLaneAssignment tPosition
         * @property {number|null} [angleToLane] LogicalLaneAssignment angleToLane
         */

        /**
         * Constructs a new LogicalLaneAssignment.
         * @memberof osi3
         * @classdesc Represents a LogicalLaneAssignment.
         * @implements ILogicalLaneAssignment
         * @constructor
         * @param {osi3.ILogicalLaneAssignment=} [properties] Properties to set
         */
        function LogicalLaneAssignment(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LogicalLaneAssignment assignedLaneId.
         * @member {osi3.IIdentifier|null|undefined} assignedLaneId
         * @memberof osi3.LogicalLaneAssignment
         * @instance
         */
        LogicalLaneAssignment.prototype.assignedLaneId = null;

        /**
         * LogicalLaneAssignment sPosition.
         * @member {number} sPosition
         * @memberof osi3.LogicalLaneAssignment
         * @instance
         */
        LogicalLaneAssignment.prototype.sPosition = 0;

        /**
         * LogicalLaneAssignment tPosition.
         * @member {number} tPosition
         * @memberof osi3.LogicalLaneAssignment
         * @instance
         */
        LogicalLaneAssignment.prototype.tPosition = 0;

        /**
         * LogicalLaneAssignment angleToLane.
         * @member {number} angleToLane
         * @memberof osi3.LogicalLaneAssignment
         * @instance
         */
        LogicalLaneAssignment.prototype.angleToLane = 0;

        /**
         * Creates a new LogicalLaneAssignment instance using the specified properties.
         * @function create
         * @memberof osi3.LogicalLaneAssignment
         * @static
         * @param {osi3.ILogicalLaneAssignment=} [properties] Properties to set
         * @returns {osi3.LogicalLaneAssignment} LogicalLaneAssignment instance
         */
        LogicalLaneAssignment.create = function create(properties) {
            return new LogicalLaneAssignment(properties);
        };

        /**
         * Encodes the specified LogicalLaneAssignment message. Does not implicitly {@link osi3.LogicalLaneAssignment.verify|verify} messages.
         * @function encode
         * @memberof osi3.LogicalLaneAssignment
         * @static
         * @param {osi3.ILogicalLaneAssignment} message LogicalLaneAssignment message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LogicalLaneAssignment.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.assignedLaneId != null && Object.hasOwnProperty.call(message, "assignedLaneId"))
                $root.osi3.Identifier.encode(message.assignedLaneId, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.sPosition != null && Object.hasOwnProperty.call(message, "sPosition"))
                writer.uint32(/* id 2, wireType 1 =*/17).double(message.sPosition);
            if (message.tPosition != null && Object.hasOwnProperty.call(message, "tPosition"))
                writer.uint32(/* id 3, wireType 1 =*/25).double(message.tPosition);
            if (message.angleToLane != null && Object.hasOwnProperty.call(message, "angleToLane"))
                writer.uint32(/* id 4, wireType 1 =*/33).double(message.angleToLane);
            return writer;
        };

        /**
         * Encodes the specified LogicalLaneAssignment message, length delimited. Does not implicitly {@link osi3.LogicalLaneAssignment.verify|verify} messages.
         * @function encodeDelimited
         * @memberof osi3.LogicalLaneAssignment
         * @static
         * @param {osi3.ILogicalLaneAssignment} message LogicalLaneAssignment message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LogicalLaneAssignment.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LogicalLaneAssignment message from the specified reader or buffer.
         * @function decode
         * @memberof osi3.LogicalLaneAssignment
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {osi3.LogicalLaneAssignment} LogicalLaneAssignment
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LogicalLaneAssignment.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.osi3.LogicalLaneAssignment();
            while (reader.pos < end) {
                let tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.assignedLaneId = $root.osi3.Identifier.decode(reader, reader.uint32());
                        break;
                    }
                case 2: {
                        message.sPosition = reader.double();
                        break;
                    }
                case 3: {
                        message.tPosition = reader.double();
                        break;
                    }
                case 4: {
                        message.angleToLane = reader.double();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LogicalLaneAssignment message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof osi3.LogicalLaneAssignment
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {osi3.LogicalLaneAssignment} LogicalLaneAssignment
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LogicalLaneAssignment.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LogicalLaneAssignment message.
         * @function verify
         * @memberof osi3.LogicalLaneAssignment
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LogicalLaneAssignment.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.assignedLaneId != null && message.hasOwnProperty("assignedLaneId")) {
                let error = $root.osi3.Identifier.verify(message.assignedLaneId);
                if (error)
                    return "assignedLaneId." + error;
            }
            if (message.sPosition != null && message.hasOwnProperty("sPosition"))
                if (typeof message.sPosition !== "number")
                    return "sPosition: number expected";
            if (message.tPosition != null && message.hasOwnProperty("tPosition"))
                if (typeof message.tPosition !== "number")
                    return "tPosition: number expected";
            if (message.angleToLane != null && message.hasOwnProperty("angleToLane"))
                if (typeof message.angleToLane !== "number")
                    return "angleToLane: number expected";
            return null;
        };

        /**
         * Creates a LogicalLaneAssignment message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof osi3.LogicalLaneAssignment
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {osi3.LogicalLaneAssignment} LogicalLaneAssignment
         */
        LogicalLaneAssignment.fromObject = function fromObject(object) {
            if (object instanceof $root.osi3.LogicalLaneAssignment)
                return object;
            let message = new $root.osi3.LogicalLaneAssignment();
            if (object.assignedLaneId != null) {
                if (typeof object.assignedLaneId !== "object")
                    throw TypeError(".osi3.LogicalLaneAssignment.assignedLaneId: object expected");
                message.assignedLaneId = $root.osi3.Identifier.fromObject(object.assignedLaneId);
            }
            if (object.sPosition != null)
                message.sPosition = Number(object.sPosition);
            if (object.tPosition != null)
                message.tPosition = Number(object.tPosition);
            if (object.angleToLane != null)
                message.angleToLane = Number(object.angleToLane);
            return message;
        };

        /**
         * Creates a plain object from a LogicalLaneAssignment message. Also converts values to other types if specified.
         * @function toObject
         * @memberof osi3.LogicalLaneAssignment
         * @static
         * @param {osi3.LogicalLaneAssignment} message LogicalLaneAssignment
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        LogicalLaneAssignment.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.assignedLaneId = null;
                object.sPosition = 0;
                object.tPosition = 0;
                object.angleToLane = 0;
            }
            if (message.assignedLaneId != null && message.hasOwnProperty("assignedLaneId"))
                object.assignedLaneId = $root.osi3.Identifier.toObject(message.assignedLaneId, options);
            if (message.sPosition != null && message.hasOwnProperty("sPosition"))
                object.sPosition = options.json && !isFinite(message.sPosition) ? String(message.sPosition) : message.sPosition;
            if (message.tPosition != null && message.hasOwnProperty("tPosition"))
                object.tPosition = options.json && !isFinite(message.tPosition) ? String(message.tPosition) : message.tPosition;
            if (message.angleToLane != null && message.hasOwnProperty("angleToLane"))
                object.angleToLane = options.json && !isFinite(message.angleToLane) ? String(message.angleToLane) : message.angleToLane;
            return object;
        };

        /**
         * Converts this LogicalLaneAssignment to JSON.
         * @function toJSON
         * @memberof osi3.LogicalLaneAssignment
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        LogicalLaneAssignment.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for LogicalLaneAssignment
         * @function getTypeUrl
         * @memberof osi3.LogicalLaneAssignment
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        LogicalLaneAssignment.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/osi3.LogicalLaneAssignment";
        };

        return LogicalLaneAssignment;
    })();

    osi3.BoundingBox = (function() {

        /**
         * Properties of a BoundingBox.
         * @memberof osi3
         * @interface IBoundingBox
         * @property {osi3.IDimension3d|null} [dimension] BoundingBox dimension
         * @property {osi3.IVector3d|null} [position] BoundingBox position
         * @property {osi3.IOrientation3d|null} [orientation] BoundingBox orientation
         * @property {osi3.BoundingBox.Type|null} [containedObjectType] BoundingBox containedObjectType
         * @property {string|null} [modelReference] BoundingBox modelReference
         */

        /**
         * Constructs a new BoundingBox.
         * @memberof osi3
         * @classdesc Represents a BoundingBox.
         * @implements IBoundingBox
         * @constructor
         * @param {osi3.IBoundingBox=} [properties] Properties to set
         */
        function BoundingBox(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BoundingBox dimension.
         * @member {osi3.IDimension3d|null|undefined} dimension
         * @memberof osi3.BoundingBox
         * @instance
         */
        BoundingBox.prototype.dimension = null;

        /**
         * BoundingBox position.
         * @member {osi3.IVector3d|null|undefined} position
         * @memberof osi3.BoundingBox
         * @instance
         */
        BoundingBox.prototype.position = null;

        /**
         * BoundingBox orientation.
         * @member {osi3.IOrientation3d|null|undefined} orientation
         * @memberof osi3.BoundingBox
         * @instance
         */
        BoundingBox.prototype.orientation = null;

        /**
         * BoundingBox containedObjectType.
         * @member {osi3.BoundingBox.Type} containedObjectType
         * @memberof osi3.BoundingBox
         * @instance
         */
        BoundingBox.prototype.containedObjectType = 0;

        /**
         * BoundingBox modelReference.
         * @member {string} modelReference
         * @memberof osi3.BoundingBox
         * @instance
         */
        BoundingBox.prototype.modelReference = "";

        /**
         * Creates a new BoundingBox instance using the specified properties.
         * @function create
         * @memberof osi3.BoundingBox
         * @static
         * @param {osi3.IBoundingBox=} [properties] Properties to set
         * @returns {osi3.BoundingBox} BoundingBox instance
         */
        BoundingBox.create = function create(properties) {
            return new BoundingBox(properties);
        };

        /**
         * Encodes the specified BoundingBox message. Does not implicitly {@link osi3.BoundingBox.verify|verify} messages.
         * @function encode
         * @memberof osi3.BoundingBox
         * @static
         * @param {osi3.IBoundingBox} message BoundingBox message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BoundingBox.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.dimension != null && Object.hasOwnProperty.call(message, "dimension"))
                $root.osi3.Dimension3d.encode(message.dimension, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.position != null && Object.hasOwnProperty.call(message, "position"))
                $root.osi3.Vector3d.encode(message.position, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.orientation != null && Object.hasOwnProperty.call(message, "orientation"))
                $root.osi3.Orientation3d.encode(message.orientation, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.containedObjectType != null && Object.hasOwnProperty.call(message, "containedObjectType"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.containedObjectType);
            if (message.modelReference != null && Object.hasOwnProperty.call(message, "modelReference"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.modelReference);
            return writer;
        };

        /**
         * Encodes the specified BoundingBox message, length delimited. Does not implicitly {@link osi3.BoundingBox.verify|verify} messages.
         * @function encodeDelimited
         * @memberof osi3.BoundingBox
         * @static
         * @param {osi3.IBoundingBox} message BoundingBox message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BoundingBox.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BoundingBox message from the specified reader or buffer.
         * @function decode
         * @memberof osi3.BoundingBox
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {osi3.BoundingBox} BoundingBox
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BoundingBox.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.osi3.BoundingBox();
            while (reader.pos < end) {
                let tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.dimension = $root.osi3.Dimension3d.decode(reader, reader.uint32());
                        break;
                    }
                case 2: {
                        message.position = $root.osi3.Vector3d.decode(reader, reader.uint32());
                        break;
                    }
                case 3: {
                        message.orientation = $root.osi3.Orientation3d.decode(reader, reader.uint32());
                        break;
                    }
                case 4: {
                        message.containedObjectType = reader.int32();
                        break;
                    }
                case 5: {
                        message.modelReference = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BoundingBox message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof osi3.BoundingBox
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {osi3.BoundingBox} BoundingBox
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BoundingBox.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BoundingBox message.
         * @function verify
         * @memberof osi3.BoundingBox
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BoundingBox.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.dimension != null && message.hasOwnProperty("dimension")) {
                let error = $root.osi3.Dimension3d.verify(message.dimension);
                if (error)
                    return "dimension." + error;
            }
            if (message.position != null && message.hasOwnProperty("position")) {
                let error = $root.osi3.Vector3d.verify(message.position);
                if (error)
                    return "position." + error;
            }
            if (message.orientation != null && message.hasOwnProperty("orientation")) {
                let error = $root.osi3.Orientation3d.verify(message.orientation);
                if (error)
                    return "orientation." + error;
            }
            if (message.containedObjectType != null && message.hasOwnProperty("containedObjectType"))
                switch (message.containedObjectType) {
                default:
                    return "containedObjectType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                    break;
                }
            if (message.modelReference != null && message.hasOwnProperty("modelReference"))
                if (!$util.isString(message.modelReference))
                    return "modelReference: string expected";
            return null;
        };

        /**
         * Creates a BoundingBox message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof osi3.BoundingBox
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {osi3.BoundingBox} BoundingBox
         */
        BoundingBox.fromObject = function fromObject(object) {
            if (object instanceof $root.osi3.BoundingBox)
                return object;
            let message = new $root.osi3.BoundingBox();
            if (object.dimension != null) {
                if (typeof object.dimension !== "object")
                    throw TypeError(".osi3.BoundingBox.dimension: object expected");
                message.dimension = $root.osi3.Dimension3d.fromObject(object.dimension);
            }
            if (object.position != null) {
                if (typeof object.position !== "object")
                    throw TypeError(".osi3.BoundingBox.position: object expected");
                message.position = $root.osi3.Vector3d.fromObject(object.position);
            }
            if (object.orientation != null) {
                if (typeof object.orientation !== "object")
                    throw TypeError(".osi3.BoundingBox.orientation: object expected");
                message.orientation = $root.osi3.Orientation3d.fromObject(object.orientation);
            }
            switch (object.containedObjectType) {
            default:
                if (typeof object.containedObjectType === "number") {
                    message.containedObjectType = object.containedObjectType;
                    break;
                }
                break;
            case "TYPE_UNKNOWN":
            case 0:
                message.containedObjectType = 0;
                break;
            case "TYPE_OTHER":
            case 1:
                message.containedObjectType = 1;
                break;
            case "TYPE_BASE_STRUCTURE":
            case 2:
                message.containedObjectType = 2;
                break;
            case "TYPE_PROTRUDING_STRUCTURE":
            case 3:
                message.containedObjectType = 3;
                break;
            case "TYPE_CARGO":
            case 4:
                message.containedObjectType = 4;
                break;
            case "TYPE_DOOR":
            case 5:
                message.containedObjectType = 5;
                break;
            case "TYPE_SIDE_MIRROR":
            case 6:
                message.containedObjectType = 6;
                break;
            }
            if (object.modelReference != null)
                message.modelReference = String(object.modelReference);
            return message;
        };

        /**
         * Creates a plain object from a BoundingBox message. Also converts values to other types if specified.
         * @function toObject
         * @memberof osi3.BoundingBox
         * @static
         * @param {osi3.BoundingBox} message BoundingBox
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BoundingBox.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.dimension = null;
                object.position = null;
                object.orientation = null;
                object.containedObjectType = options.enums === String ? "TYPE_UNKNOWN" : 0;
                object.modelReference = "";
            }
            if (message.dimension != null && message.hasOwnProperty("dimension"))
                object.dimension = $root.osi3.Dimension3d.toObject(message.dimension, options);
            if (message.position != null && message.hasOwnProperty("position"))
                object.position = $root.osi3.Vector3d.toObject(message.position, options);
            if (message.orientation != null && message.hasOwnProperty("orientation"))
                object.orientation = $root.osi3.Orientation3d.toObject(message.orientation, options);
            if (message.containedObjectType != null && message.hasOwnProperty("containedObjectType"))
                object.containedObjectType = options.enums === String ? $root.osi3.BoundingBox.Type[message.containedObjectType] === undefined ? message.containedObjectType : $root.osi3.BoundingBox.Type[message.containedObjectType] : message.containedObjectType;
            if (message.modelReference != null && message.hasOwnProperty("modelReference"))
                object.modelReference = message.modelReference;
            return object;
        };

        /**
         * Converts this BoundingBox to JSON.
         * @function toJSON
         * @memberof osi3.BoundingBox
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BoundingBox.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for BoundingBox
         * @function getTypeUrl
         * @memberof osi3.BoundingBox
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        BoundingBox.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/osi3.BoundingBox";
        };

        /**
         * Type enum.
         * @name osi3.BoundingBox.Type
         * @enum {number}
         * @property {number} TYPE_UNKNOWN=0 TYPE_UNKNOWN value
         * @property {number} TYPE_OTHER=1 TYPE_OTHER value
         * @property {number} TYPE_BASE_STRUCTURE=2 TYPE_BASE_STRUCTURE value
         * @property {number} TYPE_PROTRUDING_STRUCTURE=3 TYPE_PROTRUDING_STRUCTURE value
         * @property {number} TYPE_CARGO=4 TYPE_CARGO value
         * @property {number} TYPE_DOOR=5 TYPE_DOOR value
         * @property {number} TYPE_SIDE_MIRROR=6 TYPE_SIDE_MIRROR value
         */
        BoundingBox.Type = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "TYPE_UNKNOWN"] = 0;
            values[valuesById[1] = "TYPE_OTHER"] = 1;
            values[valuesById[2] = "TYPE_BASE_STRUCTURE"] = 2;
            values[valuesById[3] = "TYPE_PROTRUDING_STRUCTURE"] = 3;
            values[valuesById[4] = "TYPE_CARGO"] = 4;
            values[valuesById[5] = "TYPE_DOOR"] = 5;
            values[valuesById[6] = "TYPE_SIDE_MIRROR"] = 6;
            return values;
        })();

        return BoundingBox;
    })();

    osi3.BaseStationary = (function() {

        /**
         * Properties of a BaseStationary.
         * @memberof osi3
         * @interface IBaseStationary
         * @property {osi3.IDimension3d|null} [dimension] BaseStationary dimension
         * @property {osi3.IVector3d|null} [position] BaseStationary position
         * @property {osi3.IOrientation3d|null} [orientation] BaseStationary orientation
         * @property {Array.<osi3.IVector2d>|null} [basePolygon] BaseStationary basePolygon
         * @property {Array.<osi3.IBoundingBox>|null} [boundingBoxSection] BaseStationary boundingBoxSection
         */

        /**
         * Constructs a new BaseStationary.
         * @memberof osi3
         * @classdesc Represents a BaseStationary.
         * @implements IBaseStationary
         * @constructor
         * @param {osi3.IBaseStationary=} [properties] Properties to set
         */
        function BaseStationary(properties) {
            this.basePolygon = [];
            this.boundingBoxSection = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BaseStationary dimension.
         * @member {osi3.IDimension3d|null|undefined} dimension
         * @memberof osi3.BaseStationary
         * @instance
         */
        BaseStationary.prototype.dimension = null;

        /**
         * BaseStationary position.
         * @member {osi3.IVector3d|null|undefined} position
         * @memberof osi3.BaseStationary
         * @instance
         */
        BaseStationary.prototype.position = null;

        /**
         * BaseStationary orientation.
         * @member {osi3.IOrientation3d|null|undefined} orientation
         * @memberof osi3.BaseStationary
         * @instance
         */
        BaseStationary.prototype.orientation = null;

        /**
         * BaseStationary basePolygon.
         * @member {Array.<osi3.IVector2d>} basePolygon
         * @memberof osi3.BaseStationary
         * @instance
         */
        BaseStationary.prototype.basePolygon = $util.emptyArray;

        /**
         * BaseStationary boundingBoxSection.
         * @member {Array.<osi3.IBoundingBox>} boundingBoxSection
         * @memberof osi3.BaseStationary
         * @instance
         */
        BaseStationary.prototype.boundingBoxSection = $util.emptyArray;

        /**
         * Creates a new BaseStationary instance using the specified properties.
         * @function create
         * @memberof osi3.BaseStationary
         * @static
         * @param {osi3.IBaseStationary=} [properties] Properties to set
         * @returns {osi3.BaseStationary} BaseStationary instance
         */
        BaseStationary.create = function create(properties) {
            return new BaseStationary(properties);
        };

        /**
         * Encodes the specified BaseStationary message. Does not implicitly {@link osi3.BaseStationary.verify|verify} messages.
         * @function encode
         * @memberof osi3.BaseStationary
         * @static
         * @param {osi3.IBaseStationary} message BaseStationary message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BaseStationary.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.dimension != null && Object.hasOwnProperty.call(message, "dimension"))
                $root.osi3.Dimension3d.encode(message.dimension, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.position != null && Object.hasOwnProperty.call(message, "position"))
                $root.osi3.Vector3d.encode(message.position, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.orientation != null && Object.hasOwnProperty.call(message, "orientation"))
                $root.osi3.Orientation3d.encode(message.orientation, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.basePolygon != null && message.basePolygon.length)
                for (let i = 0; i < message.basePolygon.length; ++i)
                    $root.osi3.Vector2d.encode(message.basePolygon[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.boundingBoxSection != null && message.boundingBoxSection.length)
                for (let i = 0; i < message.boundingBoxSection.length; ++i)
                    $root.osi3.BoundingBox.encode(message.boundingBoxSection[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified BaseStationary message, length delimited. Does not implicitly {@link osi3.BaseStationary.verify|verify} messages.
         * @function encodeDelimited
         * @memberof osi3.BaseStationary
         * @static
         * @param {osi3.IBaseStationary} message BaseStationary message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BaseStationary.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BaseStationary message from the specified reader or buffer.
         * @function decode
         * @memberof osi3.BaseStationary
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {osi3.BaseStationary} BaseStationary
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BaseStationary.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.osi3.BaseStationary();
            while (reader.pos < end) {
                let tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.dimension = $root.osi3.Dimension3d.decode(reader, reader.uint32());
                        break;
                    }
                case 2: {
                        message.position = $root.osi3.Vector3d.decode(reader, reader.uint32());
                        break;
                    }
                case 3: {
                        message.orientation = $root.osi3.Orientation3d.decode(reader, reader.uint32());
                        break;
                    }
                case 4: {
                        if (!(message.basePolygon && message.basePolygon.length))
                            message.basePolygon = [];
                        message.basePolygon.push($root.osi3.Vector2d.decode(reader, reader.uint32()));
                        break;
                    }
                case 5: {
                        if (!(message.boundingBoxSection && message.boundingBoxSection.length))
                            message.boundingBoxSection = [];
                        message.boundingBoxSection.push($root.osi3.BoundingBox.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BaseStationary message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof osi3.BaseStationary
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {osi3.BaseStationary} BaseStationary
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BaseStationary.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BaseStationary message.
         * @function verify
         * @memberof osi3.BaseStationary
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BaseStationary.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.dimension != null && message.hasOwnProperty("dimension")) {
                let error = $root.osi3.Dimension3d.verify(message.dimension);
                if (error)
                    return "dimension." + error;
            }
            if (message.position != null && message.hasOwnProperty("position")) {
                let error = $root.osi3.Vector3d.verify(message.position);
                if (error)
                    return "position." + error;
            }
            if (message.orientation != null && message.hasOwnProperty("orientation")) {
                let error = $root.osi3.Orientation3d.verify(message.orientation);
                if (error)
                    return "orientation." + error;
            }
            if (message.basePolygon != null && message.hasOwnProperty("basePolygon")) {
                if (!Array.isArray(message.basePolygon))
                    return "basePolygon: array expected";
                for (let i = 0; i < message.basePolygon.length; ++i) {
                    let error = $root.osi3.Vector2d.verify(message.basePolygon[i]);
                    if (error)
                        return "basePolygon." + error;
                }
            }
            if (message.boundingBoxSection != null && message.hasOwnProperty("boundingBoxSection")) {
                if (!Array.isArray(message.boundingBoxSection))
                    return "boundingBoxSection: array expected";
                for (let i = 0; i < message.boundingBoxSection.length; ++i) {
                    let error = $root.osi3.BoundingBox.verify(message.boundingBoxSection[i]);
                    if (error)
                        return "boundingBoxSection." + error;
                }
            }
            return null;
        };

        /**
         * Creates a BaseStationary message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof osi3.BaseStationary
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {osi3.BaseStationary} BaseStationary
         */
        BaseStationary.fromObject = function fromObject(object) {
            if (object instanceof $root.osi3.BaseStationary)
                return object;
            let message = new $root.osi3.BaseStationary();
            if (object.dimension != null) {
                if (typeof object.dimension !== "object")
                    throw TypeError(".osi3.BaseStationary.dimension: object expected");
                message.dimension = $root.osi3.Dimension3d.fromObject(object.dimension);
            }
            if (object.position != null) {
                if (typeof object.position !== "object")
                    throw TypeError(".osi3.BaseStationary.position: object expected");
                message.position = $root.osi3.Vector3d.fromObject(object.position);
            }
            if (object.orientation != null) {
                if (typeof object.orientation !== "object")
                    throw TypeError(".osi3.BaseStationary.orientation: object expected");
                message.orientation = $root.osi3.Orientation3d.fromObject(object.orientation);
            }
            if (object.basePolygon) {
                if (!Array.isArray(object.basePolygon))
                    throw TypeError(".osi3.BaseStationary.basePolygon: array expected");
                message.basePolygon = [];
                for (let i = 0; i < object.basePolygon.length; ++i) {
                    if (typeof object.basePolygon[i] !== "object")
                        throw TypeError(".osi3.BaseStationary.basePolygon: object expected");
                    message.basePolygon[i] = $root.osi3.Vector2d.fromObject(object.basePolygon[i]);
                }
            }
            if (object.boundingBoxSection) {
                if (!Array.isArray(object.boundingBoxSection))
                    throw TypeError(".osi3.BaseStationary.boundingBoxSection: array expected");
                message.boundingBoxSection = [];
                for (let i = 0; i < object.boundingBoxSection.length; ++i) {
                    if (typeof object.boundingBoxSection[i] !== "object")
                        throw TypeError(".osi3.BaseStationary.boundingBoxSection: object expected");
                    message.boundingBoxSection[i] = $root.osi3.BoundingBox.fromObject(object.boundingBoxSection[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a BaseStationary message. Also converts values to other types if specified.
         * @function toObject
         * @memberof osi3.BaseStationary
         * @static
         * @param {osi3.BaseStationary} message BaseStationary
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BaseStationary.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.basePolygon = [];
                object.boundingBoxSection = [];
            }
            if (options.defaults) {
                object.dimension = null;
                object.position = null;
                object.orientation = null;
            }
            if (message.dimension != null && message.hasOwnProperty("dimension"))
                object.dimension = $root.osi3.Dimension3d.toObject(message.dimension, options);
            if (message.position != null && message.hasOwnProperty("position"))
                object.position = $root.osi3.Vector3d.toObject(message.position, options);
            if (message.orientation != null && message.hasOwnProperty("orientation"))
                object.orientation = $root.osi3.Orientation3d.toObject(message.orientation, options);
            if (message.basePolygon && message.basePolygon.length) {
                object.basePolygon = [];
                for (let j = 0; j < message.basePolygon.length; ++j)
                    object.basePolygon[j] = $root.osi3.Vector2d.toObject(message.basePolygon[j], options);
            }
            if (message.boundingBoxSection && message.boundingBoxSection.length) {
                object.boundingBoxSection = [];
                for (let j = 0; j < message.boundingBoxSection.length; ++j)
                    object.boundingBoxSection[j] = $root.osi3.BoundingBox.toObject(message.boundingBoxSection[j], options);
            }
            return object;
        };

        /**
         * Converts this BaseStationary to JSON.
         * @function toJSON
         * @memberof osi3.BaseStationary
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BaseStationary.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for BaseStationary
         * @function getTypeUrl
         * @memberof osi3.BaseStationary
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        BaseStationary.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/osi3.BaseStationary";
        };

        return BaseStationary;
    })();

    osi3.BaseMoving = (function() {

        /**
         * Properties of a BaseMoving.
         * @memberof osi3
         * @interface IBaseMoving
         * @property {osi3.IDimension3d|null} [dimension] BaseMoving dimension
         * @property {osi3.IVector3d|null} [position] BaseMoving position
         * @property {osi3.IOrientation3d|null} [orientation] BaseMoving orientation
         * @property {osi3.IVector3d|null} [velocity] BaseMoving velocity
         * @property {osi3.IVector3d|null} [acceleration] BaseMoving acceleration
         * @property {osi3.IOrientation3d|null} [orientationRate] BaseMoving orientationRate
         * @property {osi3.IOrientation3d|null} [orientationAcceleration] BaseMoving orientationAcceleration
         * @property {Array.<osi3.IVector2d>|null} [basePolygon] BaseMoving basePolygon
         * @property {Array.<osi3.IBoundingBox>|null} [boundingBoxSection] BaseMoving boundingBoxSection
         */

        /**
         * Constructs a new BaseMoving.
         * @memberof osi3
         * @classdesc Represents a BaseMoving.
         * @implements IBaseMoving
         * @constructor
         * @param {osi3.IBaseMoving=} [properties] Properties to set
         */
        function BaseMoving(properties) {
            this.basePolygon = [];
            this.boundingBoxSection = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BaseMoving dimension.
         * @member {osi3.IDimension3d|null|undefined} dimension
         * @memberof osi3.BaseMoving
         * @instance
         */
        BaseMoving.prototype.dimension = null;

        /**
         * BaseMoving position.
         * @member {osi3.IVector3d|null|undefined} position
         * @memberof osi3.BaseMoving
         * @instance
         */
        BaseMoving.prototype.position = null;

        /**
         * BaseMoving orientation.
         * @member {osi3.IOrientation3d|null|undefined} orientation
         * @memberof osi3.BaseMoving
         * @instance
         */
        BaseMoving.prototype.orientation = null;

        /**
         * BaseMoving velocity.
         * @member {osi3.IVector3d|null|undefined} velocity
         * @memberof osi3.BaseMoving
         * @instance
         */
        BaseMoving.prototype.velocity = null;

        /**
         * BaseMoving acceleration.
         * @member {osi3.IVector3d|null|undefined} acceleration
         * @memberof osi3.BaseMoving
         * @instance
         */
        BaseMoving.prototype.acceleration = null;

        /**
         * BaseMoving orientationRate.
         * @member {osi3.IOrientation3d|null|undefined} orientationRate
         * @memberof osi3.BaseMoving
         * @instance
         */
        BaseMoving.prototype.orientationRate = null;

        /**
         * BaseMoving orientationAcceleration.
         * @member {osi3.IOrientation3d|null|undefined} orientationAcceleration
         * @memberof osi3.BaseMoving
         * @instance
         */
        BaseMoving.prototype.orientationAcceleration = null;

        /**
         * BaseMoving basePolygon.
         * @member {Array.<osi3.IVector2d>} basePolygon
         * @memberof osi3.BaseMoving
         * @instance
         */
        BaseMoving.prototype.basePolygon = $util.emptyArray;

        /**
         * BaseMoving boundingBoxSection.
         * @member {Array.<osi3.IBoundingBox>} boundingBoxSection
         * @memberof osi3.BaseMoving
         * @instance
         */
        BaseMoving.prototype.boundingBoxSection = $util.emptyArray;

        /**
         * Creates a new BaseMoving instance using the specified properties.
         * @function create
         * @memberof osi3.BaseMoving
         * @static
         * @param {osi3.IBaseMoving=} [properties] Properties to set
         * @returns {osi3.BaseMoving} BaseMoving instance
         */
        BaseMoving.create = function create(properties) {
            return new BaseMoving(properties);
        };

        /**
         * Encodes the specified BaseMoving message. Does not implicitly {@link osi3.BaseMoving.verify|verify} messages.
         * @function encode
         * @memberof osi3.BaseMoving
         * @static
         * @param {osi3.IBaseMoving} message BaseMoving message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BaseMoving.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.dimension != null && Object.hasOwnProperty.call(message, "dimension"))
                $root.osi3.Dimension3d.encode(message.dimension, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.position != null && Object.hasOwnProperty.call(message, "position"))
                $root.osi3.Vector3d.encode(message.position, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.orientation != null && Object.hasOwnProperty.call(message, "orientation"))
                $root.osi3.Orientation3d.encode(message.orientation, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.velocity != null && Object.hasOwnProperty.call(message, "velocity"))
                $root.osi3.Vector3d.encode(message.velocity, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.acceleration != null && Object.hasOwnProperty.call(message, "acceleration"))
                $root.osi3.Vector3d.encode(message.acceleration, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.orientationRate != null && Object.hasOwnProperty.call(message, "orientationRate"))
                $root.osi3.Orientation3d.encode(message.orientationRate, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.basePolygon != null && message.basePolygon.length)
                for (let i = 0; i < message.basePolygon.length; ++i)
                    $root.osi3.Vector2d.encode(message.basePolygon[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.orientationAcceleration != null && Object.hasOwnProperty.call(message, "orientationAcceleration"))
                $root.osi3.Orientation3d.encode(message.orientationAcceleration, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.boundingBoxSection != null && message.boundingBoxSection.length)
                for (let i = 0; i < message.boundingBoxSection.length; ++i)
                    $root.osi3.BoundingBox.encode(message.boundingBoxSection[i], writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified BaseMoving message, length delimited. Does not implicitly {@link osi3.BaseMoving.verify|verify} messages.
         * @function encodeDelimited
         * @memberof osi3.BaseMoving
         * @static
         * @param {osi3.IBaseMoving} message BaseMoving message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BaseMoving.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BaseMoving message from the specified reader or buffer.
         * @function decode
         * @memberof osi3.BaseMoving
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {osi3.BaseMoving} BaseMoving
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BaseMoving.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.osi3.BaseMoving();
            while (reader.pos < end) {
                let tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.dimension = $root.osi3.Dimension3d.decode(reader, reader.uint32());
                        break;
                    }
                case 2: {
                        message.position = $root.osi3.Vector3d.decode(reader, reader.uint32());
                        break;
                    }
                case 3: {
                        message.orientation = $root.osi3.Orientation3d.decode(reader, reader.uint32());
                        break;
                    }
                case 4: {
                        message.velocity = $root.osi3.Vector3d.decode(reader, reader.uint32());
                        break;
                    }
                case 5: {
                        message.acceleration = $root.osi3.Vector3d.decode(reader, reader.uint32());
                        break;
                    }
                case 6: {
                        message.orientationRate = $root.osi3.Orientation3d.decode(reader, reader.uint32());
                        break;
                    }
                case 8: {
                        message.orientationAcceleration = $root.osi3.Orientation3d.decode(reader, reader.uint32());
                        break;
                    }
                case 7: {
                        if (!(message.basePolygon && message.basePolygon.length))
                            message.basePolygon = [];
                        message.basePolygon.push($root.osi3.Vector2d.decode(reader, reader.uint32()));
                        break;
                    }
                case 9: {
                        if (!(message.boundingBoxSection && message.boundingBoxSection.length))
                            message.boundingBoxSection = [];
                        message.boundingBoxSection.push($root.osi3.BoundingBox.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BaseMoving message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof osi3.BaseMoving
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {osi3.BaseMoving} BaseMoving
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BaseMoving.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BaseMoving message.
         * @function verify
         * @memberof osi3.BaseMoving
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BaseMoving.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.dimension != null && message.hasOwnProperty("dimension")) {
                let error = $root.osi3.Dimension3d.verify(message.dimension);
                if (error)
                    return "dimension." + error;
            }
            if (message.position != null && message.hasOwnProperty("position")) {
                let error = $root.osi3.Vector3d.verify(message.position);
                if (error)
                    return "position." + error;
            }
            if (message.orientation != null && message.hasOwnProperty("orientation")) {
                let error = $root.osi3.Orientation3d.verify(message.orientation);
                if (error)
                    return "orientation." + error;
            }
            if (message.velocity != null && message.hasOwnProperty("velocity")) {
                let error = $root.osi3.Vector3d.verify(message.velocity);
                if (error)
                    return "velocity." + error;
            }
            if (message.acceleration != null && message.hasOwnProperty("acceleration")) {
                let error = $root.osi3.Vector3d.verify(message.acceleration);
                if (error)
                    return "acceleration." + error;
            }
            if (message.orientationRate != null && message.hasOwnProperty("orientationRate")) {
                let error = $root.osi3.Orientation3d.verify(message.orientationRate);
                if (error)
                    return "orientationRate." + error;
            }
            if (message.orientationAcceleration != null && message.hasOwnProperty("orientationAcceleration")) {
                let error = $root.osi3.Orientation3d.verify(message.orientationAcceleration);
                if (error)
                    return "orientationAcceleration." + error;
            }
            if (message.basePolygon != null && message.hasOwnProperty("basePolygon")) {
                if (!Array.isArray(message.basePolygon))
                    return "basePolygon: array expected";
                for (let i = 0; i < message.basePolygon.length; ++i) {
                    let error = $root.osi3.Vector2d.verify(message.basePolygon[i]);
                    if (error)
                        return "basePolygon." + error;
                }
            }
            if (message.boundingBoxSection != null && message.hasOwnProperty("boundingBoxSection")) {
                if (!Array.isArray(message.boundingBoxSection))
                    return "boundingBoxSection: array expected";
                for (let i = 0; i < message.boundingBoxSection.length; ++i) {
                    let error = $root.osi3.BoundingBox.verify(message.boundingBoxSection[i]);
                    if (error)
                        return "boundingBoxSection." + error;
                }
            }
            return null;
        };

        /**
         * Creates a BaseMoving message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof osi3.BaseMoving
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {osi3.BaseMoving} BaseMoving
         */
        BaseMoving.fromObject = function fromObject(object) {
            if (object instanceof $root.osi3.BaseMoving)
                return object;
            let message = new $root.osi3.BaseMoving();
            if (object.dimension != null) {
                if (typeof object.dimension !== "object")
                    throw TypeError(".osi3.BaseMoving.dimension: object expected");
                message.dimension = $root.osi3.Dimension3d.fromObject(object.dimension);
            }
            if (object.position != null) {
                if (typeof object.position !== "object")
                    throw TypeError(".osi3.BaseMoving.position: object expected");
                message.position = $root.osi3.Vector3d.fromObject(object.position);
            }
            if (object.orientation != null) {
                if (typeof object.orientation !== "object")
                    throw TypeError(".osi3.BaseMoving.orientation: object expected");
                message.orientation = $root.osi3.Orientation3d.fromObject(object.orientation);
            }
            if (object.velocity != null) {
                if (typeof object.velocity !== "object")
                    throw TypeError(".osi3.BaseMoving.velocity: object expected");
                message.velocity = $root.osi3.Vector3d.fromObject(object.velocity);
            }
            if (object.acceleration != null) {
                if (typeof object.acceleration !== "object")
                    throw TypeError(".osi3.BaseMoving.acceleration: object expected");
                message.acceleration = $root.osi3.Vector3d.fromObject(object.acceleration);
            }
            if (object.orientationRate != null) {
                if (typeof object.orientationRate !== "object")
                    throw TypeError(".osi3.BaseMoving.orientationRate: object expected");
                message.orientationRate = $root.osi3.Orientation3d.fromObject(object.orientationRate);
            }
            if (object.orientationAcceleration != null) {
                if (typeof object.orientationAcceleration !== "object")
                    throw TypeError(".osi3.BaseMoving.orientationAcceleration: object expected");
                message.orientationAcceleration = $root.osi3.Orientation3d.fromObject(object.orientationAcceleration);
            }
            if (object.basePolygon) {
                if (!Array.isArray(object.basePolygon))
                    throw TypeError(".osi3.BaseMoving.basePolygon: array expected");
                message.basePolygon = [];
                for (let i = 0; i < object.basePolygon.length; ++i) {
                    if (typeof object.basePolygon[i] !== "object")
                        throw TypeError(".osi3.BaseMoving.basePolygon: object expected");
                    message.basePolygon[i] = $root.osi3.Vector2d.fromObject(object.basePolygon[i]);
                }
            }
            if (object.boundingBoxSection) {
                if (!Array.isArray(object.boundingBoxSection))
                    throw TypeError(".osi3.BaseMoving.boundingBoxSection: array expected");
                message.boundingBoxSection = [];
                for (let i = 0; i < object.boundingBoxSection.length; ++i) {
                    if (typeof object.boundingBoxSection[i] !== "object")
                        throw TypeError(".osi3.BaseMoving.boundingBoxSection: object expected");
                    message.boundingBoxSection[i] = $root.osi3.BoundingBox.fromObject(object.boundingBoxSection[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a BaseMoving message. Also converts values to other types if specified.
         * @function toObject
         * @memberof osi3.BaseMoving
         * @static
         * @param {osi3.BaseMoving} message BaseMoving
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BaseMoving.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.basePolygon = [];
                object.boundingBoxSection = [];
            }
            if (options.defaults) {
                object.dimension = null;
                object.position = null;
                object.orientation = null;
                object.velocity = null;
                object.acceleration = null;
                object.orientationRate = null;
                object.orientationAcceleration = null;
            }
            if (message.dimension != null && message.hasOwnProperty("dimension"))
                object.dimension = $root.osi3.Dimension3d.toObject(message.dimension, options);
            if (message.position != null && message.hasOwnProperty("position"))
                object.position = $root.osi3.Vector3d.toObject(message.position, options);
            if (message.orientation != null && message.hasOwnProperty("orientation"))
                object.orientation = $root.osi3.Orientation3d.toObject(message.orientation, options);
            if (message.velocity != null && message.hasOwnProperty("velocity"))
                object.velocity = $root.osi3.Vector3d.toObject(message.velocity, options);
            if (message.acceleration != null && message.hasOwnProperty("acceleration"))
                object.acceleration = $root.osi3.Vector3d.toObject(message.acceleration, options);
            if (message.orientationRate != null && message.hasOwnProperty("orientationRate"))
                object.orientationRate = $root.osi3.Orientation3d.toObject(message.orientationRate, options);
            if (message.basePolygon && message.basePolygon.length) {
                object.basePolygon = [];
                for (let j = 0; j < message.basePolygon.length; ++j)
                    object.basePolygon[j] = $root.osi3.Vector2d.toObject(message.basePolygon[j], options);
            }
            if (message.orientationAcceleration != null && message.hasOwnProperty("orientationAcceleration"))
                object.orientationAcceleration = $root.osi3.Orientation3d.toObject(message.orientationAcceleration, options);
            if (message.boundingBoxSection && message.boundingBoxSection.length) {
                object.boundingBoxSection = [];
                for (let j = 0; j < message.boundingBoxSection.length; ++j)
                    object.boundingBoxSection[j] = $root.osi3.BoundingBox.toObject(message.boundingBoxSection[j], options);
            }
            return object;
        };

        /**
         * Converts this BaseMoving to JSON.
         * @function toJSON
         * @memberof osi3.BaseMoving
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BaseMoving.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for BaseMoving
         * @function getTypeUrl
         * @memberof osi3.BaseMoving
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        BaseMoving.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/osi3.BaseMoving";
        };

        return BaseMoving;
    })();

    osi3.StatePoint = (function() {

        /**
         * Properties of a StatePoint.
         * @memberof osi3
         * @interface IStatePoint
         * @property {osi3.ITimestamp|null} [timestamp] StatePoint timestamp
         * @property {osi3.IVector3d|null} [position] StatePoint position
         * @property {osi3.IOrientation3d|null} [orientation] StatePoint orientation
         */

        /**
         * Constructs a new StatePoint.
         * @memberof osi3
         * @classdesc Represents a StatePoint.
         * @implements IStatePoint
         * @constructor
         * @param {osi3.IStatePoint=} [properties] Properties to set
         */
        function StatePoint(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StatePoint timestamp.
         * @member {osi3.ITimestamp|null|undefined} timestamp
         * @memberof osi3.StatePoint
         * @instance
         */
        StatePoint.prototype.timestamp = null;

        /**
         * StatePoint position.
         * @member {osi3.IVector3d|null|undefined} position
         * @memberof osi3.StatePoint
         * @instance
         */
        StatePoint.prototype.position = null;

        /**
         * StatePoint orientation.
         * @member {osi3.IOrientation3d|null|undefined} orientation
         * @memberof osi3.StatePoint
         * @instance
         */
        StatePoint.prototype.orientation = null;

        /**
         * Creates a new StatePoint instance using the specified properties.
         * @function create
         * @memberof osi3.StatePoint
         * @static
         * @param {osi3.IStatePoint=} [properties] Properties to set
         * @returns {osi3.StatePoint} StatePoint instance
         */
        StatePoint.create = function create(properties) {
            return new StatePoint(properties);
        };

        /**
         * Encodes the specified StatePoint message. Does not implicitly {@link osi3.StatePoint.verify|verify} messages.
         * @function encode
         * @memberof osi3.StatePoint
         * @static
         * @param {osi3.IStatePoint} message StatePoint message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StatePoint.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                $root.osi3.Timestamp.encode(message.timestamp, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.position != null && Object.hasOwnProperty.call(message, "position"))
                $root.osi3.Vector3d.encode(message.position, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.orientation != null && Object.hasOwnProperty.call(message, "orientation"))
                $root.osi3.Orientation3d.encode(message.orientation, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified StatePoint message, length delimited. Does not implicitly {@link osi3.StatePoint.verify|verify} messages.
         * @function encodeDelimited
         * @memberof osi3.StatePoint
         * @static
         * @param {osi3.IStatePoint} message StatePoint message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StatePoint.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a StatePoint message from the specified reader or buffer.
         * @function decode
         * @memberof osi3.StatePoint
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {osi3.StatePoint} StatePoint
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StatePoint.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.osi3.StatePoint();
            while (reader.pos < end) {
                let tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.timestamp = $root.osi3.Timestamp.decode(reader, reader.uint32());
                        break;
                    }
                case 2: {
                        message.position = $root.osi3.Vector3d.decode(reader, reader.uint32());
                        break;
                    }
                case 3: {
                        message.orientation = $root.osi3.Orientation3d.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a StatePoint message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof osi3.StatePoint
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {osi3.StatePoint} StatePoint
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StatePoint.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a StatePoint message.
         * @function verify
         * @memberof osi3.StatePoint
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        StatePoint.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp")) {
                let error = $root.osi3.Timestamp.verify(message.timestamp);
                if (error)
                    return "timestamp." + error;
            }
            if (message.position != null && message.hasOwnProperty("position")) {
                let error = $root.osi3.Vector3d.verify(message.position);
                if (error)
                    return "position." + error;
            }
            if (message.orientation != null && message.hasOwnProperty("orientation")) {
                let error = $root.osi3.Orientation3d.verify(message.orientation);
                if (error)
                    return "orientation." + error;
            }
            return null;
        };

        /**
         * Creates a StatePoint message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof osi3.StatePoint
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {osi3.StatePoint} StatePoint
         */
        StatePoint.fromObject = function fromObject(object) {
            if (object instanceof $root.osi3.StatePoint)
                return object;
            let message = new $root.osi3.StatePoint();
            if (object.timestamp != null) {
                if (typeof object.timestamp !== "object")
                    throw TypeError(".osi3.StatePoint.timestamp: object expected");
                message.timestamp = $root.osi3.Timestamp.fromObject(object.timestamp);
            }
            if (object.position != null) {
                if (typeof object.position !== "object")
                    throw TypeError(".osi3.StatePoint.position: object expected");
                message.position = $root.osi3.Vector3d.fromObject(object.position);
            }
            if (object.orientation != null) {
                if (typeof object.orientation !== "object")
                    throw TypeError(".osi3.StatePoint.orientation: object expected");
                message.orientation = $root.osi3.Orientation3d.fromObject(object.orientation);
            }
            return message;
        };

        /**
         * Creates a plain object from a StatePoint message. Also converts values to other types if specified.
         * @function toObject
         * @memberof osi3.StatePoint
         * @static
         * @param {osi3.StatePoint} message StatePoint
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        StatePoint.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.timestamp = null;
                object.position = null;
                object.orientation = null;
            }
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                object.timestamp = $root.osi3.Timestamp.toObject(message.timestamp, options);
            if (message.position != null && message.hasOwnProperty("position"))
                object.position = $root.osi3.Vector3d.toObject(message.position, options);
            if (message.orientation != null && message.hasOwnProperty("orientation"))
                object.orientation = $root.osi3.Orientation3d.toObject(message.orientation, options);
            return object;
        };

        /**
         * Converts this StatePoint to JSON.
         * @function toJSON
         * @memberof osi3.StatePoint
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        StatePoint.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for StatePoint
         * @function getTypeUrl
         * @memberof osi3.StatePoint
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        StatePoint.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/osi3.StatePoint";
        };

        return StatePoint;
    })();

    osi3.WavelengthData = (function() {

        /**
         * Properties of a WavelengthData.
         * @memberof osi3
         * @interface IWavelengthData
         * @property {number|null} [start] WavelengthData start
         * @property {number|null} [end] WavelengthData end
         * @property {number|null} [samplesNumber] WavelengthData samplesNumber
         */

        /**
         * Constructs a new WavelengthData.
         * @memberof osi3
         * @classdesc Represents a WavelengthData.
         * @implements IWavelengthData
         * @constructor
         * @param {osi3.IWavelengthData=} [properties] Properties to set
         */
        function WavelengthData(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * WavelengthData start.
         * @member {number} start
         * @memberof osi3.WavelengthData
         * @instance
         */
        WavelengthData.prototype.start = 0;

        /**
         * WavelengthData end.
         * @member {number} end
         * @memberof osi3.WavelengthData
         * @instance
         */
        WavelengthData.prototype.end = 0;

        /**
         * WavelengthData samplesNumber.
         * @member {number} samplesNumber
         * @memberof osi3.WavelengthData
         * @instance
         */
        WavelengthData.prototype.samplesNumber = 0;

        /**
         * Creates a new WavelengthData instance using the specified properties.
         * @function create
         * @memberof osi3.WavelengthData
         * @static
         * @param {osi3.IWavelengthData=} [properties] Properties to set
         * @returns {osi3.WavelengthData} WavelengthData instance
         */
        WavelengthData.create = function create(properties) {
            return new WavelengthData(properties);
        };

        /**
         * Encodes the specified WavelengthData message. Does not implicitly {@link osi3.WavelengthData.verify|verify} messages.
         * @function encode
         * @memberof osi3.WavelengthData
         * @static
         * @param {osi3.IWavelengthData} message WavelengthData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WavelengthData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.start != null && Object.hasOwnProperty.call(message, "start"))
                writer.uint32(/* id 1, wireType 1 =*/9).double(message.start);
            if (message.end != null && Object.hasOwnProperty.call(message, "end"))
                writer.uint32(/* id 2, wireType 1 =*/17).double(message.end);
            if (message.samplesNumber != null && Object.hasOwnProperty.call(message, "samplesNumber"))
                writer.uint32(/* id 3, wireType 1 =*/25).double(message.samplesNumber);
            return writer;
        };

        /**
         * Encodes the specified WavelengthData message, length delimited. Does not implicitly {@link osi3.WavelengthData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof osi3.WavelengthData
         * @static
         * @param {osi3.IWavelengthData} message WavelengthData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WavelengthData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a WavelengthData message from the specified reader or buffer.
         * @function decode
         * @memberof osi3.WavelengthData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {osi3.WavelengthData} WavelengthData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WavelengthData.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.osi3.WavelengthData();
            while (reader.pos < end) {
                let tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.start = reader.double();
                        break;
                    }
                case 2: {
                        message.end = reader.double();
                        break;
                    }
                case 3: {
                        message.samplesNumber = reader.double();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a WavelengthData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof osi3.WavelengthData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {osi3.WavelengthData} WavelengthData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WavelengthData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a WavelengthData message.
         * @function verify
         * @memberof osi3.WavelengthData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        WavelengthData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.start != null && message.hasOwnProperty("start"))
                if (typeof message.start !== "number")
                    return "start: number expected";
            if (message.end != null && message.hasOwnProperty("end"))
                if (typeof message.end !== "number")
                    return "end: number expected";
            if (message.samplesNumber != null && message.hasOwnProperty("samplesNumber"))
                if (typeof message.samplesNumber !== "number")
                    return "samplesNumber: number expected";
            return null;
        };

        /**
         * Creates a WavelengthData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof osi3.WavelengthData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {osi3.WavelengthData} WavelengthData
         */
        WavelengthData.fromObject = function fromObject(object) {
            if (object instanceof $root.osi3.WavelengthData)
                return object;
            let message = new $root.osi3.WavelengthData();
            if (object.start != null)
                message.start = Number(object.start);
            if (object.end != null)
                message.end = Number(object.end);
            if (object.samplesNumber != null)
                message.samplesNumber = Number(object.samplesNumber);
            return message;
        };

        /**
         * Creates a plain object from a WavelengthData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof osi3.WavelengthData
         * @static
         * @param {osi3.WavelengthData} message WavelengthData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        WavelengthData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.start = 0;
                object.end = 0;
                object.samplesNumber = 0;
            }
            if (message.start != null && message.hasOwnProperty("start"))
                object.start = options.json && !isFinite(message.start) ? String(message.start) : message.start;
            if (message.end != null && message.hasOwnProperty("end"))
                object.end = options.json && !isFinite(message.end) ? String(message.end) : message.end;
            if (message.samplesNumber != null && message.hasOwnProperty("samplesNumber"))
                object.samplesNumber = options.json && !isFinite(message.samplesNumber) ? String(message.samplesNumber) : message.samplesNumber;
            return object;
        };

        /**
         * Converts this WavelengthData to JSON.
         * @function toJSON
         * @memberof osi3.WavelengthData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        WavelengthData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for WavelengthData
         * @function getTypeUrl
         * @memberof osi3.WavelengthData
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        WavelengthData.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/osi3.WavelengthData";
        };

        return WavelengthData;
    })();

    osi3.SpatialSignalStrength = (function() {

        /**
         * Properties of a SpatialSignalStrength.
         * @memberof osi3
         * @interface ISpatialSignalStrength
         * @property {number|null} [horizontalAngle] SpatialSignalStrength horizontalAngle
         * @property {number|null} [verticalAngle] SpatialSignalStrength verticalAngle
         * @property {number|null} [signalStrength] SpatialSignalStrength signalStrength
         */

        /**
         * Constructs a new SpatialSignalStrength.
         * @memberof osi3
         * @classdesc Represents a SpatialSignalStrength.
         * @implements ISpatialSignalStrength
         * @constructor
         * @param {osi3.ISpatialSignalStrength=} [properties] Properties to set
         */
        function SpatialSignalStrength(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SpatialSignalStrength horizontalAngle.
         * @member {number} horizontalAngle
         * @memberof osi3.SpatialSignalStrength
         * @instance
         */
        SpatialSignalStrength.prototype.horizontalAngle = 0;

        /**
         * SpatialSignalStrength verticalAngle.
         * @member {number} verticalAngle
         * @memberof osi3.SpatialSignalStrength
         * @instance
         */
        SpatialSignalStrength.prototype.verticalAngle = 0;

        /**
         * SpatialSignalStrength signalStrength.
         * @member {number} signalStrength
         * @memberof osi3.SpatialSignalStrength
         * @instance
         */
        SpatialSignalStrength.prototype.signalStrength = 0;

        /**
         * Creates a new SpatialSignalStrength instance using the specified properties.
         * @function create
         * @memberof osi3.SpatialSignalStrength
         * @static
         * @param {osi3.ISpatialSignalStrength=} [properties] Properties to set
         * @returns {osi3.SpatialSignalStrength} SpatialSignalStrength instance
         */
        SpatialSignalStrength.create = function create(properties) {
            return new SpatialSignalStrength(properties);
        };

        /**
         * Encodes the specified SpatialSignalStrength message. Does not implicitly {@link osi3.SpatialSignalStrength.verify|verify} messages.
         * @function encode
         * @memberof osi3.SpatialSignalStrength
         * @static
         * @param {osi3.ISpatialSignalStrength} message SpatialSignalStrength message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SpatialSignalStrength.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.horizontalAngle != null && Object.hasOwnProperty.call(message, "horizontalAngle"))
                writer.uint32(/* id 1, wireType 1 =*/9).double(message.horizontalAngle);
            if (message.verticalAngle != null && Object.hasOwnProperty.call(message, "verticalAngle"))
                writer.uint32(/* id 2, wireType 1 =*/17).double(message.verticalAngle);
            if (message.signalStrength != null && Object.hasOwnProperty.call(message, "signalStrength"))
                writer.uint32(/* id 3, wireType 1 =*/25).double(message.signalStrength);
            return writer;
        };

        /**
         * Encodes the specified SpatialSignalStrength message, length delimited. Does not implicitly {@link osi3.SpatialSignalStrength.verify|verify} messages.
         * @function encodeDelimited
         * @memberof osi3.SpatialSignalStrength
         * @static
         * @param {osi3.ISpatialSignalStrength} message SpatialSignalStrength message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SpatialSignalStrength.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SpatialSignalStrength message from the specified reader or buffer.
         * @function decode
         * @memberof osi3.SpatialSignalStrength
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {osi3.SpatialSignalStrength} SpatialSignalStrength
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SpatialSignalStrength.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.osi3.SpatialSignalStrength();
            while (reader.pos < end) {
                let tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.horizontalAngle = reader.double();
                        break;
                    }
                case 2: {
                        message.verticalAngle = reader.double();
                        break;
                    }
                case 3: {
                        message.signalStrength = reader.double();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SpatialSignalStrength message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof osi3.SpatialSignalStrength
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {osi3.SpatialSignalStrength} SpatialSignalStrength
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SpatialSignalStrength.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SpatialSignalStrength message.
         * @function verify
         * @memberof osi3.SpatialSignalStrength
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SpatialSignalStrength.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.horizontalAngle != null && message.hasOwnProperty("horizontalAngle"))
                if (typeof message.horizontalAngle !== "number")
                    return "horizontalAngle: number expected";
            if (message.verticalAngle != null && message.hasOwnProperty("verticalAngle"))
                if (typeof message.verticalAngle !== "number")
                    return "verticalAngle: number expected";
            if (message.signalStrength != null && message.hasOwnProperty("signalStrength"))
                if (typeof message.signalStrength !== "number")
                    return "signalStrength: number expected";
            return null;
        };

        /**
         * Creates a SpatialSignalStrength message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof osi3.SpatialSignalStrength
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {osi3.SpatialSignalStrength} SpatialSignalStrength
         */
        SpatialSignalStrength.fromObject = function fromObject(object) {
            if (object instanceof $root.osi3.SpatialSignalStrength)
                return object;
            let message = new $root.osi3.SpatialSignalStrength();
            if (object.horizontalAngle != null)
                message.horizontalAngle = Number(object.horizontalAngle);
            if (object.verticalAngle != null)
                message.verticalAngle = Number(object.verticalAngle);
            if (object.signalStrength != null)
                message.signalStrength = Number(object.signalStrength);
            return message;
        };

        /**
         * Creates a plain object from a SpatialSignalStrength message. Also converts values to other types if specified.
         * @function toObject
         * @memberof osi3.SpatialSignalStrength
         * @static
         * @param {osi3.SpatialSignalStrength} message SpatialSignalStrength
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SpatialSignalStrength.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.horizontalAngle = 0;
                object.verticalAngle = 0;
                object.signalStrength = 0;
            }
            if (message.horizontalAngle != null && message.hasOwnProperty("horizontalAngle"))
                object.horizontalAngle = options.json && !isFinite(message.horizontalAngle) ? String(message.horizontalAngle) : message.horizontalAngle;
            if (message.verticalAngle != null && message.hasOwnProperty("verticalAngle"))
                object.verticalAngle = options.json && !isFinite(message.verticalAngle) ? String(message.verticalAngle) : message.verticalAngle;
            if (message.signalStrength != null && message.hasOwnProperty("signalStrength"))
                object.signalStrength = options.json && !isFinite(message.signalStrength) ? String(message.signalStrength) : message.signalStrength;
            return object;
        };

        /**
         * Converts this SpatialSignalStrength to JSON.
         * @function toJSON
         * @memberof osi3.SpatialSignalStrength
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SpatialSignalStrength.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SpatialSignalStrength
         * @function getTypeUrl
         * @memberof osi3.SpatialSignalStrength
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SpatialSignalStrength.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/osi3.SpatialSignalStrength";
        };

        return SpatialSignalStrength;
    })();

    osi3.ColorDescription = (function() {

        /**
         * Properties of a ColorDescription.
         * @memberof osi3
         * @interface IColorDescription
         * @property {osi3.IColorGrey|null} [grey] ColorDescription grey
         * @property {osi3.IColorRGB|null} [rgb] ColorDescription rgb
         * @property {osi3.IColorRGBIR|null} [rgbir] ColorDescription rgbir
         * @property {osi3.IColorHSV|null} [hsv] ColorDescription hsv
         * @property {osi3.IColorLUV|null} [luv] ColorDescription luv
         * @property {osi3.IColorCMYK|null} [cmyk] ColorDescription cmyk
         */

        /**
         * Constructs a new ColorDescription.
         * @memberof osi3
         * @classdesc Represents a ColorDescription.
         * @implements IColorDescription
         * @constructor
         * @param {osi3.IColorDescription=} [properties] Properties to set
         */
        function ColorDescription(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ColorDescription grey.
         * @member {osi3.IColorGrey|null|undefined} grey
         * @memberof osi3.ColorDescription
         * @instance
         */
        ColorDescription.prototype.grey = null;

        /**
         * ColorDescription rgb.
         * @member {osi3.IColorRGB|null|undefined} rgb
         * @memberof osi3.ColorDescription
         * @instance
         */
        ColorDescription.prototype.rgb = null;

        /**
         * ColorDescription rgbir.
         * @member {osi3.IColorRGBIR|null|undefined} rgbir
         * @memberof osi3.ColorDescription
         * @instance
         */
        ColorDescription.prototype.rgbir = null;

        /**
         * ColorDescription hsv.
         * @member {osi3.IColorHSV|null|undefined} hsv
         * @memberof osi3.ColorDescription
         * @instance
         */
        ColorDescription.prototype.hsv = null;

        /**
         * ColorDescription luv.
         * @member {osi3.IColorLUV|null|undefined} luv
         * @memberof osi3.ColorDescription
         * @instance
         */
        ColorDescription.prototype.luv = null;

        /**
         * ColorDescription cmyk.
         * @member {osi3.IColorCMYK|null|undefined} cmyk
         * @memberof osi3.ColorDescription
         * @instance
         */
        ColorDescription.prototype.cmyk = null;

        /**
         * Creates a new ColorDescription instance using the specified properties.
         * @function create
         * @memberof osi3.ColorDescription
         * @static
         * @param {osi3.IColorDescription=} [properties] Properties to set
         * @returns {osi3.ColorDescription} ColorDescription instance
         */
        ColorDescription.create = function create(properties) {
            return new ColorDescription(properties);
        };

        /**
         * Encodes the specified ColorDescription message. Does not implicitly {@link osi3.ColorDescription.verify|verify} messages.
         * @function encode
         * @memberof osi3.ColorDescription
         * @static
         * @param {osi3.IColorDescription} message ColorDescription message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ColorDescription.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.grey != null && Object.hasOwnProperty.call(message, "grey"))
                $root.osi3.ColorGrey.encode(message.grey, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.rgb != null && Object.hasOwnProperty.call(message, "rgb"))
                $root.osi3.ColorRGB.encode(message.rgb, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.rgbir != null && Object.hasOwnProperty.call(message, "rgbir"))
                $root.osi3.ColorRGBIR.encode(message.rgbir, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.hsv != null && Object.hasOwnProperty.call(message, "hsv"))
                $root.osi3.ColorHSV.encode(message.hsv, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.luv != null && Object.hasOwnProperty.call(message, "luv"))
                $root.osi3.ColorLUV.encode(message.luv, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.cmyk != null && Object.hasOwnProperty.call(message, "cmyk"))
                $root.osi3.ColorCMYK.encode(message.cmyk, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ColorDescription message, length delimited. Does not implicitly {@link osi3.ColorDescription.verify|verify} messages.
         * @function encodeDelimited
         * @memberof osi3.ColorDescription
         * @static
         * @param {osi3.IColorDescription} message ColorDescription message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ColorDescription.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ColorDescription message from the specified reader or buffer.
         * @function decode
         * @memberof osi3.ColorDescription
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {osi3.ColorDescription} ColorDescription
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ColorDescription.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.osi3.ColorDescription();
            while (reader.pos < end) {
                let tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.grey = $root.osi3.ColorGrey.decode(reader, reader.uint32());
                        break;
                    }
                case 2: {
                        message.rgb = $root.osi3.ColorRGB.decode(reader, reader.uint32());
                        break;
                    }
                case 3: {
                        message.rgbir = $root.osi3.ColorRGBIR.decode(reader, reader.uint32());
                        break;
                    }
                case 4: {
                        message.hsv = $root.osi3.ColorHSV.decode(reader, reader.uint32());
                        break;
                    }
                case 5: {
                        message.luv = $root.osi3.ColorLUV.decode(reader, reader.uint32());
                        break;
                    }
                case 6: {
                        message.cmyk = $root.osi3.ColorCMYK.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ColorDescription message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof osi3.ColorDescription
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {osi3.ColorDescription} ColorDescription
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ColorDescription.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ColorDescription message.
         * @function verify
         * @memberof osi3.ColorDescription
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ColorDescription.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.grey != null && message.hasOwnProperty("grey")) {
                let error = $root.osi3.ColorGrey.verify(message.grey);
                if (error)
                    return "grey." + error;
            }
            if (message.rgb != null && message.hasOwnProperty("rgb")) {
                let error = $root.osi3.ColorRGB.verify(message.rgb);
                if (error)
                    return "rgb." + error;
            }
            if (message.rgbir != null && message.hasOwnProperty("rgbir")) {
                let error = $root.osi3.ColorRGBIR.verify(message.rgbir);
                if (error)
                    return "rgbir." + error;
            }
            if (message.hsv != null && message.hasOwnProperty("hsv")) {
                let error = $root.osi3.ColorHSV.verify(message.hsv);
                if (error)
                    return "hsv." + error;
            }
            if (message.luv != null && message.hasOwnProperty("luv")) {
                let error = $root.osi3.ColorLUV.verify(message.luv);
                if (error)
                    return "luv." + error;
            }
            if (message.cmyk != null && message.hasOwnProperty("cmyk")) {
                let error = $root.osi3.ColorCMYK.verify(message.cmyk);
                if (error)
                    return "cmyk." + error;
            }
            return null;
        };

        /**
         * Creates a ColorDescription message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof osi3.ColorDescription
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {osi3.ColorDescription} ColorDescription
         */
        ColorDescription.fromObject = function fromObject(object) {
            if (object instanceof $root.osi3.ColorDescription)
                return object;
            let message = new $root.osi3.ColorDescription();
            if (object.grey != null) {
                if (typeof object.grey !== "object")
                    throw TypeError(".osi3.ColorDescription.grey: object expected");
                message.grey = $root.osi3.ColorGrey.fromObject(object.grey);
            }
            if (object.rgb != null) {
                if (typeof object.rgb !== "object")
                    throw TypeError(".osi3.ColorDescription.rgb: object expected");
                message.rgb = $root.osi3.ColorRGB.fromObject(object.rgb);
            }
            if (object.rgbir != null) {
                if (typeof object.rgbir !== "object")
                    throw TypeError(".osi3.ColorDescription.rgbir: object expected");
                message.rgbir = $root.osi3.ColorRGBIR.fromObject(object.rgbir);
            }
            if (object.hsv != null) {
                if (typeof object.hsv !== "object")
                    throw TypeError(".osi3.ColorDescription.hsv: object expected");
                message.hsv = $root.osi3.ColorHSV.fromObject(object.hsv);
            }
            if (object.luv != null) {
                if (typeof object.luv !== "object")
                    throw TypeError(".osi3.ColorDescription.luv: object expected");
                message.luv = $root.osi3.ColorLUV.fromObject(object.luv);
            }
            if (object.cmyk != null) {
                if (typeof object.cmyk !== "object")
                    throw TypeError(".osi3.ColorDescription.cmyk: object expected");
                message.cmyk = $root.osi3.ColorCMYK.fromObject(object.cmyk);
            }
            return message;
        };

        /**
         * Creates a plain object from a ColorDescription message. Also converts values to other types if specified.
         * @function toObject
         * @memberof osi3.ColorDescription
         * @static
         * @param {osi3.ColorDescription} message ColorDescription
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ColorDescription.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.grey = null;
                object.rgb = null;
                object.rgbir = null;
                object.hsv = null;
                object.luv = null;
                object.cmyk = null;
            }
            if (message.grey != null && message.hasOwnProperty("grey"))
                object.grey = $root.osi3.ColorGrey.toObject(message.grey, options);
            if (message.rgb != null && message.hasOwnProperty("rgb"))
                object.rgb = $root.osi3.ColorRGB.toObject(message.rgb, options);
            if (message.rgbir != null && message.hasOwnProperty("rgbir"))
                object.rgbir = $root.osi3.ColorRGBIR.toObject(message.rgbir, options);
            if (message.hsv != null && message.hasOwnProperty("hsv"))
                object.hsv = $root.osi3.ColorHSV.toObject(message.hsv, options);
            if (message.luv != null && message.hasOwnProperty("luv"))
                object.luv = $root.osi3.ColorLUV.toObject(message.luv, options);
            if (message.cmyk != null && message.hasOwnProperty("cmyk"))
                object.cmyk = $root.osi3.ColorCMYK.toObject(message.cmyk, options);
            return object;
        };

        /**
         * Converts this ColorDescription to JSON.
         * @function toJSON
         * @memberof osi3.ColorDescription
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ColorDescription.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ColorDescription
         * @function getTypeUrl
         * @memberof osi3.ColorDescription
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ColorDescription.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/osi3.ColorDescription";
        };

        return ColorDescription;
    })();

    osi3.ColorGrey = (function() {

        /**
         * Properties of a ColorGrey.
         * @memberof osi3
         * @interface IColorGrey
         * @property {number|null} [grey] ColorGrey grey
         */

        /**
         * Constructs a new ColorGrey.
         * @memberof osi3
         * @classdesc Represents a ColorGrey.
         * @implements IColorGrey
         * @constructor
         * @param {osi3.IColorGrey=} [properties] Properties to set
         */
        function ColorGrey(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ColorGrey grey.
         * @member {number} grey
         * @memberof osi3.ColorGrey
         * @instance
         */
        ColorGrey.prototype.grey = 0;

        /**
         * Creates a new ColorGrey instance using the specified properties.
         * @function create
         * @memberof osi3.ColorGrey
         * @static
         * @param {osi3.IColorGrey=} [properties] Properties to set
         * @returns {osi3.ColorGrey} ColorGrey instance
         */
        ColorGrey.create = function create(properties) {
            return new ColorGrey(properties);
        };

        /**
         * Encodes the specified ColorGrey message. Does not implicitly {@link osi3.ColorGrey.verify|verify} messages.
         * @function encode
         * @memberof osi3.ColorGrey
         * @static
         * @param {osi3.IColorGrey} message ColorGrey message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ColorGrey.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.grey != null && Object.hasOwnProperty.call(message, "grey"))
                writer.uint32(/* id 1, wireType 1 =*/9).double(message.grey);
            return writer;
        };

        /**
         * Encodes the specified ColorGrey message, length delimited. Does not implicitly {@link osi3.ColorGrey.verify|verify} messages.
         * @function encodeDelimited
         * @memberof osi3.ColorGrey
         * @static
         * @param {osi3.IColorGrey} message ColorGrey message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ColorGrey.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ColorGrey message from the specified reader or buffer.
         * @function decode
         * @memberof osi3.ColorGrey
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {osi3.ColorGrey} ColorGrey
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ColorGrey.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.osi3.ColorGrey();
            while (reader.pos < end) {
                let tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.grey = reader.double();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ColorGrey message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof osi3.ColorGrey
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {osi3.ColorGrey} ColorGrey
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ColorGrey.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ColorGrey message.
         * @function verify
         * @memberof osi3.ColorGrey
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ColorGrey.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.grey != null && message.hasOwnProperty("grey"))
                if (typeof message.grey !== "number")
                    return "grey: number expected";
            return null;
        };

        /**
         * Creates a ColorGrey message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof osi3.ColorGrey
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {osi3.ColorGrey} ColorGrey
         */
        ColorGrey.fromObject = function fromObject(object) {
            if (object instanceof $root.osi3.ColorGrey)
                return object;
            let message = new $root.osi3.ColorGrey();
            if (object.grey != null)
                message.grey = Number(object.grey);
            return message;
        };

        /**
         * Creates a plain object from a ColorGrey message. Also converts values to other types if specified.
         * @function toObject
         * @memberof osi3.ColorGrey
         * @static
         * @param {osi3.ColorGrey} message ColorGrey
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ColorGrey.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.grey = 0;
            if (message.grey != null && message.hasOwnProperty("grey"))
                object.grey = options.json && !isFinite(message.grey) ? String(message.grey) : message.grey;
            return object;
        };

        /**
         * Converts this ColorGrey to JSON.
         * @function toJSON
         * @memberof osi3.ColorGrey
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ColorGrey.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ColorGrey
         * @function getTypeUrl
         * @memberof osi3.ColorGrey
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ColorGrey.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/osi3.ColorGrey";
        };

        return ColorGrey;
    })();

    osi3.ColorRGB = (function() {

        /**
         * Properties of a ColorRGB.
         * @memberof osi3
         * @interface IColorRGB
         * @property {number|null} [red] ColorRGB red
         * @property {number|null} [green] ColorRGB green
         * @property {number|null} [blue] ColorRGB blue
         */

        /**
         * Constructs a new ColorRGB.
         * @memberof osi3
         * @classdesc Represents a ColorRGB.
         * @implements IColorRGB
         * @constructor
         * @param {osi3.IColorRGB=} [properties] Properties to set
         */
        function ColorRGB(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ColorRGB red.
         * @member {number} red
         * @memberof osi3.ColorRGB
         * @instance
         */
        ColorRGB.prototype.red = 0;

        /**
         * ColorRGB green.
         * @member {number} green
         * @memberof osi3.ColorRGB
         * @instance
         */
        ColorRGB.prototype.green = 0;

        /**
         * ColorRGB blue.
         * @member {number} blue
         * @memberof osi3.ColorRGB
         * @instance
         */
        ColorRGB.prototype.blue = 0;

        /**
         * Creates a new ColorRGB instance using the specified properties.
         * @function create
         * @memberof osi3.ColorRGB
         * @static
         * @param {osi3.IColorRGB=} [properties] Properties to set
         * @returns {osi3.ColorRGB} ColorRGB instance
         */
        ColorRGB.create = function create(properties) {
            return new ColorRGB(properties);
        };

        /**
         * Encodes the specified ColorRGB message. Does not implicitly {@link osi3.ColorRGB.verify|verify} messages.
         * @function encode
         * @memberof osi3.ColorRGB
         * @static
         * @param {osi3.IColorRGB} message ColorRGB message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ColorRGB.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.red != null && Object.hasOwnProperty.call(message, "red"))
                writer.uint32(/* id 1, wireType 1 =*/9).double(message.red);
            if (message.green != null && Object.hasOwnProperty.call(message, "green"))
                writer.uint32(/* id 2, wireType 1 =*/17).double(message.green);
            if (message.blue != null && Object.hasOwnProperty.call(message, "blue"))
                writer.uint32(/* id 3, wireType 1 =*/25).double(message.blue);
            return writer;
        };

        /**
         * Encodes the specified ColorRGB message, length delimited. Does not implicitly {@link osi3.ColorRGB.verify|verify} messages.
         * @function encodeDelimited
         * @memberof osi3.ColorRGB
         * @static
         * @param {osi3.IColorRGB} message ColorRGB message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ColorRGB.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ColorRGB message from the specified reader or buffer.
         * @function decode
         * @memberof osi3.ColorRGB
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {osi3.ColorRGB} ColorRGB
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ColorRGB.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.osi3.ColorRGB();
            while (reader.pos < end) {
                let tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.red = reader.double();
                        break;
                    }
                case 2: {
                        message.green = reader.double();
                        break;
                    }
                case 3: {
                        message.blue = reader.double();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ColorRGB message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof osi3.ColorRGB
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {osi3.ColorRGB} ColorRGB
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ColorRGB.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ColorRGB message.
         * @function verify
         * @memberof osi3.ColorRGB
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ColorRGB.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.red != null && message.hasOwnProperty("red"))
                if (typeof message.red !== "number")
                    return "red: number expected";
            if (message.green != null && message.hasOwnProperty("green"))
                if (typeof message.green !== "number")
                    return "green: number expected";
            if (message.blue != null && message.hasOwnProperty("blue"))
                if (typeof message.blue !== "number")
                    return "blue: number expected";
            return null;
        };

        /**
         * Creates a ColorRGB message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof osi3.ColorRGB
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {osi3.ColorRGB} ColorRGB
         */
        ColorRGB.fromObject = function fromObject(object) {
            if (object instanceof $root.osi3.ColorRGB)
                return object;
            let message = new $root.osi3.ColorRGB();
            if (object.red != null)
                message.red = Number(object.red);
            if (object.green != null)
                message.green = Number(object.green);
            if (object.blue != null)
                message.blue = Number(object.blue);
            return message;
        };

        /**
         * Creates a plain object from a ColorRGB message. Also converts values to other types if specified.
         * @function toObject
         * @memberof osi3.ColorRGB
         * @static
         * @param {osi3.ColorRGB} message ColorRGB
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ColorRGB.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.red = 0;
                object.green = 0;
                object.blue = 0;
            }
            if (message.red != null && message.hasOwnProperty("red"))
                object.red = options.json && !isFinite(message.red) ? String(message.red) : message.red;
            if (message.green != null && message.hasOwnProperty("green"))
                object.green = options.json && !isFinite(message.green) ? String(message.green) : message.green;
            if (message.blue != null && message.hasOwnProperty("blue"))
                object.blue = options.json && !isFinite(message.blue) ? String(message.blue) : message.blue;
            return object;
        };

        /**
         * Converts this ColorRGB to JSON.
         * @function toJSON
         * @memberof osi3.ColorRGB
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ColorRGB.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ColorRGB
         * @function getTypeUrl
         * @memberof osi3.ColorRGB
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ColorRGB.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/osi3.ColorRGB";
        };

        return ColorRGB;
    })();

    osi3.ColorRGBIR = (function() {

        /**
         * Properties of a ColorRGBIR.
         * @memberof osi3
         * @interface IColorRGBIR
         * @property {number|null} [red] ColorRGBIR red
         * @property {number|null} [green] ColorRGBIR green
         * @property {number|null} [blue] ColorRGBIR blue
         * @property {number|null} [infrared] ColorRGBIR infrared
         */

        /**
         * Constructs a new ColorRGBIR.
         * @memberof osi3
         * @classdesc Represents a ColorRGBIR.
         * @implements IColorRGBIR
         * @constructor
         * @param {osi3.IColorRGBIR=} [properties] Properties to set
         */
        function ColorRGBIR(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ColorRGBIR red.
         * @member {number} red
         * @memberof osi3.ColorRGBIR
         * @instance
         */
        ColorRGBIR.prototype.red = 0;

        /**
         * ColorRGBIR green.
         * @member {number} green
         * @memberof osi3.ColorRGBIR
         * @instance
         */
        ColorRGBIR.prototype.green = 0;

        /**
         * ColorRGBIR blue.
         * @member {number} blue
         * @memberof osi3.ColorRGBIR
         * @instance
         */
        ColorRGBIR.prototype.blue = 0;

        /**
         * ColorRGBIR infrared.
         * @member {number} infrared
         * @memberof osi3.ColorRGBIR
         * @instance
         */
        ColorRGBIR.prototype.infrared = 0;

        /**
         * Creates a new ColorRGBIR instance using the specified properties.
         * @function create
         * @memberof osi3.ColorRGBIR
         * @static
         * @param {osi3.IColorRGBIR=} [properties] Properties to set
         * @returns {osi3.ColorRGBIR} ColorRGBIR instance
         */
        ColorRGBIR.create = function create(properties) {
            return new ColorRGBIR(properties);
        };

        /**
         * Encodes the specified ColorRGBIR message. Does not implicitly {@link osi3.ColorRGBIR.verify|verify} messages.
         * @function encode
         * @memberof osi3.ColorRGBIR
         * @static
         * @param {osi3.IColorRGBIR} message ColorRGBIR message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ColorRGBIR.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.red != null && Object.hasOwnProperty.call(message, "red"))
                writer.uint32(/* id 1, wireType 1 =*/9).double(message.red);
            if (message.green != null && Object.hasOwnProperty.call(message, "green"))
                writer.uint32(/* id 2, wireType 1 =*/17).double(message.green);
            if (message.blue != null && Object.hasOwnProperty.call(message, "blue"))
                writer.uint32(/* id 3, wireType 1 =*/25).double(message.blue);
            if (message.infrared != null && Object.hasOwnProperty.call(message, "infrared"))
                writer.uint32(/* id 4, wireType 1 =*/33).double(message.infrared);
            return writer;
        };

        /**
         * Encodes the specified ColorRGBIR message, length delimited. Does not implicitly {@link osi3.ColorRGBIR.verify|verify} messages.
         * @function encodeDelimited
         * @memberof osi3.ColorRGBIR
         * @static
         * @param {osi3.IColorRGBIR} message ColorRGBIR message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ColorRGBIR.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ColorRGBIR message from the specified reader or buffer.
         * @function decode
         * @memberof osi3.ColorRGBIR
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {osi3.ColorRGBIR} ColorRGBIR
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ColorRGBIR.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.osi3.ColorRGBIR();
            while (reader.pos < end) {
                let tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.red = reader.double();
                        break;
                    }
                case 2: {
                        message.green = reader.double();
                        break;
                    }
                case 3: {
                        message.blue = reader.double();
                        break;
                    }
                case 4: {
                        message.infrared = reader.double();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ColorRGBIR message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof osi3.ColorRGBIR
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {osi3.ColorRGBIR} ColorRGBIR
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ColorRGBIR.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ColorRGBIR message.
         * @function verify
         * @memberof osi3.ColorRGBIR
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ColorRGBIR.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.red != null && message.hasOwnProperty("red"))
                if (typeof message.red !== "number")
                    return "red: number expected";
            if (message.green != null && message.hasOwnProperty("green"))
                if (typeof message.green !== "number")
                    return "green: number expected";
            if (message.blue != null && message.hasOwnProperty("blue"))
                if (typeof message.blue !== "number")
                    return "blue: number expected";
            if (message.infrared != null && message.hasOwnProperty("infrared"))
                if (typeof message.infrared !== "number")
                    return "infrared: number expected";
            return null;
        };

        /**
         * Creates a ColorRGBIR message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof osi3.ColorRGBIR
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {osi3.ColorRGBIR} ColorRGBIR
         */
        ColorRGBIR.fromObject = function fromObject(object) {
            if (object instanceof $root.osi3.ColorRGBIR)
                return object;
            let message = new $root.osi3.ColorRGBIR();
            if (object.red != null)
                message.red = Number(object.red);
            if (object.green != null)
                message.green = Number(object.green);
            if (object.blue != null)
                message.blue = Number(object.blue);
            if (object.infrared != null)
                message.infrared = Number(object.infrared);
            return message;
        };

        /**
         * Creates a plain object from a ColorRGBIR message. Also converts values to other types if specified.
         * @function toObject
         * @memberof osi3.ColorRGBIR
         * @static
         * @param {osi3.ColorRGBIR} message ColorRGBIR
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ColorRGBIR.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.red = 0;
                object.green = 0;
                object.blue = 0;
                object.infrared = 0;
            }
            if (message.red != null && message.hasOwnProperty("red"))
                object.red = options.json && !isFinite(message.red) ? String(message.red) : message.red;
            if (message.green != null && message.hasOwnProperty("green"))
                object.green = options.json && !isFinite(message.green) ? String(message.green) : message.green;
            if (message.blue != null && message.hasOwnProperty("blue"))
                object.blue = options.json && !isFinite(message.blue) ? String(message.blue) : message.blue;
            if (message.infrared != null && message.hasOwnProperty("infrared"))
                object.infrared = options.json && !isFinite(message.infrared) ? String(message.infrared) : message.infrared;
            return object;
        };

        /**
         * Converts this ColorRGBIR to JSON.
         * @function toJSON
         * @memberof osi3.ColorRGBIR
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ColorRGBIR.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ColorRGBIR
         * @function getTypeUrl
         * @memberof osi3.ColorRGBIR
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ColorRGBIR.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/osi3.ColorRGBIR";
        };

        return ColorRGBIR;
    })();

    osi3.ColorHSV = (function() {

        /**
         * Properties of a ColorHSV.
         * @memberof osi3
         * @interface IColorHSV
         * @property {number|null} [hue] ColorHSV hue
         * @property {number|null} [saturation] ColorHSV saturation
         * @property {number|null} [value] ColorHSV value
         */

        /**
         * Constructs a new ColorHSV.
         * @memberof osi3
         * @classdesc Represents a ColorHSV.
         * @implements IColorHSV
         * @constructor
         * @param {osi3.IColorHSV=} [properties] Properties to set
         */
        function ColorHSV(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ColorHSV hue.
         * @member {number} hue
         * @memberof osi3.ColorHSV
         * @instance
         */
        ColorHSV.prototype.hue = 0;

        /**
         * ColorHSV saturation.
         * @member {number} saturation
         * @memberof osi3.ColorHSV
         * @instance
         */
        ColorHSV.prototype.saturation = 0;

        /**
         * ColorHSV value.
         * @member {number} value
         * @memberof osi3.ColorHSV
         * @instance
         */
        ColorHSV.prototype.value = 0;

        /**
         * Creates a new ColorHSV instance using the specified properties.
         * @function create
         * @memberof osi3.ColorHSV
         * @static
         * @param {osi3.IColorHSV=} [properties] Properties to set
         * @returns {osi3.ColorHSV} ColorHSV instance
         */
        ColorHSV.create = function create(properties) {
            return new ColorHSV(properties);
        };

        /**
         * Encodes the specified ColorHSV message. Does not implicitly {@link osi3.ColorHSV.verify|verify} messages.
         * @function encode
         * @memberof osi3.ColorHSV
         * @static
         * @param {osi3.IColorHSV} message ColorHSV message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ColorHSV.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.hue != null && Object.hasOwnProperty.call(message, "hue"))
                writer.uint32(/* id 1, wireType 1 =*/9).double(message.hue);
            if (message.saturation != null && Object.hasOwnProperty.call(message, "saturation"))
                writer.uint32(/* id 2, wireType 1 =*/17).double(message.saturation);
            if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                writer.uint32(/* id 3, wireType 1 =*/25).double(message.value);
            return writer;
        };

        /**
         * Encodes the specified ColorHSV message, length delimited. Does not implicitly {@link osi3.ColorHSV.verify|verify} messages.
         * @function encodeDelimited
         * @memberof osi3.ColorHSV
         * @static
         * @param {osi3.IColorHSV} message ColorHSV message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ColorHSV.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ColorHSV message from the specified reader or buffer.
         * @function decode
         * @memberof osi3.ColorHSV
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {osi3.ColorHSV} ColorHSV
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ColorHSV.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.osi3.ColorHSV();
            while (reader.pos < end) {
                let tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.hue = reader.double();
                        break;
                    }
                case 2: {
                        message.saturation = reader.double();
                        break;
                    }
                case 3: {
                        message.value = reader.double();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ColorHSV message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof osi3.ColorHSV
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {osi3.ColorHSV} ColorHSV
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ColorHSV.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ColorHSV message.
         * @function verify
         * @memberof osi3.ColorHSV
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ColorHSV.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.hue != null && message.hasOwnProperty("hue"))
                if (typeof message.hue !== "number")
                    return "hue: number expected";
            if (message.saturation != null && message.hasOwnProperty("saturation"))
                if (typeof message.saturation !== "number")
                    return "saturation: number expected";
            if (message.value != null && message.hasOwnProperty("value"))
                if (typeof message.value !== "number")
                    return "value: number expected";
            return null;
        };

        /**
         * Creates a ColorHSV message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof osi3.ColorHSV
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {osi3.ColorHSV} ColorHSV
         */
        ColorHSV.fromObject = function fromObject(object) {
            if (object instanceof $root.osi3.ColorHSV)
                return object;
            let message = new $root.osi3.ColorHSV();
            if (object.hue != null)
                message.hue = Number(object.hue);
            if (object.saturation != null)
                message.saturation = Number(object.saturation);
            if (object.value != null)
                message.value = Number(object.value);
            return message;
        };

        /**
         * Creates a plain object from a ColorHSV message. Also converts values to other types if specified.
         * @function toObject
         * @memberof osi3.ColorHSV
         * @static
         * @param {osi3.ColorHSV} message ColorHSV
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ColorHSV.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.hue = 0;
                object.saturation = 0;
                object.value = 0;
            }
            if (message.hue != null && message.hasOwnProperty("hue"))
                object.hue = options.json && !isFinite(message.hue) ? String(message.hue) : message.hue;
            if (message.saturation != null && message.hasOwnProperty("saturation"))
                object.saturation = options.json && !isFinite(message.saturation) ? String(message.saturation) : message.saturation;
            if (message.value != null && message.hasOwnProperty("value"))
                object.value = options.json && !isFinite(message.value) ? String(message.value) : message.value;
            return object;
        };

        /**
         * Converts this ColorHSV to JSON.
         * @function toJSON
         * @memberof osi3.ColorHSV
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ColorHSV.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ColorHSV
         * @function getTypeUrl
         * @memberof osi3.ColorHSV
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ColorHSV.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/osi3.ColorHSV";
        };

        return ColorHSV;
    })();

    osi3.ColorLUV = (function() {

        /**
         * Properties of a ColorLUV.
         * @memberof osi3
         * @interface IColorLUV
         * @property {number|null} [luminance] ColorLUV luminance
         * @property {number|null} [u] ColorLUV u
         * @property {number|null} [v] ColorLUV v
         */

        /**
         * Constructs a new ColorLUV.
         * @memberof osi3
         * @classdesc Represents a ColorLUV.
         * @implements IColorLUV
         * @constructor
         * @param {osi3.IColorLUV=} [properties] Properties to set
         */
        function ColorLUV(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ColorLUV luminance.
         * @member {number} luminance
         * @memberof osi3.ColorLUV
         * @instance
         */
        ColorLUV.prototype.luminance = 0;

        /**
         * ColorLUV u.
         * @member {number} u
         * @memberof osi3.ColorLUV
         * @instance
         */
        ColorLUV.prototype.u = 0;

        /**
         * ColorLUV v.
         * @member {number} v
         * @memberof osi3.ColorLUV
         * @instance
         */
        ColorLUV.prototype.v = 0;

        /**
         * Creates a new ColorLUV instance using the specified properties.
         * @function create
         * @memberof osi3.ColorLUV
         * @static
         * @param {osi3.IColorLUV=} [properties] Properties to set
         * @returns {osi3.ColorLUV} ColorLUV instance
         */
        ColorLUV.create = function create(properties) {
            return new ColorLUV(properties);
        };

        /**
         * Encodes the specified ColorLUV message. Does not implicitly {@link osi3.ColorLUV.verify|verify} messages.
         * @function encode
         * @memberof osi3.ColorLUV
         * @static
         * @param {osi3.IColorLUV} message ColorLUV message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ColorLUV.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.luminance != null && Object.hasOwnProperty.call(message, "luminance"))
                writer.uint32(/* id 1, wireType 1 =*/9).double(message.luminance);
            if (message.u != null && Object.hasOwnProperty.call(message, "u"))
                writer.uint32(/* id 2, wireType 1 =*/17).double(message.u);
            if (message.v != null && Object.hasOwnProperty.call(message, "v"))
                writer.uint32(/* id 3, wireType 1 =*/25).double(message.v);
            return writer;
        };

        /**
         * Encodes the specified ColorLUV message, length delimited. Does not implicitly {@link osi3.ColorLUV.verify|verify} messages.
         * @function encodeDelimited
         * @memberof osi3.ColorLUV
         * @static
         * @param {osi3.IColorLUV} message ColorLUV message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ColorLUV.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ColorLUV message from the specified reader or buffer.
         * @function decode
         * @memberof osi3.ColorLUV
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {osi3.ColorLUV} ColorLUV
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ColorLUV.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.osi3.ColorLUV();
            while (reader.pos < end) {
                let tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.luminance = reader.double();
                        break;
                    }
                case 2: {
                        message.u = reader.double();
                        break;
                    }
                case 3: {
                        message.v = reader.double();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ColorLUV message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof osi3.ColorLUV
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {osi3.ColorLUV} ColorLUV
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ColorLUV.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ColorLUV message.
         * @function verify
         * @memberof osi3.ColorLUV
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ColorLUV.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.luminance != null && message.hasOwnProperty("luminance"))
                if (typeof message.luminance !== "number")
                    return "luminance: number expected";
            if (message.u != null && message.hasOwnProperty("u"))
                if (typeof message.u !== "number")
                    return "u: number expected";
            if (message.v != null && message.hasOwnProperty("v"))
                if (typeof message.v !== "number")
                    return "v: number expected";
            return null;
        };

        /**
         * Creates a ColorLUV message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof osi3.ColorLUV
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {osi3.ColorLUV} ColorLUV
         */
        ColorLUV.fromObject = function fromObject(object) {
            if (object instanceof $root.osi3.ColorLUV)
                return object;
            let message = new $root.osi3.ColorLUV();
            if (object.luminance != null)
                message.luminance = Number(object.luminance);
            if (object.u != null)
                message.u = Number(object.u);
            if (object.v != null)
                message.v = Number(object.v);
            return message;
        };

        /**
         * Creates a plain object from a ColorLUV message. Also converts values to other types if specified.
         * @function toObject
         * @memberof osi3.ColorLUV
         * @static
         * @param {osi3.ColorLUV} message ColorLUV
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ColorLUV.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.luminance = 0;
                object.u = 0;
                object.v = 0;
            }
            if (message.luminance != null && message.hasOwnProperty("luminance"))
                object.luminance = options.json && !isFinite(message.luminance) ? String(message.luminance) : message.luminance;
            if (message.u != null && message.hasOwnProperty("u"))
                object.u = options.json && !isFinite(message.u) ? String(message.u) : message.u;
            if (message.v != null && message.hasOwnProperty("v"))
                object.v = options.json && !isFinite(message.v) ? String(message.v) : message.v;
            return object;
        };

        /**
         * Converts this ColorLUV to JSON.
         * @function toJSON
         * @memberof osi3.ColorLUV
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ColorLUV.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ColorLUV
         * @function getTypeUrl
         * @memberof osi3.ColorLUV
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ColorLUV.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/osi3.ColorLUV";
        };

        return ColorLUV;
    })();

    osi3.ColorCMYK = (function() {

        /**
         * Properties of a ColorCMYK.
         * @memberof osi3
         * @interface IColorCMYK
         * @property {number|null} [cyan] ColorCMYK cyan
         * @property {number|null} [magenta] ColorCMYK magenta
         * @property {number|null} [yellow] ColorCMYK yellow
         * @property {number|null} [key] ColorCMYK key
         */

        /**
         * Constructs a new ColorCMYK.
         * @memberof osi3
         * @classdesc Represents a ColorCMYK.
         * @implements IColorCMYK
         * @constructor
         * @param {osi3.IColorCMYK=} [properties] Properties to set
         */
        function ColorCMYK(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ColorCMYK cyan.
         * @member {number} cyan
         * @memberof osi3.ColorCMYK
         * @instance
         */
        ColorCMYK.prototype.cyan = 0;

        /**
         * ColorCMYK magenta.
         * @member {number} magenta
         * @memberof osi3.ColorCMYK
         * @instance
         */
        ColorCMYK.prototype.magenta = 0;

        /**
         * ColorCMYK yellow.
         * @member {number} yellow
         * @memberof osi3.ColorCMYK
         * @instance
         */
        ColorCMYK.prototype.yellow = 0;

        /**
         * ColorCMYK key.
         * @member {number} key
         * @memberof osi3.ColorCMYK
         * @instance
         */
        ColorCMYK.prototype.key = 0;

        /**
         * Creates a new ColorCMYK instance using the specified properties.
         * @function create
         * @memberof osi3.ColorCMYK
         * @static
         * @param {osi3.IColorCMYK=} [properties] Properties to set
         * @returns {osi3.ColorCMYK} ColorCMYK instance
         */
        ColorCMYK.create = function create(properties) {
            return new ColorCMYK(properties);
        };

        /**
         * Encodes the specified ColorCMYK message. Does not implicitly {@link osi3.ColorCMYK.verify|verify} messages.
         * @function encode
         * @memberof osi3.ColorCMYK
         * @static
         * @param {osi3.IColorCMYK} message ColorCMYK message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ColorCMYK.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.cyan != null && Object.hasOwnProperty.call(message, "cyan"))
                writer.uint32(/* id 1, wireType 1 =*/9).double(message.cyan);
            if (message.magenta != null && Object.hasOwnProperty.call(message, "magenta"))
                writer.uint32(/* id 2, wireType 1 =*/17).double(message.magenta);
            if (message.yellow != null && Object.hasOwnProperty.call(message, "yellow"))
                writer.uint32(/* id 3, wireType 1 =*/25).double(message.yellow);
            if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                writer.uint32(/* id 4, wireType 1 =*/33).double(message.key);
            return writer;
        };

        /**
         * Encodes the specified ColorCMYK message, length delimited. Does not implicitly {@link osi3.ColorCMYK.verify|verify} messages.
         * @function encodeDelimited
         * @memberof osi3.ColorCMYK
         * @static
         * @param {osi3.IColorCMYK} message ColorCMYK message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ColorCMYK.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ColorCMYK message from the specified reader or buffer.
         * @function decode
         * @memberof osi3.ColorCMYK
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {osi3.ColorCMYK} ColorCMYK
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ColorCMYK.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.osi3.ColorCMYK();
            while (reader.pos < end) {
                let tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.cyan = reader.double();
                        break;
                    }
                case 2: {
                        message.magenta = reader.double();
                        break;
                    }
                case 3: {
                        message.yellow = reader.double();
                        break;
                    }
                case 4: {
                        message.key = reader.double();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ColorCMYK message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof osi3.ColorCMYK
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {osi3.ColorCMYK} ColorCMYK
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ColorCMYK.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ColorCMYK message.
         * @function verify
         * @memberof osi3.ColorCMYK
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ColorCMYK.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.cyan != null && message.hasOwnProperty("cyan"))
                if (typeof message.cyan !== "number")
                    return "cyan: number expected";
            if (message.magenta != null && message.hasOwnProperty("magenta"))
                if (typeof message.magenta !== "number")
                    return "magenta: number expected";
            if (message.yellow != null && message.hasOwnProperty("yellow"))
                if (typeof message.yellow !== "number")
                    return "yellow: number expected";
            if (message.key != null && message.hasOwnProperty("key"))
                if (typeof message.key !== "number")
                    return "key: number expected";
            return null;
        };

        /**
         * Creates a ColorCMYK message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof osi3.ColorCMYK
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {osi3.ColorCMYK} ColorCMYK
         */
        ColorCMYK.fromObject = function fromObject(object) {
            if (object instanceof $root.osi3.ColorCMYK)
                return object;
            let message = new $root.osi3.ColorCMYK();
            if (object.cyan != null)
                message.cyan = Number(object.cyan);
            if (object.magenta != null)
                message.magenta = Number(object.magenta);
            if (object.yellow != null)
                message.yellow = Number(object.yellow);
            if (object.key != null)
                message.key = Number(object.key);
            return message;
        };

        /**
         * Creates a plain object from a ColorCMYK message. Also converts values to other types if specified.
         * @function toObject
         * @memberof osi3.ColorCMYK
         * @static
         * @param {osi3.ColorCMYK} message ColorCMYK
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ColorCMYK.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.cyan = 0;
                object.magenta = 0;
                object.yellow = 0;
                object.key = 0;
            }
            if (message.cyan != null && message.hasOwnProperty("cyan"))
                object.cyan = options.json && !isFinite(message.cyan) ? String(message.cyan) : message.cyan;
            if (message.magenta != null && message.hasOwnProperty("magenta"))
                object.magenta = options.json && !isFinite(message.magenta) ? String(message.magenta) : message.magenta;
            if (message.yellow != null && message.hasOwnProperty("yellow"))
                object.yellow = options.json && !isFinite(message.yellow) ? String(message.yellow) : message.yellow;
            if (message.key != null && message.hasOwnProperty("key"))
                object.key = options.json && !isFinite(message.key) ? String(message.key) : message.key;
            return object;
        };

        /**
         * Converts this ColorCMYK to JSON.
         * @function toJSON
         * @memberof osi3.ColorCMYK
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ColorCMYK.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ColorCMYK
         * @function getTypeUrl
         * @memberof osi3.ColorCMYK
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ColorCMYK.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/osi3.ColorCMYK";
        };

        return ColorCMYK;
    })();

    osi3.Pedalry = (function() {

        /**
         * Properties of a Pedalry.
         * @memberof osi3
         * @interface IPedalry
         * @property {number|null} [pedalPositionAcceleration] Pedalry pedalPositionAcceleration
         * @property {number|null} [pedalPositionBrake] Pedalry pedalPositionBrake
         * @property {number|null} [pedalPositionClutch] Pedalry pedalPositionClutch
         */

        /**
         * Constructs a new Pedalry.
         * @memberof osi3
         * @classdesc Represents a Pedalry.
         * @implements IPedalry
         * @constructor
         * @param {osi3.IPedalry=} [properties] Properties to set
         */
        function Pedalry(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Pedalry pedalPositionAcceleration.
         * @member {number} pedalPositionAcceleration
         * @memberof osi3.Pedalry
         * @instance
         */
        Pedalry.prototype.pedalPositionAcceleration = 0;

        /**
         * Pedalry pedalPositionBrake.
         * @member {number} pedalPositionBrake
         * @memberof osi3.Pedalry
         * @instance
         */
        Pedalry.prototype.pedalPositionBrake = 0;

        /**
         * Pedalry pedalPositionClutch.
         * @member {number} pedalPositionClutch
         * @memberof osi3.Pedalry
         * @instance
         */
        Pedalry.prototype.pedalPositionClutch = 0;

        /**
         * Creates a new Pedalry instance using the specified properties.
         * @function create
         * @memberof osi3.Pedalry
         * @static
         * @param {osi3.IPedalry=} [properties] Properties to set
         * @returns {osi3.Pedalry} Pedalry instance
         */
        Pedalry.create = function create(properties) {
            return new Pedalry(properties);
        };

        /**
         * Encodes the specified Pedalry message. Does not implicitly {@link osi3.Pedalry.verify|verify} messages.
         * @function encode
         * @memberof osi3.Pedalry
         * @static
         * @param {osi3.IPedalry} message Pedalry message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Pedalry.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.pedalPositionAcceleration != null && Object.hasOwnProperty.call(message, "pedalPositionAcceleration"))
                writer.uint32(/* id 1, wireType 1 =*/9).double(message.pedalPositionAcceleration);
            if (message.pedalPositionBrake != null && Object.hasOwnProperty.call(message, "pedalPositionBrake"))
                writer.uint32(/* id 2, wireType 1 =*/17).double(message.pedalPositionBrake);
            if (message.pedalPositionClutch != null && Object.hasOwnProperty.call(message, "pedalPositionClutch"))
                writer.uint32(/* id 3, wireType 1 =*/25).double(message.pedalPositionClutch);
            return writer;
        };

        /**
         * Encodes the specified Pedalry message, length delimited. Does not implicitly {@link osi3.Pedalry.verify|verify} messages.
         * @function encodeDelimited
         * @memberof osi3.Pedalry
         * @static
         * @param {osi3.IPedalry} message Pedalry message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Pedalry.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Pedalry message from the specified reader or buffer.
         * @function decode
         * @memberof osi3.Pedalry
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {osi3.Pedalry} Pedalry
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Pedalry.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.osi3.Pedalry();
            while (reader.pos < end) {
                let tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.pedalPositionAcceleration = reader.double();
                        break;
                    }
                case 2: {
                        message.pedalPositionBrake = reader.double();
                        break;
                    }
                case 3: {
                        message.pedalPositionClutch = reader.double();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Pedalry message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof osi3.Pedalry
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {osi3.Pedalry} Pedalry
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Pedalry.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Pedalry message.
         * @function verify
         * @memberof osi3.Pedalry
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Pedalry.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.pedalPositionAcceleration != null && message.hasOwnProperty("pedalPositionAcceleration"))
                if (typeof message.pedalPositionAcceleration !== "number")
                    return "pedalPositionAcceleration: number expected";
            if (message.pedalPositionBrake != null && message.hasOwnProperty("pedalPositionBrake"))
                if (typeof message.pedalPositionBrake !== "number")
                    return "pedalPositionBrake: number expected";
            if (message.pedalPositionClutch != null && message.hasOwnProperty("pedalPositionClutch"))
                if (typeof message.pedalPositionClutch !== "number")
                    return "pedalPositionClutch: number expected";
            return null;
        };

        /**
         * Creates a Pedalry message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof osi3.Pedalry
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {osi3.Pedalry} Pedalry
         */
        Pedalry.fromObject = function fromObject(object) {
            if (object instanceof $root.osi3.Pedalry)
                return object;
            let message = new $root.osi3.Pedalry();
            if (object.pedalPositionAcceleration != null)
                message.pedalPositionAcceleration = Number(object.pedalPositionAcceleration);
            if (object.pedalPositionBrake != null)
                message.pedalPositionBrake = Number(object.pedalPositionBrake);
            if (object.pedalPositionClutch != null)
                message.pedalPositionClutch = Number(object.pedalPositionClutch);
            return message;
        };

        /**
         * Creates a plain object from a Pedalry message. Also converts values to other types if specified.
         * @function toObject
         * @memberof osi3.Pedalry
         * @static
         * @param {osi3.Pedalry} message Pedalry
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Pedalry.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.pedalPositionAcceleration = 0;
                object.pedalPositionBrake = 0;
                object.pedalPositionClutch = 0;
            }
            if (message.pedalPositionAcceleration != null && message.hasOwnProperty("pedalPositionAcceleration"))
                object.pedalPositionAcceleration = options.json && !isFinite(message.pedalPositionAcceleration) ? String(message.pedalPositionAcceleration) : message.pedalPositionAcceleration;
            if (message.pedalPositionBrake != null && message.hasOwnProperty("pedalPositionBrake"))
                object.pedalPositionBrake = options.json && !isFinite(message.pedalPositionBrake) ? String(message.pedalPositionBrake) : message.pedalPositionBrake;
            if (message.pedalPositionClutch != null && message.hasOwnProperty("pedalPositionClutch"))
                object.pedalPositionClutch = options.json && !isFinite(message.pedalPositionClutch) ? String(message.pedalPositionClutch) : message.pedalPositionClutch;
            return object;
        };

        /**
         * Converts this Pedalry to JSON.
         * @function toJSON
         * @memberof osi3.Pedalry
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Pedalry.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Pedalry
         * @function getTypeUrl
         * @memberof osi3.Pedalry
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Pedalry.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/osi3.Pedalry";
        };

        return Pedalry;
    })();

    osi3.VehicleSteeringWheel = (function() {

        /**
         * Properties of a VehicleSteeringWheel.
         * @memberof osi3
         * @interface IVehicleSteeringWheel
         * @property {number|null} [angle] VehicleSteeringWheel angle
         * @property {number|null} [angularSpeed] VehicleSteeringWheel angularSpeed
         * @property {number|null} [torque] VehicleSteeringWheel torque
         */

        /**
         * Constructs a new VehicleSteeringWheel.
         * @memberof osi3
         * @classdesc Represents a VehicleSteeringWheel.
         * @implements IVehicleSteeringWheel
         * @constructor
         * @param {osi3.IVehicleSteeringWheel=} [properties] Properties to set
         */
        function VehicleSteeringWheel(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * VehicleSteeringWheel angle.
         * @member {number} angle
         * @memberof osi3.VehicleSteeringWheel
         * @instance
         */
        VehicleSteeringWheel.prototype.angle = 0;

        /**
         * VehicleSteeringWheel angularSpeed.
         * @member {number} angularSpeed
         * @memberof osi3.VehicleSteeringWheel
         * @instance
         */
        VehicleSteeringWheel.prototype.angularSpeed = 0;

        /**
         * VehicleSteeringWheel torque.
         * @member {number} torque
         * @memberof osi3.VehicleSteeringWheel
         * @instance
         */
        VehicleSteeringWheel.prototype.torque = 0;

        /**
         * Creates a new VehicleSteeringWheel instance using the specified properties.
         * @function create
         * @memberof osi3.VehicleSteeringWheel
         * @static
         * @param {osi3.IVehicleSteeringWheel=} [properties] Properties to set
         * @returns {osi3.VehicleSteeringWheel} VehicleSteeringWheel instance
         */
        VehicleSteeringWheel.create = function create(properties) {
            return new VehicleSteeringWheel(properties);
        };

        /**
         * Encodes the specified VehicleSteeringWheel message. Does not implicitly {@link osi3.VehicleSteeringWheel.verify|verify} messages.
         * @function encode
         * @memberof osi3.VehicleSteeringWheel
         * @static
         * @param {osi3.IVehicleSteeringWheel} message VehicleSteeringWheel message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VehicleSteeringWheel.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.angle != null && Object.hasOwnProperty.call(message, "angle"))
                writer.uint32(/* id 1, wireType 1 =*/9).double(message.angle);
            if (message.angularSpeed != null && Object.hasOwnProperty.call(message, "angularSpeed"))
                writer.uint32(/* id 2, wireType 1 =*/17).double(message.angularSpeed);
            if (message.torque != null && Object.hasOwnProperty.call(message, "torque"))
                writer.uint32(/* id 3, wireType 1 =*/25).double(message.torque);
            return writer;
        };

        /**
         * Encodes the specified VehicleSteeringWheel message, length delimited. Does not implicitly {@link osi3.VehicleSteeringWheel.verify|verify} messages.
         * @function encodeDelimited
         * @memberof osi3.VehicleSteeringWheel
         * @static
         * @param {osi3.IVehicleSteeringWheel} message VehicleSteeringWheel message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VehicleSteeringWheel.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a VehicleSteeringWheel message from the specified reader or buffer.
         * @function decode
         * @memberof osi3.VehicleSteeringWheel
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {osi3.VehicleSteeringWheel} VehicleSteeringWheel
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VehicleSteeringWheel.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.osi3.VehicleSteeringWheel();
            while (reader.pos < end) {
                let tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.angle = reader.double();
                        break;
                    }
                case 2: {
                        message.angularSpeed = reader.double();
                        break;
                    }
                case 3: {
                        message.torque = reader.double();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a VehicleSteeringWheel message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof osi3.VehicleSteeringWheel
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {osi3.VehicleSteeringWheel} VehicleSteeringWheel
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VehicleSteeringWheel.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a VehicleSteeringWheel message.
         * @function verify
         * @memberof osi3.VehicleSteeringWheel
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        VehicleSteeringWheel.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.angle != null && message.hasOwnProperty("angle"))
                if (typeof message.angle !== "number")
                    return "angle: number expected";
            if (message.angularSpeed != null && message.hasOwnProperty("angularSpeed"))
                if (typeof message.angularSpeed !== "number")
                    return "angularSpeed: number expected";
            if (message.torque != null && message.hasOwnProperty("torque"))
                if (typeof message.torque !== "number")
                    return "torque: number expected";
            return null;
        };

        /**
         * Creates a VehicleSteeringWheel message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof osi3.VehicleSteeringWheel
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {osi3.VehicleSteeringWheel} VehicleSteeringWheel
         */
        VehicleSteeringWheel.fromObject = function fromObject(object) {
            if (object instanceof $root.osi3.VehicleSteeringWheel)
                return object;
            let message = new $root.osi3.VehicleSteeringWheel();
            if (object.angle != null)
                message.angle = Number(object.angle);
            if (object.angularSpeed != null)
                message.angularSpeed = Number(object.angularSpeed);
            if (object.torque != null)
                message.torque = Number(object.torque);
            return message;
        };

        /**
         * Creates a plain object from a VehicleSteeringWheel message. Also converts values to other types if specified.
         * @function toObject
         * @memberof osi3.VehicleSteeringWheel
         * @static
         * @param {osi3.VehicleSteeringWheel} message VehicleSteeringWheel
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        VehicleSteeringWheel.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.angle = 0;
                object.angularSpeed = 0;
                object.torque = 0;
            }
            if (message.angle != null && message.hasOwnProperty("angle"))
                object.angle = options.json && !isFinite(message.angle) ? String(message.angle) : message.angle;
            if (message.angularSpeed != null && message.hasOwnProperty("angularSpeed"))
                object.angularSpeed = options.json && !isFinite(message.angularSpeed) ? String(message.angularSpeed) : message.angularSpeed;
            if (message.torque != null && message.hasOwnProperty("torque"))
                object.torque = options.json && !isFinite(message.torque) ? String(message.torque) : message.torque;
            return object;
        };

        /**
         * Converts this VehicleSteeringWheel to JSON.
         * @function toJSON
         * @memberof osi3.VehicleSteeringWheel
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        VehicleSteeringWheel.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for VehicleSteeringWheel
         * @function getTypeUrl
         * @memberof osi3.VehicleSteeringWheel
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        VehicleSteeringWheel.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/osi3.VehicleSteeringWheel";
        };

        return VehicleSteeringWheel;
    })();

    osi3.GeodeticPosition = (function() {

        /**
         * Properties of a GeodeticPosition.
         * @memberof osi3
         * @interface IGeodeticPosition
         * @property {number|null} [longitude] GeodeticPosition longitude
         * @property {number|null} [latitude] GeodeticPosition latitude
         * @property {number|null} [altitude] GeodeticPosition altitude
         */

        /**
         * Constructs a new GeodeticPosition.
         * @memberof osi3
         * @classdesc Represents a GeodeticPosition.
         * @implements IGeodeticPosition
         * @constructor
         * @param {osi3.IGeodeticPosition=} [properties] Properties to set
         */
        function GeodeticPosition(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GeodeticPosition longitude.
         * @member {number} longitude
         * @memberof osi3.GeodeticPosition
         * @instance
         */
        GeodeticPosition.prototype.longitude = 0;

        /**
         * GeodeticPosition latitude.
         * @member {number} latitude
         * @memberof osi3.GeodeticPosition
         * @instance
         */
        GeodeticPosition.prototype.latitude = 0;

        /**
         * GeodeticPosition altitude.
         * @member {number} altitude
         * @memberof osi3.GeodeticPosition
         * @instance
         */
        GeodeticPosition.prototype.altitude = 0;

        /**
         * Creates a new GeodeticPosition instance using the specified properties.
         * @function create
         * @memberof osi3.GeodeticPosition
         * @static
         * @param {osi3.IGeodeticPosition=} [properties] Properties to set
         * @returns {osi3.GeodeticPosition} GeodeticPosition instance
         */
        GeodeticPosition.create = function create(properties) {
            return new GeodeticPosition(properties);
        };

        /**
         * Encodes the specified GeodeticPosition message. Does not implicitly {@link osi3.GeodeticPosition.verify|verify} messages.
         * @function encode
         * @memberof osi3.GeodeticPosition
         * @static
         * @param {osi3.IGeodeticPosition} message GeodeticPosition message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GeodeticPosition.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.longitude != null && Object.hasOwnProperty.call(message, "longitude"))
                writer.uint32(/* id 1, wireType 1 =*/9).double(message.longitude);
            if (message.latitude != null && Object.hasOwnProperty.call(message, "latitude"))
                writer.uint32(/* id 2, wireType 1 =*/17).double(message.latitude);
            if (message.altitude != null && Object.hasOwnProperty.call(message, "altitude"))
                writer.uint32(/* id 3, wireType 1 =*/25).double(message.altitude);
            return writer;
        };

        /**
         * Encodes the specified GeodeticPosition message, length delimited. Does not implicitly {@link osi3.GeodeticPosition.verify|verify} messages.
         * @function encodeDelimited
         * @memberof osi3.GeodeticPosition
         * @static
         * @param {osi3.IGeodeticPosition} message GeodeticPosition message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GeodeticPosition.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GeodeticPosition message from the specified reader or buffer.
         * @function decode
         * @memberof osi3.GeodeticPosition
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {osi3.GeodeticPosition} GeodeticPosition
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GeodeticPosition.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.osi3.GeodeticPosition();
            while (reader.pos < end) {
                let tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.longitude = reader.double();
                        break;
                    }
                case 2: {
                        message.latitude = reader.double();
                        break;
                    }
                case 3: {
                        message.altitude = reader.double();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GeodeticPosition message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof osi3.GeodeticPosition
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {osi3.GeodeticPosition} GeodeticPosition
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GeodeticPosition.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GeodeticPosition message.
         * @function verify
         * @memberof osi3.GeodeticPosition
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GeodeticPosition.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.longitude != null && message.hasOwnProperty("longitude"))
                if (typeof message.longitude !== "number")
                    return "longitude: number expected";
            if (message.latitude != null && message.hasOwnProperty("latitude"))
                if (typeof message.latitude !== "number")
                    return "latitude: number expected";
            if (message.altitude != null && message.hasOwnProperty("altitude"))
                if (typeof message.altitude !== "number")
                    return "altitude: number expected";
            return null;
        };

        /**
         * Creates a GeodeticPosition message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof osi3.GeodeticPosition
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {osi3.GeodeticPosition} GeodeticPosition
         */
        GeodeticPosition.fromObject = function fromObject(object) {
            if (object instanceof $root.osi3.GeodeticPosition)
                return object;
            let message = new $root.osi3.GeodeticPosition();
            if (object.longitude != null)
                message.longitude = Number(object.longitude);
            if (object.latitude != null)
                message.latitude = Number(object.latitude);
            if (object.altitude != null)
                message.altitude = Number(object.altitude);
            return message;
        };

        /**
         * Creates a plain object from a GeodeticPosition message. Also converts values to other types if specified.
         * @function toObject
         * @memberof osi3.GeodeticPosition
         * @static
         * @param {osi3.GeodeticPosition} message GeodeticPosition
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GeodeticPosition.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.longitude = 0;
                object.latitude = 0;
                object.altitude = 0;
            }
            if (message.longitude != null && message.hasOwnProperty("longitude"))
                object.longitude = options.json && !isFinite(message.longitude) ? String(message.longitude) : message.longitude;
            if (message.latitude != null && message.hasOwnProperty("latitude"))
                object.latitude = options.json && !isFinite(message.latitude) ? String(message.latitude) : message.latitude;
            if (message.altitude != null && message.hasOwnProperty("altitude"))
                object.altitude = options.json && !isFinite(message.altitude) ? String(message.altitude) : message.altitude;
            return object;
        };

        /**
         * Converts this GeodeticPosition to JSON.
         * @function toJSON
         * @memberof osi3.GeodeticPosition
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GeodeticPosition.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for GeodeticPosition
         * @function getTypeUrl
         * @memberof osi3.GeodeticPosition
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        GeodeticPosition.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/osi3.GeodeticPosition";
        };

        return GeodeticPosition;
    })();

    osi3.KeyValuePair = (function() {

        /**
         * Properties of a KeyValuePair.
         * @memberof osi3
         * @interface IKeyValuePair
         * @property {string|null} [key] KeyValuePair key
         * @property {string|null} [value] KeyValuePair value
         */

        /**
         * Constructs a new KeyValuePair.
         * @memberof osi3
         * @classdesc Represents a KeyValuePair.
         * @implements IKeyValuePair
         * @constructor
         * @param {osi3.IKeyValuePair=} [properties] Properties to set
         */
        function KeyValuePair(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * KeyValuePair key.
         * @member {string} key
         * @memberof osi3.KeyValuePair
         * @instance
         */
        KeyValuePair.prototype.key = "";

        /**
         * KeyValuePair value.
         * @member {string} value
         * @memberof osi3.KeyValuePair
         * @instance
         */
        KeyValuePair.prototype.value = "";

        /**
         * Creates a new KeyValuePair instance using the specified properties.
         * @function create
         * @memberof osi3.KeyValuePair
         * @static
         * @param {osi3.IKeyValuePair=} [properties] Properties to set
         * @returns {osi3.KeyValuePair} KeyValuePair instance
         */
        KeyValuePair.create = function create(properties) {
            return new KeyValuePair(properties);
        };

        /**
         * Encodes the specified KeyValuePair message. Does not implicitly {@link osi3.KeyValuePair.verify|verify} messages.
         * @function encode
         * @memberof osi3.KeyValuePair
         * @static
         * @param {osi3.IKeyValuePair} message KeyValuePair message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        KeyValuePair.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.key);
            if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.value);
            return writer;
        };

        /**
         * Encodes the specified KeyValuePair message, length delimited. Does not implicitly {@link osi3.KeyValuePair.verify|verify} messages.
         * @function encodeDelimited
         * @memberof osi3.KeyValuePair
         * @static
         * @param {osi3.IKeyValuePair} message KeyValuePair message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        KeyValuePair.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a KeyValuePair message from the specified reader or buffer.
         * @function decode
         * @memberof osi3.KeyValuePair
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {osi3.KeyValuePair} KeyValuePair
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        KeyValuePair.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.osi3.KeyValuePair();
            while (reader.pos < end) {
                let tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.key = reader.string();
                        break;
                    }
                case 2: {
                        message.value = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a KeyValuePair message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof osi3.KeyValuePair
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {osi3.KeyValuePair} KeyValuePair
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        KeyValuePair.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a KeyValuePair message.
         * @function verify
         * @memberof osi3.KeyValuePair
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        KeyValuePair.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.key != null && message.hasOwnProperty("key"))
                if (!$util.isString(message.key))
                    return "key: string expected";
            if (message.value != null && message.hasOwnProperty("value"))
                if (!$util.isString(message.value))
                    return "value: string expected";
            return null;
        };

        /**
         * Creates a KeyValuePair message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof osi3.KeyValuePair
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {osi3.KeyValuePair} KeyValuePair
         */
        KeyValuePair.fromObject = function fromObject(object) {
            if (object instanceof $root.osi3.KeyValuePair)
                return object;
            let message = new $root.osi3.KeyValuePair();
            if (object.key != null)
                message.key = String(object.key);
            if (object.value != null)
                message.value = String(object.value);
            return message;
        };

        /**
         * Creates a plain object from a KeyValuePair message. Also converts values to other types if specified.
         * @function toObject
         * @memberof osi3.KeyValuePair
         * @static
         * @param {osi3.KeyValuePair} message KeyValuePair
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        KeyValuePair.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.key = "";
                object.value = "";
            }
            if (message.key != null && message.hasOwnProperty("key"))
                object.key = message.key;
            if (message.value != null && message.hasOwnProperty("value"))
                object.value = message.value;
            return object;
        };

        /**
         * Converts this KeyValuePair to JSON.
         * @function toJSON
         * @memberof osi3.KeyValuePair
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        KeyValuePair.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for KeyValuePair
         * @function getTypeUrl
         * @memberof osi3.KeyValuePair
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        KeyValuePair.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/osi3.KeyValuePair";
        };

        return KeyValuePair;
    })();

    osi3.Polygon3d = (function() {

        /**
         * Properties of a Polygon3d.
         * @memberof osi3
         * @interface IPolygon3d
         * @property {Array.<osi3.IVector3d>|null} [vertex] Polygon3d vertex
         */

        /**
         * Constructs a new Polygon3d.
         * @memberof osi3
         * @classdesc Represents a Polygon3d.
         * @implements IPolygon3d
         * @constructor
         * @param {osi3.IPolygon3d=} [properties] Properties to set
         */
        function Polygon3d(properties) {
            this.vertex = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Polygon3d vertex.
         * @member {Array.<osi3.IVector3d>} vertex
         * @memberof osi3.Polygon3d
         * @instance
         */
        Polygon3d.prototype.vertex = $util.emptyArray;

        /**
         * Creates a new Polygon3d instance using the specified properties.
         * @function create
         * @memberof osi3.Polygon3d
         * @static
         * @param {osi3.IPolygon3d=} [properties] Properties to set
         * @returns {osi3.Polygon3d} Polygon3d instance
         */
        Polygon3d.create = function create(properties) {
            return new Polygon3d(properties);
        };

        /**
         * Encodes the specified Polygon3d message. Does not implicitly {@link osi3.Polygon3d.verify|verify} messages.
         * @function encode
         * @memberof osi3.Polygon3d
         * @static
         * @param {osi3.IPolygon3d} message Polygon3d message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Polygon3d.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.vertex != null && message.vertex.length)
                for (let i = 0; i < message.vertex.length; ++i)
                    $root.osi3.Vector3d.encode(message.vertex[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Polygon3d message, length delimited. Does not implicitly {@link osi3.Polygon3d.verify|verify} messages.
         * @function encodeDelimited
         * @memberof osi3.Polygon3d
         * @static
         * @param {osi3.IPolygon3d} message Polygon3d message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Polygon3d.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Polygon3d message from the specified reader or buffer.
         * @function decode
         * @memberof osi3.Polygon3d
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {osi3.Polygon3d} Polygon3d
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Polygon3d.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.osi3.Polygon3d();
            while (reader.pos < end) {
                let tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.vertex && message.vertex.length))
                            message.vertex = [];
                        message.vertex.push($root.osi3.Vector3d.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Polygon3d message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof osi3.Polygon3d
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {osi3.Polygon3d} Polygon3d
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Polygon3d.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Polygon3d message.
         * @function verify
         * @memberof osi3.Polygon3d
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Polygon3d.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.vertex != null && message.hasOwnProperty("vertex")) {
                if (!Array.isArray(message.vertex))
                    return "vertex: array expected";
                for (let i = 0; i < message.vertex.length; ++i) {
                    let error = $root.osi3.Vector3d.verify(message.vertex[i]);
                    if (error)
                        return "vertex." + error;
                }
            }
            return null;
        };

        /**
         * Creates a Polygon3d message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof osi3.Polygon3d
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {osi3.Polygon3d} Polygon3d
         */
        Polygon3d.fromObject = function fromObject(object) {
            if (object instanceof $root.osi3.Polygon3d)
                return object;
            let message = new $root.osi3.Polygon3d();
            if (object.vertex) {
                if (!Array.isArray(object.vertex))
                    throw TypeError(".osi3.Polygon3d.vertex: array expected");
                message.vertex = [];
                for (let i = 0; i < object.vertex.length; ++i) {
                    if (typeof object.vertex[i] !== "object")
                        throw TypeError(".osi3.Polygon3d.vertex: object expected");
                    message.vertex[i] = $root.osi3.Vector3d.fromObject(object.vertex[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a Polygon3d message. Also converts values to other types if specified.
         * @function toObject
         * @memberof osi3.Polygon3d
         * @static
         * @param {osi3.Polygon3d} message Polygon3d
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Polygon3d.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.vertex = [];
            if (message.vertex && message.vertex.length) {
                object.vertex = [];
                for (let j = 0; j < message.vertex.length; ++j)
                    object.vertex[j] = $root.osi3.Vector3d.toObject(message.vertex[j], options);
            }
            return object;
        };

        /**
         * Converts this Polygon3d to JSON.
         * @function toJSON
         * @memberof osi3.Polygon3d
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Polygon3d.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Polygon3d
         * @function getTypeUrl
         * @memberof osi3.Polygon3d
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Polygon3d.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/osi3.Polygon3d";
        };

        return Polygon3d;
    })();

    osi3.EnvironmentalConditions = (function() {

        /**
         * Properties of an EnvironmentalConditions.
         * @memberof osi3
         * @interface IEnvironmentalConditions
         * @property {osi3.EnvironmentalConditions.AmbientIllumination|null} [ambientIllumination] EnvironmentalConditions ambientIllumination
         * @property {osi3.EnvironmentalConditions.ITimeOfDay|null} [timeOfDay] EnvironmentalConditions timeOfDay
         * @property {number|Long|null} [unixTimestamp] EnvironmentalConditions unixTimestamp
         * @property {number|null} [atmosphericPressure] EnvironmentalConditions atmosphericPressure
         * @property {number|null} [temperature] EnvironmentalConditions temperature
         * @property {number|null} [relativeHumidity] EnvironmentalConditions relativeHumidity
         * @property {osi3.EnvironmentalConditions.Precipitation|null} [precipitation] EnvironmentalConditions precipitation
         * @property {osi3.EnvironmentalConditions.Fog|null} [fog] EnvironmentalConditions fog
         * @property {Array.<osi3.IExternalReference>|null} [sourceReference] EnvironmentalConditions sourceReference
         * @property {osi3.EnvironmentalConditions.ICloudLayer|null} [clouds] EnvironmentalConditions clouds
         * @property {osi3.EnvironmentalConditions.IWind|null} [wind] EnvironmentalConditions wind
         * @property {osi3.EnvironmentalConditions.ISun|null} [sun] EnvironmentalConditions sun
         */

        /**
         * Constructs a new EnvironmentalConditions.
         * @memberof osi3
         * @classdesc Represents an EnvironmentalConditions.
         * @implements IEnvironmentalConditions
         * @constructor
         * @param {osi3.IEnvironmentalConditions=} [properties] Properties to set
         */
        function EnvironmentalConditions(properties) {
            this.sourceReference = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * EnvironmentalConditions ambientIllumination.
         * @member {osi3.EnvironmentalConditions.AmbientIllumination} ambientIllumination
         * @memberof osi3.EnvironmentalConditions
         * @instance
         */
        EnvironmentalConditions.prototype.ambientIllumination = 0;

        /**
         * EnvironmentalConditions timeOfDay.
         * @member {osi3.EnvironmentalConditions.ITimeOfDay|null|undefined} timeOfDay
         * @memberof osi3.EnvironmentalConditions
         * @instance
         */
        EnvironmentalConditions.prototype.timeOfDay = null;

        /**
         * EnvironmentalConditions unixTimestamp.
         * @member {number|Long} unixTimestamp
         * @memberof osi3.EnvironmentalConditions
         * @instance
         */
        EnvironmentalConditions.prototype.unixTimestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * EnvironmentalConditions atmosphericPressure.
         * @member {number} atmosphericPressure
         * @memberof osi3.EnvironmentalConditions
         * @instance
         */
        EnvironmentalConditions.prototype.atmosphericPressure = 0;

        /**
         * EnvironmentalConditions temperature.
         * @member {number} temperature
         * @memberof osi3.EnvironmentalConditions
         * @instance
         */
        EnvironmentalConditions.prototype.temperature = 0;

        /**
         * EnvironmentalConditions relativeHumidity.
         * @member {number} relativeHumidity
         * @memberof osi3.EnvironmentalConditions
         * @instance
         */
        EnvironmentalConditions.prototype.relativeHumidity = 0;

        /**
         * EnvironmentalConditions precipitation.
         * @member {osi3.EnvironmentalConditions.Precipitation} precipitation
         * @memberof osi3.EnvironmentalConditions
         * @instance
         */
        EnvironmentalConditions.prototype.precipitation = 0;

        /**
         * EnvironmentalConditions fog.
         * @member {osi3.EnvironmentalConditions.Fog} fog
         * @memberof osi3.EnvironmentalConditions
         * @instance
         */
        EnvironmentalConditions.prototype.fog = 0;

        /**
         * EnvironmentalConditions sourceReference.
         * @member {Array.<osi3.IExternalReference>} sourceReference
         * @memberof osi3.EnvironmentalConditions
         * @instance
         */
        EnvironmentalConditions.prototype.sourceReference = $util.emptyArray;

        /**
         * EnvironmentalConditions clouds.
         * @member {osi3.EnvironmentalConditions.ICloudLayer|null|undefined} clouds
         * @memberof osi3.EnvironmentalConditions
         * @instance
         */
        EnvironmentalConditions.prototype.clouds = null;

        /**
         * EnvironmentalConditions wind.
         * @member {osi3.EnvironmentalConditions.IWind|null|undefined} wind
         * @memberof osi3.EnvironmentalConditions
         * @instance
         */
        EnvironmentalConditions.prototype.wind = null;

        /**
         * EnvironmentalConditions sun.
         * @member {osi3.EnvironmentalConditions.ISun|null|undefined} sun
         * @memberof osi3.EnvironmentalConditions
         * @instance
         */
        EnvironmentalConditions.prototype.sun = null;

        /**
         * Creates a new EnvironmentalConditions instance using the specified properties.
         * @function create
         * @memberof osi3.EnvironmentalConditions
         * @static
         * @param {osi3.IEnvironmentalConditions=} [properties] Properties to set
         * @returns {osi3.EnvironmentalConditions} EnvironmentalConditions instance
         */
        EnvironmentalConditions.create = function create(properties) {
            return new EnvironmentalConditions(properties);
        };

        /**
         * Encodes the specified EnvironmentalConditions message. Does not implicitly {@link osi3.EnvironmentalConditions.verify|verify} messages.
         * @function encode
         * @memberof osi3.EnvironmentalConditions
         * @static
         * @param {osi3.IEnvironmentalConditions} message EnvironmentalConditions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EnvironmentalConditions.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ambientIllumination != null && Object.hasOwnProperty.call(message, "ambientIllumination"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.ambientIllumination);
            if (message.timeOfDay != null && Object.hasOwnProperty.call(message, "timeOfDay"))
                $root.osi3.EnvironmentalConditions.TimeOfDay.encode(message.timeOfDay, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.atmosphericPressure != null && Object.hasOwnProperty.call(message, "atmosphericPressure"))
                writer.uint32(/* id 3, wireType 1 =*/25).double(message.atmosphericPressure);
            if (message.temperature != null && Object.hasOwnProperty.call(message, "temperature"))
                writer.uint32(/* id 4, wireType 1 =*/33).double(message.temperature);
            if (message.relativeHumidity != null && Object.hasOwnProperty.call(message, "relativeHumidity"))
                writer.uint32(/* id 5, wireType 1 =*/41).double(message.relativeHumidity);
            if (message.precipitation != null && Object.hasOwnProperty.call(message, "precipitation"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.precipitation);
            if (message.fog != null && Object.hasOwnProperty.call(message, "fog"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.fog);
            if (message.unixTimestamp != null && Object.hasOwnProperty.call(message, "unixTimestamp"))
                writer.uint32(/* id 8, wireType 0 =*/64).int64(message.unixTimestamp);
            if (message.sourceReference != null && message.sourceReference.length)
                for (let i = 0; i < message.sourceReference.length; ++i)
                    $root.osi3.ExternalReference.encode(message.sourceReference[i], writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            if (message.clouds != null && Object.hasOwnProperty.call(message, "clouds"))
                $root.osi3.EnvironmentalConditions.CloudLayer.encode(message.clouds, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            if (message.wind != null && Object.hasOwnProperty.call(message, "wind"))
                $root.osi3.EnvironmentalConditions.Wind.encode(message.wind, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
            if (message.sun != null && Object.hasOwnProperty.call(message, "sun"))
                $root.osi3.EnvironmentalConditions.Sun.encode(message.sun, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified EnvironmentalConditions message, length delimited. Does not implicitly {@link osi3.EnvironmentalConditions.verify|verify} messages.
         * @function encodeDelimited
         * @memberof osi3.EnvironmentalConditions
         * @static
         * @param {osi3.IEnvironmentalConditions} message EnvironmentalConditions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EnvironmentalConditions.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an EnvironmentalConditions message from the specified reader or buffer.
         * @function decode
         * @memberof osi3.EnvironmentalConditions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {osi3.EnvironmentalConditions} EnvironmentalConditions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EnvironmentalConditions.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.osi3.EnvironmentalConditions();
            while (reader.pos < end) {
                let tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.ambientIllumination = reader.int32();
                        break;
                    }
                case 2: {
                        message.timeOfDay = $root.osi3.EnvironmentalConditions.TimeOfDay.decode(reader, reader.uint32());
                        break;
                    }
                case 8: {
                        message.unixTimestamp = reader.int64();
                        break;
                    }
                case 3: {
                        message.atmosphericPressure = reader.double();
                        break;
                    }
                case 4: {
                        message.temperature = reader.double();
                        break;
                    }
                case 5: {
                        message.relativeHumidity = reader.double();
                        break;
                    }
                case 6: {
                        message.precipitation = reader.int32();
                        break;
                    }
                case 7: {
                        message.fog = reader.int32();
                        break;
                    }
                case 9: {
                        if (!(message.sourceReference && message.sourceReference.length))
                            message.sourceReference = [];
                        message.sourceReference.push($root.osi3.ExternalReference.decode(reader, reader.uint32()));
                        break;
                    }
                case 10: {
                        message.clouds = $root.osi3.EnvironmentalConditions.CloudLayer.decode(reader, reader.uint32());
                        break;
                    }
                case 11: {
                        message.wind = $root.osi3.EnvironmentalConditions.Wind.decode(reader, reader.uint32());
                        break;
                    }
                case 12: {
                        message.sun = $root.osi3.EnvironmentalConditions.Sun.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an EnvironmentalConditions message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof osi3.EnvironmentalConditions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {osi3.EnvironmentalConditions} EnvironmentalConditions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EnvironmentalConditions.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an EnvironmentalConditions message.
         * @function verify
         * @memberof osi3.EnvironmentalConditions
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EnvironmentalConditions.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ambientIllumination != null && message.hasOwnProperty("ambientIllumination"))
                switch (message.ambientIllumination) {
                default:
                    return "ambientIllumination: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                    break;
                }
            if (message.timeOfDay != null && message.hasOwnProperty("timeOfDay")) {
                let error = $root.osi3.EnvironmentalConditions.TimeOfDay.verify(message.timeOfDay);
                if (error)
                    return "timeOfDay." + error;
            }
            if (message.unixTimestamp != null && message.hasOwnProperty("unixTimestamp"))
                if (!$util.isInteger(message.unixTimestamp) && !(message.unixTimestamp && $util.isInteger(message.unixTimestamp.low) && $util.isInteger(message.unixTimestamp.high)))
                    return "unixTimestamp: integer|Long expected";
            if (message.atmosphericPressure != null && message.hasOwnProperty("atmosphericPressure"))
                if (typeof message.atmosphericPressure !== "number")
                    return "atmosphericPressure: number expected";
            if (message.temperature != null && message.hasOwnProperty("temperature"))
                if (typeof message.temperature !== "number")
                    return "temperature: number expected";
            if (message.relativeHumidity != null && message.hasOwnProperty("relativeHumidity"))
                if (typeof message.relativeHumidity !== "number")
                    return "relativeHumidity: number expected";
            if (message.precipitation != null && message.hasOwnProperty("precipitation"))
                switch (message.precipitation) {
                default:
                    return "precipitation: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                    break;
                }
            if (message.fog != null && message.hasOwnProperty("fog"))
                switch (message.fog) {
                default:
                    return "fog: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                    break;
                }
            if (message.sourceReference != null && message.hasOwnProperty("sourceReference")) {
                if (!Array.isArray(message.sourceReference))
                    return "sourceReference: array expected";
                for (let i = 0; i < message.sourceReference.length; ++i) {
                    let error = $root.osi3.ExternalReference.verify(message.sourceReference[i]);
                    if (error)
                        return "sourceReference." + error;
                }
            }
            if (message.clouds != null && message.hasOwnProperty("clouds")) {
                let error = $root.osi3.EnvironmentalConditions.CloudLayer.verify(message.clouds);
                if (error)
                    return "clouds." + error;
            }
            if (message.wind != null && message.hasOwnProperty("wind")) {
                let error = $root.osi3.EnvironmentalConditions.Wind.verify(message.wind);
                if (error)
                    return "wind." + error;
            }
            if (message.sun != null && message.hasOwnProperty("sun")) {
                let error = $root.osi3.EnvironmentalConditions.Sun.verify(message.sun);
                if (error)
                    return "sun." + error;
            }
            return null;
        };

        /**
         * Creates an EnvironmentalConditions message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof osi3.EnvironmentalConditions
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {osi3.EnvironmentalConditions} EnvironmentalConditions
         */
        EnvironmentalConditions.fromObject = function fromObject(object) {
            if (object instanceof $root.osi3.EnvironmentalConditions)
                return object;
            let message = new $root.osi3.EnvironmentalConditions();
            switch (object.ambientIllumination) {
            default:
                if (typeof object.ambientIllumination === "number") {
                    message.ambientIllumination = object.ambientIllumination;
                    break;
                }
                break;
            case "AMBIENT_ILLUMINATION_UNKNOWN":
            case 0:
                message.ambientIllumination = 0;
                break;
            case "AMBIENT_ILLUMINATION_OTHER":
            case 1:
                message.ambientIllumination = 1;
                break;
            case "AMBIENT_ILLUMINATION_LEVEL1":
            case 2:
                message.ambientIllumination = 2;
                break;
            case "AMBIENT_ILLUMINATION_LEVEL2":
            case 3:
                message.ambientIllumination = 3;
                break;
            case "AMBIENT_ILLUMINATION_LEVEL3":
            case 4:
                message.ambientIllumination = 4;
                break;
            case "AMBIENT_ILLUMINATION_LEVEL4":
            case 5:
                message.ambientIllumination = 5;
                break;
            case "AMBIENT_ILLUMINATION_LEVEL5":
            case 6:
                message.ambientIllumination = 6;
                break;
            case "AMBIENT_ILLUMINATION_LEVEL6":
            case 7:
                message.ambientIllumination = 7;
                break;
            case "AMBIENT_ILLUMINATION_LEVEL7":
            case 8:
                message.ambientIllumination = 8;
                break;
            case "AMBIENT_ILLUMINATION_LEVEL8":
            case 9:
                message.ambientIllumination = 9;
                break;
            case "AMBIENT_ILLUMINATION_LEVEL9":
            case 10:
                message.ambientIllumination = 10;
                break;
            }
            if (object.timeOfDay != null) {
                if (typeof object.timeOfDay !== "object")
                    throw TypeError(".osi3.EnvironmentalConditions.timeOfDay: object expected");
                message.timeOfDay = $root.osi3.EnvironmentalConditions.TimeOfDay.fromObject(object.timeOfDay);
            }
            if (object.unixTimestamp != null)
                if ($util.Long)
                    (message.unixTimestamp = $util.Long.fromValue(object.unixTimestamp)).unsigned = false;
                else if (typeof object.unixTimestamp === "string")
                    message.unixTimestamp = parseInt(object.unixTimestamp, 10);
                else if (typeof object.unixTimestamp === "number")
                    message.unixTimestamp = object.unixTimestamp;
                else if (typeof object.unixTimestamp === "object")
                    message.unixTimestamp = new $util.LongBits(object.unixTimestamp.low >>> 0, object.unixTimestamp.high >>> 0).toNumber();
            if (object.atmosphericPressure != null)
                message.atmosphericPressure = Number(object.atmosphericPressure);
            if (object.temperature != null)
                message.temperature = Number(object.temperature);
            if (object.relativeHumidity != null)
                message.relativeHumidity = Number(object.relativeHumidity);
            switch (object.precipitation) {
            default:
                if (typeof object.precipitation === "number") {
                    message.precipitation = object.precipitation;
                    break;
                }
                break;
            case "PRECIPITATION_UNKNOWN":
            case 0:
                message.precipitation = 0;
                break;
            case "PRECIPITATION_OTHER":
            case 1:
                message.precipitation = 1;
                break;
            case "PRECIPITATION_NONE":
            case 2:
                message.precipitation = 2;
                break;
            case "PRECIPITATION_VERY_LIGHT":
            case 3:
                message.precipitation = 3;
                break;
            case "PRECIPITATION_LIGHT":
            case 4:
                message.precipitation = 4;
                break;
            case "PRECIPITATION_MODERATE":
            case 5:
                message.precipitation = 5;
                break;
            case "PRECIPITATION_HEAVY":
            case 6:
                message.precipitation = 6;
                break;
            case "PRECIPITATION_VERY_HEAVY":
            case 7:
                message.precipitation = 7;
                break;
            case "PRECIPITATION_EXTREME":
            case 8:
                message.precipitation = 8;
                break;
            }
            switch (object.fog) {
            default:
                if (typeof object.fog === "number") {
                    message.fog = object.fog;
                    break;
                }
                break;
            case "FOG_UNKNOWN":
            case 0:
                message.fog = 0;
                break;
            case "FOG_OTHER":
            case 1:
                message.fog = 1;
                break;
            case "FOG_EXCELLENT_VISIBILITY":
            case 2:
                message.fog = 2;
                break;
            case "FOG_GOOD_VISIBILITY":
            case 3:
                message.fog = 3;
                break;
            case "FOG_MODERATE_VISIBILITY":
            case 4:
                message.fog = 4;
                break;
            case "FOG_POOR_VISIBILITY":
            case 5:
                message.fog = 5;
                break;
            case "FOG_MIST":
            case 6:
                message.fog = 6;
                break;
            case "FOG_LIGHT":
            case 7:
                message.fog = 7;
                break;
            case "FOG_THICK":
            case 8:
                message.fog = 8;
                break;
            case "FOG_DENSE":
            case 9:
                message.fog = 9;
                break;
            }
            if (object.sourceReference) {
                if (!Array.isArray(object.sourceReference))
                    throw TypeError(".osi3.EnvironmentalConditions.sourceReference: array expected");
                message.sourceReference = [];
                for (let i = 0; i < object.sourceReference.length; ++i) {
                    if (typeof object.sourceReference[i] !== "object")
                        throw TypeError(".osi3.EnvironmentalConditions.sourceReference: object expected");
                    message.sourceReference[i] = $root.osi3.ExternalReference.fromObject(object.sourceReference[i]);
                }
            }
            if (object.clouds != null) {
                if (typeof object.clouds !== "object")
                    throw TypeError(".osi3.EnvironmentalConditions.clouds: object expected");
                message.clouds = $root.osi3.EnvironmentalConditions.CloudLayer.fromObject(object.clouds);
            }
            if (object.wind != null) {
                if (typeof object.wind !== "object")
                    throw TypeError(".osi3.EnvironmentalConditions.wind: object expected");
                message.wind = $root.osi3.EnvironmentalConditions.Wind.fromObject(object.wind);
            }
            if (object.sun != null) {
                if (typeof object.sun !== "object")
                    throw TypeError(".osi3.EnvironmentalConditions.sun: object expected");
                message.sun = $root.osi3.EnvironmentalConditions.Sun.fromObject(object.sun);
            }
            return message;
        };

        /**
         * Creates a plain object from an EnvironmentalConditions message. Also converts values to other types if specified.
         * @function toObject
         * @memberof osi3.EnvironmentalConditions
         * @static
         * @param {osi3.EnvironmentalConditions} message EnvironmentalConditions
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EnvironmentalConditions.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.sourceReference = [];
            if (options.defaults) {
                object.ambientIllumination = options.enums === String ? "AMBIENT_ILLUMINATION_UNKNOWN" : 0;
                object.timeOfDay = null;
                object.atmosphericPressure = 0;
                object.temperature = 0;
                object.relativeHumidity = 0;
                object.precipitation = options.enums === String ? "PRECIPITATION_UNKNOWN" : 0;
                object.fog = options.enums === String ? "FOG_UNKNOWN" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.unixTimestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.unixTimestamp = options.longs === String ? "0" : 0;
                object.clouds = null;
                object.wind = null;
                object.sun = null;
            }
            if (message.ambientIllumination != null && message.hasOwnProperty("ambientIllumination"))
                object.ambientIllumination = options.enums === String ? $root.osi3.EnvironmentalConditions.AmbientIllumination[message.ambientIllumination] === undefined ? message.ambientIllumination : $root.osi3.EnvironmentalConditions.AmbientIllumination[message.ambientIllumination] : message.ambientIllumination;
            if (message.timeOfDay != null && message.hasOwnProperty("timeOfDay"))
                object.timeOfDay = $root.osi3.EnvironmentalConditions.TimeOfDay.toObject(message.timeOfDay, options);
            if (message.atmosphericPressure != null && message.hasOwnProperty("atmosphericPressure"))
                object.atmosphericPressure = options.json && !isFinite(message.atmosphericPressure) ? String(message.atmosphericPressure) : message.atmosphericPressure;
            if (message.temperature != null && message.hasOwnProperty("temperature"))
                object.temperature = options.json && !isFinite(message.temperature) ? String(message.temperature) : message.temperature;
            if (message.relativeHumidity != null && message.hasOwnProperty("relativeHumidity"))
                object.relativeHumidity = options.json && !isFinite(message.relativeHumidity) ? String(message.relativeHumidity) : message.relativeHumidity;
            if (message.precipitation != null && message.hasOwnProperty("precipitation"))
                object.precipitation = options.enums === String ? $root.osi3.EnvironmentalConditions.Precipitation[message.precipitation] === undefined ? message.precipitation : $root.osi3.EnvironmentalConditions.Precipitation[message.precipitation] : message.precipitation;
            if (message.fog != null && message.hasOwnProperty("fog"))
                object.fog = options.enums === String ? $root.osi3.EnvironmentalConditions.Fog[message.fog] === undefined ? message.fog : $root.osi3.EnvironmentalConditions.Fog[message.fog] : message.fog;
            if (message.unixTimestamp != null && message.hasOwnProperty("unixTimestamp"))
                if (typeof message.unixTimestamp === "number")
                    object.unixTimestamp = options.longs === String ? String(message.unixTimestamp) : message.unixTimestamp;
                else
                    object.unixTimestamp = options.longs === String ? $util.Long.prototype.toString.call(message.unixTimestamp) : options.longs === Number ? new $util.LongBits(message.unixTimestamp.low >>> 0, message.unixTimestamp.high >>> 0).toNumber() : message.unixTimestamp;
            if (message.sourceReference && message.sourceReference.length) {
                object.sourceReference = [];
                for (let j = 0; j < message.sourceReference.length; ++j)
                    object.sourceReference[j] = $root.osi3.ExternalReference.toObject(message.sourceReference[j], options);
            }
            if (message.clouds != null && message.hasOwnProperty("clouds"))
                object.clouds = $root.osi3.EnvironmentalConditions.CloudLayer.toObject(message.clouds, options);
            if (message.wind != null && message.hasOwnProperty("wind"))
                object.wind = $root.osi3.EnvironmentalConditions.Wind.toObject(message.wind, options);
            if (message.sun != null && message.hasOwnProperty("sun"))
                object.sun = $root.osi3.EnvironmentalConditions.Sun.toObject(message.sun, options);
            return object;
        };

        /**
         * Converts this EnvironmentalConditions to JSON.
         * @function toJSON
         * @memberof osi3.EnvironmentalConditions
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EnvironmentalConditions.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for EnvironmentalConditions
         * @function getTypeUrl
         * @memberof osi3.EnvironmentalConditions
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        EnvironmentalConditions.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/osi3.EnvironmentalConditions";
        };

        /**
         * Precipitation enum.
         * @name osi3.EnvironmentalConditions.Precipitation
         * @enum {number}
         * @property {number} PRECIPITATION_UNKNOWN=0 PRECIPITATION_UNKNOWN value
         * @property {number} PRECIPITATION_OTHER=1 PRECIPITATION_OTHER value
         * @property {number} PRECIPITATION_NONE=2 PRECIPITATION_NONE value
         * @property {number} PRECIPITATION_VERY_LIGHT=3 PRECIPITATION_VERY_LIGHT value
         * @property {number} PRECIPITATION_LIGHT=4 PRECIPITATION_LIGHT value
         * @property {number} PRECIPITATION_MODERATE=5 PRECIPITATION_MODERATE value
         * @property {number} PRECIPITATION_HEAVY=6 PRECIPITATION_HEAVY value
         * @property {number} PRECIPITATION_VERY_HEAVY=7 PRECIPITATION_VERY_HEAVY value
         * @property {number} PRECIPITATION_EXTREME=8 PRECIPITATION_EXTREME value
         */
        EnvironmentalConditions.Precipitation = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "PRECIPITATION_UNKNOWN"] = 0;
            values[valuesById[1] = "PRECIPITATION_OTHER"] = 1;
            values[valuesById[2] = "PRECIPITATION_NONE"] = 2;
            values[valuesById[3] = "PRECIPITATION_VERY_LIGHT"] = 3;
            values[valuesById[4] = "PRECIPITATION_LIGHT"] = 4;
            values[valuesById[5] = "PRECIPITATION_MODERATE"] = 5;
            values[valuesById[6] = "PRECIPITATION_HEAVY"] = 6;
            values[valuesById[7] = "PRECIPITATION_VERY_HEAVY"] = 7;
            values[valuesById[8] = "PRECIPITATION_EXTREME"] = 8;
            return values;
        })();

        /**
         * Fog enum.
         * @name osi3.EnvironmentalConditions.Fog
         * @enum {number}
         * @property {number} FOG_UNKNOWN=0 FOG_UNKNOWN value
         * @property {number} FOG_OTHER=1 FOG_OTHER value
         * @property {number} FOG_EXCELLENT_VISIBILITY=2 FOG_EXCELLENT_VISIBILITY value
         * @property {number} FOG_GOOD_VISIBILITY=3 FOG_GOOD_VISIBILITY value
         * @property {number} FOG_MODERATE_VISIBILITY=4 FOG_MODERATE_VISIBILITY value
         * @property {number} FOG_POOR_VISIBILITY=5 FOG_POOR_VISIBILITY value
         * @property {number} FOG_MIST=6 FOG_MIST value
         * @property {number} FOG_LIGHT=7 FOG_LIGHT value
         * @property {number} FOG_THICK=8 FOG_THICK value
         * @property {number} FOG_DENSE=9 FOG_DENSE value
         */
        EnvironmentalConditions.Fog = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "FOG_UNKNOWN"] = 0;
            values[valuesById[1] = "FOG_OTHER"] = 1;
            values[valuesById[2] = "FOG_EXCELLENT_VISIBILITY"] = 2;
            values[valuesById[3] = "FOG_GOOD_VISIBILITY"] = 3;
            values[valuesById[4] = "FOG_MODERATE_VISIBILITY"] = 4;
            values[valuesById[5] = "FOG_POOR_VISIBILITY"] = 5;
            values[valuesById[6] = "FOG_MIST"] = 6;
            values[valuesById[7] = "FOG_LIGHT"] = 7;
            values[valuesById[8] = "FOG_THICK"] = 8;
            values[valuesById[9] = "FOG_DENSE"] = 9;
            return values;
        })();

        /**
         * AmbientIllumination enum.
         * @name osi3.EnvironmentalConditions.AmbientIllumination
         * @enum {number}
         * @property {number} AMBIENT_ILLUMINATION_UNKNOWN=0 AMBIENT_ILLUMINATION_UNKNOWN value
         * @property {number} AMBIENT_ILLUMINATION_OTHER=1 AMBIENT_ILLUMINATION_OTHER value
         * @property {number} AMBIENT_ILLUMINATION_LEVEL1=2 AMBIENT_ILLUMINATION_LEVEL1 value
         * @property {number} AMBIENT_ILLUMINATION_LEVEL2=3 AMBIENT_ILLUMINATION_LEVEL2 value
         * @property {number} AMBIENT_ILLUMINATION_LEVEL3=4 AMBIENT_ILLUMINATION_LEVEL3 value
         * @property {number} AMBIENT_ILLUMINATION_LEVEL4=5 AMBIENT_ILLUMINATION_LEVEL4 value
         * @property {number} AMBIENT_ILLUMINATION_LEVEL5=6 AMBIENT_ILLUMINATION_LEVEL5 value
         * @property {number} AMBIENT_ILLUMINATION_LEVEL6=7 AMBIENT_ILLUMINATION_LEVEL6 value
         * @property {number} AMBIENT_ILLUMINATION_LEVEL7=8 AMBIENT_ILLUMINATION_LEVEL7 value
         * @property {number} AMBIENT_ILLUMINATION_LEVEL8=9 AMBIENT_ILLUMINATION_LEVEL8 value
         * @property {number} AMBIENT_ILLUMINATION_LEVEL9=10 AMBIENT_ILLUMINATION_LEVEL9 value
         */
        EnvironmentalConditions.AmbientIllumination = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "AMBIENT_ILLUMINATION_UNKNOWN"] = 0;
            values[valuesById[1] = "AMBIENT_ILLUMINATION_OTHER"] = 1;
            values[valuesById[2] = "AMBIENT_ILLUMINATION_LEVEL1"] = 2;
            values[valuesById[3] = "AMBIENT_ILLUMINATION_LEVEL2"] = 3;
            values[valuesById[4] = "AMBIENT_ILLUMINATION_LEVEL3"] = 4;
            values[valuesById[5] = "AMBIENT_ILLUMINATION_LEVEL4"] = 5;
            values[valuesById[6] = "AMBIENT_ILLUMINATION_LEVEL5"] = 6;
            values[valuesById[7] = "AMBIENT_ILLUMINATION_LEVEL6"] = 7;
            values[valuesById[8] = "AMBIENT_ILLUMINATION_LEVEL7"] = 8;
            values[valuesById[9] = "AMBIENT_ILLUMINATION_LEVEL8"] = 9;
            values[valuesById[10] = "AMBIENT_ILLUMINATION_LEVEL9"] = 10;
            return values;
        })();

        EnvironmentalConditions.TimeOfDay = (function() {

            /**
             * Properties of a TimeOfDay.
             * @memberof osi3.EnvironmentalConditions
             * @interface ITimeOfDay
             * @property {number|null} [secondsSinceMidnight] TimeOfDay secondsSinceMidnight
             */

            /**
             * Constructs a new TimeOfDay.
             * @memberof osi3.EnvironmentalConditions
             * @classdesc Represents a TimeOfDay.
             * @implements ITimeOfDay
             * @constructor
             * @param {osi3.EnvironmentalConditions.ITimeOfDay=} [properties] Properties to set
             */
            function TimeOfDay(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TimeOfDay secondsSinceMidnight.
             * @member {number} secondsSinceMidnight
             * @memberof osi3.EnvironmentalConditions.TimeOfDay
             * @instance
             */
            TimeOfDay.prototype.secondsSinceMidnight = 0;

            /**
             * Creates a new TimeOfDay instance using the specified properties.
             * @function create
             * @memberof osi3.EnvironmentalConditions.TimeOfDay
             * @static
             * @param {osi3.EnvironmentalConditions.ITimeOfDay=} [properties] Properties to set
             * @returns {osi3.EnvironmentalConditions.TimeOfDay} TimeOfDay instance
             */
            TimeOfDay.create = function create(properties) {
                return new TimeOfDay(properties);
            };

            /**
             * Encodes the specified TimeOfDay message. Does not implicitly {@link osi3.EnvironmentalConditions.TimeOfDay.verify|verify} messages.
             * @function encode
             * @memberof osi3.EnvironmentalConditions.TimeOfDay
             * @static
             * @param {osi3.EnvironmentalConditions.ITimeOfDay} message TimeOfDay message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TimeOfDay.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.secondsSinceMidnight != null && Object.hasOwnProperty.call(message, "secondsSinceMidnight"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.secondsSinceMidnight);
                return writer;
            };

            /**
             * Encodes the specified TimeOfDay message, length delimited. Does not implicitly {@link osi3.EnvironmentalConditions.TimeOfDay.verify|verify} messages.
             * @function encodeDelimited
             * @memberof osi3.EnvironmentalConditions.TimeOfDay
             * @static
             * @param {osi3.EnvironmentalConditions.ITimeOfDay} message TimeOfDay message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TimeOfDay.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a TimeOfDay message from the specified reader or buffer.
             * @function decode
             * @memberof osi3.EnvironmentalConditions.TimeOfDay
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {osi3.EnvironmentalConditions.TimeOfDay} TimeOfDay
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TimeOfDay.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.osi3.EnvironmentalConditions.TimeOfDay();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.secondsSinceMidnight = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a TimeOfDay message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof osi3.EnvironmentalConditions.TimeOfDay
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {osi3.EnvironmentalConditions.TimeOfDay} TimeOfDay
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TimeOfDay.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a TimeOfDay message.
             * @function verify
             * @memberof osi3.EnvironmentalConditions.TimeOfDay
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TimeOfDay.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.secondsSinceMidnight != null && message.hasOwnProperty("secondsSinceMidnight"))
                    if (!$util.isInteger(message.secondsSinceMidnight))
                        return "secondsSinceMidnight: integer expected";
                return null;
            };

            /**
             * Creates a TimeOfDay message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof osi3.EnvironmentalConditions.TimeOfDay
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {osi3.EnvironmentalConditions.TimeOfDay} TimeOfDay
             */
            TimeOfDay.fromObject = function fromObject(object) {
                if (object instanceof $root.osi3.EnvironmentalConditions.TimeOfDay)
                    return object;
                let message = new $root.osi3.EnvironmentalConditions.TimeOfDay();
                if (object.secondsSinceMidnight != null)
                    message.secondsSinceMidnight = object.secondsSinceMidnight >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a TimeOfDay message. Also converts values to other types if specified.
             * @function toObject
             * @memberof osi3.EnvironmentalConditions.TimeOfDay
             * @static
             * @param {osi3.EnvironmentalConditions.TimeOfDay} message TimeOfDay
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TimeOfDay.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.secondsSinceMidnight = 0;
                if (message.secondsSinceMidnight != null && message.hasOwnProperty("secondsSinceMidnight"))
                    object.secondsSinceMidnight = message.secondsSinceMidnight;
                return object;
            };

            /**
             * Converts this TimeOfDay to JSON.
             * @function toJSON
             * @memberof osi3.EnvironmentalConditions.TimeOfDay
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TimeOfDay.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for TimeOfDay
             * @function getTypeUrl
             * @memberof osi3.EnvironmentalConditions.TimeOfDay
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            TimeOfDay.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/osi3.EnvironmentalConditions.TimeOfDay";
            };

            return TimeOfDay;
        })();

        EnvironmentalConditions.CloudLayer = (function() {

            /**
             * Properties of a CloudLayer.
             * @memberof osi3.EnvironmentalConditions
             * @interface ICloudLayer
             * @property {osi3.EnvironmentalConditions.CloudLayer.FractionalCloudCover|null} [fractionalCloudCover] CloudLayer fractionalCloudCover
             */

            /**
             * Constructs a new CloudLayer.
             * @memberof osi3.EnvironmentalConditions
             * @classdesc Represents a CloudLayer.
             * @implements ICloudLayer
             * @constructor
             * @param {osi3.EnvironmentalConditions.ICloudLayer=} [properties] Properties to set
             */
            function CloudLayer(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CloudLayer fractionalCloudCover.
             * @member {osi3.EnvironmentalConditions.CloudLayer.FractionalCloudCover} fractionalCloudCover
             * @memberof osi3.EnvironmentalConditions.CloudLayer
             * @instance
             */
            CloudLayer.prototype.fractionalCloudCover = 0;

            /**
             * Creates a new CloudLayer instance using the specified properties.
             * @function create
             * @memberof osi3.EnvironmentalConditions.CloudLayer
             * @static
             * @param {osi3.EnvironmentalConditions.ICloudLayer=} [properties] Properties to set
             * @returns {osi3.EnvironmentalConditions.CloudLayer} CloudLayer instance
             */
            CloudLayer.create = function create(properties) {
                return new CloudLayer(properties);
            };

            /**
             * Encodes the specified CloudLayer message. Does not implicitly {@link osi3.EnvironmentalConditions.CloudLayer.verify|verify} messages.
             * @function encode
             * @memberof osi3.EnvironmentalConditions.CloudLayer
             * @static
             * @param {osi3.EnvironmentalConditions.ICloudLayer} message CloudLayer message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CloudLayer.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.fractionalCloudCover != null && Object.hasOwnProperty.call(message, "fractionalCloudCover"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.fractionalCloudCover);
                return writer;
            };

            /**
             * Encodes the specified CloudLayer message, length delimited. Does not implicitly {@link osi3.EnvironmentalConditions.CloudLayer.verify|verify} messages.
             * @function encodeDelimited
             * @memberof osi3.EnvironmentalConditions.CloudLayer
             * @static
             * @param {osi3.EnvironmentalConditions.ICloudLayer} message CloudLayer message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CloudLayer.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CloudLayer message from the specified reader or buffer.
             * @function decode
             * @memberof osi3.EnvironmentalConditions.CloudLayer
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {osi3.EnvironmentalConditions.CloudLayer} CloudLayer
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CloudLayer.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.osi3.EnvironmentalConditions.CloudLayer();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.fractionalCloudCover = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CloudLayer message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof osi3.EnvironmentalConditions.CloudLayer
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {osi3.EnvironmentalConditions.CloudLayer} CloudLayer
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CloudLayer.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CloudLayer message.
             * @function verify
             * @memberof osi3.EnvironmentalConditions.CloudLayer
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CloudLayer.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.fractionalCloudCover != null && message.hasOwnProperty("fractionalCloudCover"))
                    switch (message.fractionalCloudCover) {
                    default:
                        return "fractionalCloudCover: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                    case 9:
                    case 10:
                    case 11:
                        break;
                    }
                return null;
            };

            /**
             * Creates a CloudLayer message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof osi3.EnvironmentalConditions.CloudLayer
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {osi3.EnvironmentalConditions.CloudLayer} CloudLayer
             */
            CloudLayer.fromObject = function fromObject(object) {
                if (object instanceof $root.osi3.EnvironmentalConditions.CloudLayer)
                    return object;
                let message = new $root.osi3.EnvironmentalConditions.CloudLayer();
                switch (object.fractionalCloudCover) {
                default:
                    if (typeof object.fractionalCloudCover === "number") {
                        message.fractionalCloudCover = object.fractionalCloudCover;
                        break;
                    }
                    break;
                case "FRACTIONAL_CLOUD_COVER_UNKNOWN":
                case 0:
                    message.fractionalCloudCover = 0;
                    break;
                case "FRACTIONAL_CLOUD_COVER_OTHER":
                case 1:
                    message.fractionalCloudCover = 1;
                    break;
                case "FRACTIONAL_CLOUD_COVER_ZERO_OKTAS":
                case 2:
                    message.fractionalCloudCover = 2;
                    break;
                case "FRACTIONAL_CLOUD_COVER_ONE_OKTAS":
                case 3:
                    message.fractionalCloudCover = 3;
                    break;
                case "FRACTIONAL_CLOUD_COVER_TWO_OKTAS":
                case 4:
                    message.fractionalCloudCover = 4;
                    break;
                case "FRACTIONAL_CLOUD_COVER_THREE_OKTAS":
                case 5:
                    message.fractionalCloudCover = 5;
                    break;
                case "FRACTIONAL_CLOUD_COVER_FOUR_OKTAS":
                case 6:
                    message.fractionalCloudCover = 6;
                    break;
                case "FRACTIONAL_CLOUD_COVER_FIVE_OKTAS":
                case 7:
                    message.fractionalCloudCover = 7;
                    break;
                case "FRACTIONAL_CLOUD_COVER_SIX_OKTAS":
                case 8:
                    message.fractionalCloudCover = 8;
                    break;
                case "FRACTIONAL_CLOUD_COVER_SEVEN_OKTAS":
                case 9:
                    message.fractionalCloudCover = 9;
                    break;
                case "FRACTIONAL_CLOUD_COVER_EIGHT_OKTAS":
                case 10:
                    message.fractionalCloudCover = 10;
                    break;
                case "FRACTIONAL_CLOUD_COVER_SKY_OBSCURED":
                case 11:
                    message.fractionalCloudCover = 11;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from a CloudLayer message. Also converts values to other types if specified.
             * @function toObject
             * @memberof osi3.EnvironmentalConditions.CloudLayer
             * @static
             * @param {osi3.EnvironmentalConditions.CloudLayer} message CloudLayer
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CloudLayer.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.fractionalCloudCover = options.enums === String ? "FRACTIONAL_CLOUD_COVER_UNKNOWN" : 0;
                if (message.fractionalCloudCover != null && message.hasOwnProperty("fractionalCloudCover"))
                    object.fractionalCloudCover = options.enums === String ? $root.osi3.EnvironmentalConditions.CloudLayer.FractionalCloudCover[message.fractionalCloudCover] === undefined ? message.fractionalCloudCover : $root.osi3.EnvironmentalConditions.CloudLayer.FractionalCloudCover[message.fractionalCloudCover] : message.fractionalCloudCover;
                return object;
            };

            /**
             * Converts this CloudLayer to JSON.
             * @function toJSON
             * @memberof osi3.EnvironmentalConditions.CloudLayer
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CloudLayer.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for CloudLayer
             * @function getTypeUrl
             * @memberof osi3.EnvironmentalConditions.CloudLayer
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            CloudLayer.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/osi3.EnvironmentalConditions.CloudLayer";
            };

            /**
             * FractionalCloudCover enum.
             * @name osi3.EnvironmentalConditions.CloudLayer.FractionalCloudCover
             * @enum {number}
             * @property {number} FRACTIONAL_CLOUD_COVER_UNKNOWN=0 FRACTIONAL_CLOUD_COVER_UNKNOWN value
             * @property {number} FRACTIONAL_CLOUD_COVER_OTHER=1 FRACTIONAL_CLOUD_COVER_OTHER value
             * @property {number} FRACTIONAL_CLOUD_COVER_ZERO_OKTAS=2 FRACTIONAL_CLOUD_COVER_ZERO_OKTAS value
             * @property {number} FRACTIONAL_CLOUD_COVER_ONE_OKTAS=3 FRACTIONAL_CLOUD_COVER_ONE_OKTAS value
             * @property {number} FRACTIONAL_CLOUD_COVER_TWO_OKTAS=4 FRACTIONAL_CLOUD_COVER_TWO_OKTAS value
             * @property {number} FRACTIONAL_CLOUD_COVER_THREE_OKTAS=5 FRACTIONAL_CLOUD_COVER_THREE_OKTAS value
             * @property {number} FRACTIONAL_CLOUD_COVER_FOUR_OKTAS=6 FRACTIONAL_CLOUD_COVER_FOUR_OKTAS value
             * @property {number} FRACTIONAL_CLOUD_COVER_FIVE_OKTAS=7 FRACTIONAL_CLOUD_COVER_FIVE_OKTAS value
             * @property {number} FRACTIONAL_CLOUD_COVER_SIX_OKTAS=8 FRACTIONAL_CLOUD_COVER_SIX_OKTAS value
             * @property {number} FRACTIONAL_CLOUD_COVER_SEVEN_OKTAS=9 FRACTIONAL_CLOUD_COVER_SEVEN_OKTAS value
             * @property {number} FRACTIONAL_CLOUD_COVER_EIGHT_OKTAS=10 FRACTIONAL_CLOUD_COVER_EIGHT_OKTAS value
             * @property {number} FRACTIONAL_CLOUD_COVER_SKY_OBSCURED=11 FRACTIONAL_CLOUD_COVER_SKY_OBSCURED value
             */
            CloudLayer.FractionalCloudCover = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "FRACTIONAL_CLOUD_COVER_UNKNOWN"] = 0;
                values[valuesById[1] = "FRACTIONAL_CLOUD_COVER_OTHER"] = 1;
                values[valuesById[2] = "FRACTIONAL_CLOUD_COVER_ZERO_OKTAS"] = 2;
                values[valuesById[3] = "FRACTIONAL_CLOUD_COVER_ONE_OKTAS"] = 3;
                values[valuesById[4] = "FRACTIONAL_CLOUD_COVER_TWO_OKTAS"] = 4;
                values[valuesById[5] = "FRACTIONAL_CLOUD_COVER_THREE_OKTAS"] = 5;
                values[valuesById[6] = "FRACTIONAL_CLOUD_COVER_FOUR_OKTAS"] = 6;
                values[valuesById[7] = "FRACTIONAL_CLOUD_COVER_FIVE_OKTAS"] = 7;
                values[valuesById[8] = "FRACTIONAL_CLOUD_COVER_SIX_OKTAS"] = 8;
                values[valuesById[9] = "FRACTIONAL_CLOUD_COVER_SEVEN_OKTAS"] = 9;
                values[valuesById[10] = "FRACTIONAL_CLOUD_COVER_EIGHT_OKTAS"] = 10;
                values[valuesById[11] = "FRACTIONAL_CLOUD_COVER_SKY_OBSCURED"] = 11;
                return values;
            })();

            return CloudLayer;
        })();

        EnvironmentalConditions.Wind = (function() {

            /**
             * Properties of a Wind.
             * @memberof osi3.EnvironmentalConditions
             * @interface IWind
             * @property {number|null} [originDirection] Wind originDirection
             * @property {number|null} [speed] Wind speed
             */

            /**
             * Constructs a new Wind.
             * @memberof osi3.EnvironmentalConditions
             * @classdesc Represents a Wind.
             * @implements IWind
             * @constructor
             * @param {osi3.EnvironmentalConditions.IWind=} [properties] Properties to set
             */
            function Wind(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Wind originDirection.
             * @member {number} originDirection
             * @memberof osi3.EnvironmentalConditions.Wind
             * @instance
             */
            Wind.prototype.originDirection = 0;

            /**
             * Wind speed.
             * @member {number} speed
             * @memberof osi3.EnvironmentalConditions.Wind
             * @instance
             */
            Wind.prototype.speed = 0;

            /**
             * Creates a new Wind instance using the specified properties.
             * @function create
             * @memberof osi3.EnvironmentalConditions.Wind
             * @static
             * @param {osi3.EnvironmentalConditions.IWind=} [properties] Properties to set
             * @returns {osi3.EnvironmentalConditions.Wind} Wind instance
             */
            Wind.create = function create(properties) {
                return new Wind(properties);
            };

            /**
             * Encodes the specified Wind message. Does not implicitly {@link osi3.EnvironmentalConditions.Wind.verify|verify} messages.
             * @function encode
             * @memberof osi3.EnvironmentalConditions.Wind
             * @static
             * @param {osi3.EnvironmentalConditions.IWind} message Wind message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Wind.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.originDirection != null && Object.hasOwnProperty.call(message, "originDirection"))
                    writer.uint32(/* id 1, wireType 1 =*/9).double(message.originDirection);
                if (message.speed != null && Object.hasOwnProperty.call(message, "speed"))
                    writer.uint32(/* id 2, wireType 1 =*/17).double(message.speed);
                return writer;
            };

            /**
             * Encodes the specified Wind message, length delimited. Does not implicitly {@link osi3.EnvironmentalConditions.Wind.verify|verify} messages.
             * @function encodeDelimited
             * @memberof osi3.EnvironmentalConditions.Wind
             * @static
             * @param {osi3.EnvironmentalConditions.IWind} message Wind message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Wind.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Wind message from the specified reader or buffer.
             * @function decode
             * @memberof osi3.EnvironmentalConditions.Wind
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {osi3.EnvironmentalConditions.Wind} Wind
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Wind.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.osi3.EnvironmentalConditions.Wind();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.originDirection = reader.double();
                            break;
                        }
                    case 2: {
                            message.speed = reader.double();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Wind message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof osi3.EnvironmentalConditions.Wind
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {osi3.EnvironmentalConditions.Wind} Wind
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Wind.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Wind message.
             * @function verify
             * @memberof osi3.EnvironmentalConditions.Wind
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Wind.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.originDirection != null && message.hasOwnProperty("originDirection"))
                    if (typeof message.originDirection !== "number")
                        return "originDirection: number expected";
                if (message.speed != null && message.hasOwnProperty("speed"))
                    if (typeof message.speed !== "number")
                        return "speed: number expected";
                return null;
            };

            /**
             * Creates a Wind message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof osi3.EnvironmentalConditions.Wind
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {osi3.EnvironmentalConditions.Wind} Wind
             */
            Wind.fromObject = function fromObject(object) {
                if (object instanceof $root.osi3.EnvironmentalConditions.Wind)
                    return object;
                let message = new $root.osi3.EnvironmentalConditions.Wind();
                if (object.originDirection != null)
                    message.originDirection = Number(object.originDirection);
                if (object.speed != null)
                    message.speed = Number(object.speed);
                return message;
            };

            /**
             * Creates a plain object from a Wind message. Also converts values to other types if specified.
             * @function toObject
             * @memberof osi3.EnvironmentalConditions.Wind
             * @static
             * @param {osi3.EnvironmentalConditions.Wind} message Wind
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Wind.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.originDirection = 0;
                    object.speed = 0;
                }
                if (message.originDirection != null && message.hasOwnProperty("originDirection"))
                    object.originDirection = options.json && !isFinite(message.originDirection) ? String(message.originDirection) : message.originDirection;
                if (message.speed != null && message.hasOwnProperty("speed"))
                    object.speed = options.json && !isFinite(message.speed) ? String(message.speed) : message.speed;
                return object;
            };

            /**
             * Converts this Wind to JSON.
             * @function toJSON
             * @memberof osi3.EnvironmentalConditions.Wind
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Wind.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Wind
             * @function getTypeUrl
             * @memberof osi3.EnvironmentalConditions.Wind
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Wind.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/osi3.EnvironmentalConditions.Wind";
            };

            return Wind;
        })();

        EnvironmentalConditions.Sun = (function() {

            /**
             * Properties of a Sun.
             * @memberof osi3.EnvironmentalConditions
             * @interface ISun
             * @property {number|null} [azimuth] Sun azimuth
             * @property {number|null} [elevation] Sun elevation
             * @property {number|null} [intensity] Sun intensity
             */

            /**
             * Constructs a new Sun.
             * @memberof osi3.EnvironmentalConditions
             * @classdesc Represents a Sun.
             * @implements ISun
             * @constructor
             * @param {osi3.EnvironmentalConditions.ISun=} [properties] Properties to set
             */
            function Sun(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Sun azimuth.
             * @member {number} azimuth
             * @memberof osi3.EnvironmentalConditions.Sun
             * @instance
             */
            Sun.prototype.azimuth = 0;

            /**
             * Sun elevation.
             * @member {number} elevation
             * @memberof osi3.EnvironmentalConditions.Sun
             * @instance
             */
            Sun.prototype.elevation = 0;

            /**
             * Sun intensity.
             * @member {number} intensity
             * @memberof osi3.EnvironmentalConditions.Sun
             * @instance
             */
            Sun.prototype.intensity = 0;

            /**
             * Creates a new Sun instance using the specified properties.
             * @function create
             * @memberof osi3.EnvironmentalConditions.Sun
             * @static
             * @param {osi3.EnvironmentalConditions.ISun=} [properties] Properties to set
             * @returns {osi3.EnvironmentalConditions.Sun} Sun instance
             */
            Sun.create = function create(properties) {
                return new Sun(properties);
            };

            /**
             * Encodes the specified Sun message. Does not implicitly {@link osi3.EnvironmentalConditions.Sun.verify|verify} messages.
             * @function encode
             * @memberof osi3.EnvironmentalConditions.Sun
             * @static
             * @param {osi3.EnvironmentalConditions.ISun} message Sun message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Sun.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.azimuth != null && Object.hasOwnProperty.call(message, "azimuth"))
                    writer.uint32(/* id 1, wireType 1 =*/9).double(message.azimuth);
                if (message.elevation != null && Object.hasOwnProperty.call(message, "elevation"))
                    writer.uint32(/* id 2, wireType 1 =*/17).double(message.elevation);
                if (message.intensity != null && Object.hasOwnProperty.call(message, "intensity"))
                    writer.uint32(/* id 3, wireType 1 =*/25).double(message.intensity);
                return writer;
            };

            /**
             * Encodes the specified Sun message, length delimited. Does not implicitly {@link osi3.EnvironmentalConditions.Sun.verify|verify} messages.
             * @function encodeDelimited
             * @memberof osi3.EnvironmentalConditions.Sun
             * @static
             * @param {osi3.EnvironmentalConditions.ISun} message Sun message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Sun.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Sun message from the specified reader or buffer.
             * @function decode
             * @memberof osi3.EnvironmentalConditions.Sun
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {osi3.EnvironmentalConditions.Sun} Sun
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Sun.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.osi3.EnvironmentalConditions.Sun();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.azimuth = reader.double();
                            break;
                        }
                    case 2: {
                            message.elevation = reader.double();
                            break;
                        }
                    case 3: {
                            message.intensity = reader.double();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Sun message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof osi3.EnvironmentalConditions.Sun
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {osi3.EnvironmentalConditions.Sun} Sun
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Sun.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Sun message.
             * @function verify
             * @memberof osi3.EnvironmentalConditions.Sun
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Sun.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.azimuth != null && message.hasOwnProperty("azimuth"))
                    if (typeof message.azimuth !== "number")
                        return "azimuth: number expected";
                if (message.elevation != null && message.hasOwnProperty("elevation"))
                    if (typeof message.elevation !== "number")
                        return "elevation: number expected";
                if (message.intensity != null && message.hasOwnProperty("intensity"))
                    if (typeof message.intensity !== "number")
                        return "intensity: number expected";
                return null;
            };

            /**
             * Creates a Sun message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof osi3.EnvironmentalConditions.Sun
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {osi3.EnvironmentalConditions.Sun} Sun
             */
            Sun.fromObject = function fromObject(object) {
                if (object instanceof $root.osi3.EnvironmentalConditions.Sun)
                    return object;
                let message = new $root.osi3.EnvironmentalConditions.Sun();
                if (object.azimuth != null)
                    message.azimuth = Number(object.azimuth);
                if (object.elevation != null)
                    message.elevation = Number(object.elevation);
                if (object.intensity != null)
                    message.intensity = Number(object.intensity);
                return message;
            };

            /**
             * Creates a plain object from a Sun message. Also converts values to other types if specified.
             * @function toObject
             * @memberof osi3.EnvironmentalConditions.Sun
             * @static
             * @param {osi3.EnvironmentalConditions.Sun} message Sun
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Sun.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.azimuth = 0;
                    object.elevation = 0;
                    object.intensity = 0;
                }
                if (message.azimuth != null && message.hasOwnProperty("azimuth"))
                    object.azimuth = options.json && !isFinite(message.azimuth) ? String(message.azimuth) : message.azimuth;
                if (message.elevation != null && message.hasOwnProperty("elevation"))
                    object.elevation = options.json && !isFinite(message.elevation) ? String(message.elevation) : message.elevation;
                if (message.intensity != null && message.hasOwnProperty("intensity"))
                    object.intensity = options.json && !isFinite(message.intensity) ? String(message.intensity) : message.intensity;
                return object;
            };

            /**
             * Converts this Sun to JSON.
             * @function toJSON
             * @memberof osi3.EnvironmentalConditions.Sun
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Sun.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Sun
             * @function getTypeUrl
             * @memberof osi3.EnvironmentalConditions.Sun
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Sun.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/osi3.EnvironmentalConditions.Sun";
            };

            return Sun;
        })();

        return EnvironmentalConditions;
    })();

    osi3.TrafficSignValue = (function() {

        /**
         * Properties of a TrafficSignValue.
         * @memberof osi3
         * @interface ITrafficSignValue
         * @property {number|null} [value] TrafficSignValue value
         * @property {osi3.TrafficSignValue.Unit|null} [valueUnit] TrafficSignValue valueUnit
         * @property {string|null} [text] TrafficSignValue text
         */

        /**
         * Constructs a new TrafficSignValue.
         * @memberof osi3
         * @classdesc Represents a TrafficSignValue.
         * @implements ITrafficSignValue
         * @constructor
         * @param {osi3.ITrafficSignValue=} [properties] Properties to set
         */
        function TrafficSignValue(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TrafficSignValue value.
         * @member {number} value
         * @memberof osi3.TrafficSignValue
         * @instance
         */
        TrafficSignValue.prototype.value = 0;

        /**
         * TrafficSignValue valueUnit.
         * @member {osi3.TrafficSignValue.Unit} valueUnit
         * @memberof osi3.TrafficSignValue
         * @instance
         */
        TrafficSignValue.prototype.valueUnit = 0;

        /**
         * TrafficSignValue text.
         * @member {string} text
         * @memberof osi3.TrafficSignValue
         * @instance
         */
        TrafficSignValue.prototype.text = "";

        /**
         * Creates a new TrafficSignValue instance using the specified properties.
         * @function create
         * @memberof osi3.TrafficSignValue
         * @static
         * @param {osi3.ITrafficSignValue=} [properties] Properties to set
         * @returns {osi3.TrafficSignValue} TrafficSignValue instance
         */
        TrafficSignValue.create = function create(properties) {
            return new TrafficSignValue(properties);
        };

        /**
         * Encodes the specified TrafficSignValue message. Does not implicitly {@link osi3.TrafficSignValue.verify|verify} messages.
         * @function encode
         * @memberof osi3.TrafficSignValue
         * @static
         * @param {osi3.ITrafficSignValue} message TrafficSignValue message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TrafficSignValue.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                writer.uint32(/* id 1, wireType 1 =*/9).double(message.value);
            if (message.valueUnit != null && Object.hasOwnProperty.call(message, "valueUnit"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.valueUnit);
            if (message.text != null && Object.hasOwnProperty.call(message, "text"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.text);
            return writer;
        };

        /**
         * Encodes the specified TrafficSignValue message, length delimited. Does not implicitly {@link osi3.TrafficSignValue.verify|verify} messages.
         * @function encodeDelimited
         * @memberof osi3.TrafficSignValue
         * @static
         * @param {osi3.ITrafficSignValue} message TrafficSignValue message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TrafficSignValue.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TrafficSignValue message from the specified reader or buffer.
         * @function decode
         * @memberof osi3.TrafficSignValue
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {osi3.TrafficSignValue} TrafficSignValue
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TrafficSignValue.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.osi3.TrafficSignValue();
            while (reader.pos < end) {
                let tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.value = reader.double();
                        break;
                    }
                case 2: {
                        message.valueUnit = reader.int32();
                        break;
                    }
                case 3: {
                        message.text = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TrafficSignValue message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof osi3.TrafficSignValue
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {osi3.TrafficSignValue} TrafficSignValue
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TrafficSignValue.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TrafficSignValue message.
         * @function verify
         * @memberof osi3.TrafficSignValue
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TrafficSignValue.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.value != null && message.hasOwnProperty("value"))
                if (typeof message.value !== "number")
                    return "value: number expected";
            if (message.valueUnit != null && message.hasOwnProperty("valueUnit"))
                switch (message.valueUnit) {
                default:
                    return "valueUnit: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 15:
                case 12:
                case 16:
                case 13:
                case 14:
                case 17:
                case 18:
                case 19:
                    break;
                }
            if (message.text != null && message.hasOwnProperty("text"))
                if (!$util.isString(message.text))
                    return "text: string expected";
            return null;
        };

        /**
         * Creates a TrafficSignValue message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof osi3.TrafficSignValue
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {osi3.TrafficSignValue} TrafficSignValue
         */
        TrafficSignValue.fromObject = function fromObject(object) {
            if (object instanceof $root.osi3.TrafficSignValue)
                return object;
            let message = new $root.osi3.TrafficSignValue();
            if (object.value != null)
                message.value = Number(object.value);
            switch (object.valueUnit) {
            default:
                if (typeof object.valueUnit === "number") {
                    message.valueUnit = object.valueUnit;
                    break;
                }
                break;
            case "UNIT_UNKNOWN":
            case 0:
                message.valueUnit = 0;
                break;
            case "UNIT_OTHER":
            case 1:
                message.valueUnit = 1;
                break;
            case "UNIT_NO_UNIT":
            case 2:
                message.valueUnit = 2;
                break;
            case "UNIT_KILOMETER_PER_HOUR":
            case 3:
                message.valueUnit = 3;
                break;
            case "UNIT_MILE_PER_HOUR":
            case 4:
                message.valueUnit = 4;
                break;
            case "UNIT_METER":
            case 5:
                message.valueUnit = 5;
                break;
            case "UNIT_KILOMETER":
            case 6:
                message.valueUnit = 6;
                break;
            case "UNIT_FEET":
            case 7:
                message.valueUnit = 7;
                break;
            case "UNIT_MILE":
            case 8:
                message.valueUnit = 8;
                break;
            case "UNIT_METRIC_TON":
            case 9:
                message.valueUnit = 9;
                break;
            case "UNIT_LONG_TON":
            case 10:
                message.valueUnit = 10;
                break;
            case "UNIT_SHORT_TON":
            case 11:
                message.valueUnit = 11;
                break;
            case "UNIT_HOUR":
            case 15:
                message.valueUnit = 15;
                break;
            case "UNIT_MINUTES":
            case 12:
                message.valueUnit = 12;
                break;
            case "UNIT_DAY_OF_MONTH":
            case 16:
                message.valueUnit = 16;
                break;
            case "UNIT_DAY":
            case 13:
                message.valueUnit = 13;
                break;
            case "UNIT_PERCENTAGE":
            case 14:
                message.valueUnit = 14;
                break;
            case "UNIT_DURATION_DAY":
            case 17:
                message.valueUnit = 17;
                break;
            case "UNIT_DURATION_HOUR":
            case 18:
                message.valueUnit = 18;
                break;
            case "UNIT_DURATION_MINUTE":
            case 19:
                message.valueUnit = 19;
                break;
            }
            if (object.text != null)
                message.text = String(object.text);
            return message;
        };

        /**
         * Creates a plain object from a TrafficSignValue message. Also converts values to other types if specified.
         * @function toObject
         * @memberof osi3.TrafficSignValue
         * @static
         * @param {osi3.TrafficSignValue} message TrafficSignValue
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TrafficSignValue.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.value = 0;
                object.valueUnit = options.enums === String ? "UNIT_UNKNOWN" : 0;
                object.text = "";
            }
            if (message.value != null && message.hasOwnProperty("value"))
                object.value = options.json && !isFinite(message.value) ? String(message.value) : message.value;
            if (message.valueUnit != null && message.hasOwnProperty("valueUnit"))
                object.valueUnit = options.enums === String ? $root.osi3.TrafficSignValue.Unit[message.valueUnit] === undefined ? message.valueUnit : $root.osi3.TrafficSignValue.Unit[message.valueUnit] : message.valueUnit;
            if (message.text != null && message.hasOwnProperty("text"))
                object.text = message.text;
            return object;
        };

        /**
         * Converts this TrafficSignValue to JSON.
         * @function toJSON
         * @memberof osi3.TrafficSignValue
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TrafficSignValue.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for TrafficSignValue
         * @function getTypeUrl
         * @memberof osi3.TrafficSignValue
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TrafficSignValue.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/osi3.TrafficSignValue";
        };

        /**
         * Unit enum.
         * @name osi3.TrafficSignValue.Unit
         * @enum {number}
         * @property {number} UNIT_UNKNOWN=0 UNIT_UNKNOWN value
         * @property {number} UNIT_OTHER=1 UNIT_OTHER value
         * @property {number} UNIT_NO_UNIT=2 UNIT_NO_UNIT value
         * @property {number} UNIT_KILOMETER_PER_HOUR=3 UNIT_KILOMETER_PER_HOUR value
         * @property {number} UNIT_MILE_PER_HOUR=4 UNIT_MILE_PER_HOUR value
         * @property {number} UNIT_METER=5 UNIT_METER value
         * @property {number} UNIT_KILOMETER=6 UNIT_KILOMETER value
         * @property {number} UNIT_FEET=7 UNIT_FEET value
         * @property {number} UNIT_MILE=8 UNIT_MILE value
         * @property {number} UNIT_METRIC_TON=9 UNIT_METRIC_TON value
         * @property {number} UNIT_LONG_TON=10 UNIT_LONG_TON value
         * @property {number} UNIT_SHORT_TON=11 UNIT_SHORT_TON value
         * @property {number} UNIT_HOUR=15 UNIT_HOUR value
         * @property {number} UNIT_MINUTES=12 UNIT_MINUTES value
         * @property {number} UNIT_DAY_OF_MONTH=16 UNIT_DAY_OF_MONTH value
         * @property {number} UNIT_DAY=13 UNIT_DAY value
         * @property {number} UNIT_PERCENTAGE=14 UNIT_PERCENTAGE value
         * @property {number} UNIT_DURATION_DAY=17 UNIT_DURATION_DAY value
         * @property {number} UNIT_DURATION_HOUR=18 UNIT_DURATION_HOUR value
         * @property {number} UNIT_DURATION_MINUTE=19 UNIT_DURATION_MINUTE value
         */
        TrafficSignValue.Unit = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNIT_UNKNOWN"] = 0;
            values[valuesById[1] = "UNIT_OTHER"] = 1;
            values[valuesById[2] = "UNIT_NO_UNIT"] = 2;
            values[valuesById[3] = "UNIT_KILOMETER_PER_HOUR"] = 3;
            values[valuesById[4] = "UNIT_MILE_PER_HOUR"] = 4;
            values[valuesById[5] = "UNIT_METER"] = 5;
            values[valuesById[6] = "UNIT_KILOMETER"] = 6;
            values[valuesById[7] = "UNIT_FEET"] = 7;
            values[valuesById[8] = "UNIT_MILE"] = 8;
            values[valuesById[9] = "UNIT_METRIC_TON"] = 9;
            values[valuesById[10] = "UNIT_LONG_TON"] = 10;
            values[valuesById[11] = "UNIT_SHORT_TON"] = 11;
            values[valuesById[15] = "UNIT_HOUR"] = 15;
            values[valuesById[12] = "UNIT_MINUTES"] = 12;
            values[valuesById[16] = "UNIT_DAY_OF_MONTH"] = 16;
            values[valuesById[13] = "UNIT_DAY"] = 13;
            values[valuesById[14] = "UNIT_PERCENTAGE"] = 14;
            values[valuesById[17] = "UNIT_DURATION_DAY"] = 17;
            values[valuesById[18] = "UNIT_DURATION_HOUR"] = 18;
            values[valuesById[19] = "UNIT_DURATION_MINUTE"] = 19;
            return values;
        })();

        return TrafficSignValue;
    })();

    osi3.TrafficSign = (function() {

        /**
         * Properties of a TrafficSign.
         * @memberof osi3
         * @interface ITrafficSign
         * @property {osi3.IIdentifier|null} [id] TrafficSign id
         * @property {osi3.TrafficSign.IMainSign|null} [mainSign] TrafficSign mainSign
         * @property {Array.<osi3.TrafficSign.ISupplementarySign>|null} [supplementarySign] TrafficSign supplementarySign
         * @property {Array.<osi3.IExternalReference>|null} [sourceReference] TrafficSign sourceReference
         */

        /**
         * Constructs a new TrafficSign.
         * @memberof osi3
         * @classdesc Represents a TrafficSign.
         * @implements ITrafficSign
         * @constructor
         * @param {osi3.ITrafficSign=} [properties] Properties to set
         */
        function TrafficSign(properties) {
            this.supplementarySign = [];
            this.sourceReference = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TrafficSign id.
         * @member {osi3.IIdentifier|null|undefined} id
         * @memberof osi3.TrafficSign
         * @instance
         */
        TrafficSign.prototype.id = null;

        /**
         * TrafficSign mainSign.
         * @member {osi3.TrafficSign.IMainSign|null|undefined} mainSign
         * @memberof osi3.TrafficSign
         * @instance
         */
        TrafficSign.prototype.mainSign = null;

        /**
         * TrafficSign supplementarySign.
         * @member {Array.<osi3.TrafficSign.ISupplementarySign>} supplementarySign
         * @memberof osi3.TrafficSign
         * @instance
         */
        TrafficSign.prototype.supplementarySign = $util.emptyArray;

        /**
         * TrafficSign sourceReference.
         * @member {Array.<osi3.IExternalReference>} sourceReference
         * @memberof osi3.TrafficSign
         * @instance
         */
        TrafficSign.prototype.sourceReference = $util.emptyArray;

        /**
         * Creates a new TrafficSign instance using the specified properties.
         * @function create
         * @memberof osi3.TrafficSign
         * @static
         * @param {osi3.ITrafficSign=} [properties] Properties to set
         * @returns {osi3.TrafficSign} TrafficSign instance
         */
        TrafficSign.create = function create(properties) {
            return new TrafficSign(properties);
        };

        /**
         * Encodes the specified TrafficSign message. Does not implicitly {@link osi3.TrafficSign.verify|verify} messages.
         * @function encode
         * @memberof osi3.TrafficSign
         * @static
         * @param {osi3.ITrafficSign} message TrafficSign message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TrafficSign.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                $root.osi3.Identifier.encode(message.id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.mainSign != null && Object.hasOwnProperty.call(message, "mainSign"))
                $root.osi3.TrafficSign.MainSign.encode(message.mainSign, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.supplementarySign != null && message.supplementarySign.length)
                for (let i = 0; i < message.supplementarySign.length; ++i)
                    $root.osi3.TrafficSign.SupplementarySign.encode(message.supplementarySign[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.sourceReference != null && message.sourceReference.length)
                for (let i = 0; i < message.sourceReference.length; ++i)
                    $root.osi3.ExternalReference.encode(message.sourceReference[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified TrafficSign message, length delimited. Does not implicitly {@link osi3.TrafficSign.verify|verify} messages.
         * @function encodeDelimited
         * @memberof osi3.TrafficSign
         * @static
         * @param {osi3.ITrafficSign} message TrafficSign message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TrafficSign.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TrafficSign message from the specified reader or buffer.
         * @function decode
         * @memberof osi3.TrafficSign
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {osi3.TrafficSign} TrafficSign
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TrafficSign.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.osi3.TrafficSign();
            while (reader.pos < end) {
                let tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.id = $root.osi3.Identifier.decode(reader, reader.uint32());
                        break;
                    }
                case 2: {
                        message.mainSign = $root.osi3.TrafficSign.MainSign.decode(reader, reader.uint32());
                        break;
                    }
                case 3: {
                        if (!(message.supplementarySign && message.supplementarySign.length))
                            message.supplementarySign = [];
                        message.supplementarySign.push($root.osi3.TrafficSign.SupplementarySign.decode(reader, reader.uint32()));
                        break;
                    }
                case 4: {
                        if (!(message.sourceReference && message.sourceReference.length))
                            message.sourceReference = [];
                        message.sourceReference.push($root.osi3.ExternalReference.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TrafficSign message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof osi3.TrafficSign
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {osi3.TrafficSign} TrafficSign
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TrafficSign.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TrafficSign message.
         * @function verify
         * @memberof osi3.TrafficSign
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TrafficSign.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id")) {
                let error = $root.osi3.Identifier.verify(message.id);
                if (error)
                    return "id." + error;
            }
            if (message.mainSign != null && message.hasOwnProperty("mainSign")) {
                let error = $root.osi3.TrafficSign.MainSign.verify(message.mainSign);
                if (error)
                    return "mainSign." + error;
            }
            if (message.supplementarySign != null && message.hasOwnProperty("supplementarySign")) {
                if (!Array.isArray(message.supplementarySign))
                    return "supplementarySign: array expected";
                for (let i = 0; i < message.supplementarySign.length; ++i) {
                    let error = $root.osi3.TrafficSign.SupplementarySign.verify(message.supplementarySign[i]);
                    if (error)
                        return "supplementarySign." + error;
                }
            }
            if (message.sourceReference != null && message.hasOwnProperty("sourceReference")) {
                if (!Array.isArray(message.sourceReference))
                    return "sourceReference: array expected";
                for (let i = 0; i < message.sourceReference.length; ++i) {
                    let error = $root.osi3.ExternalReference.verify(message.sourceReference[i]);
                    if (error)
                        return "sourceReference." + error;
                }
            }
            return null;
        };

        /**
         * Creates a TrafficSign message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof osi3.TrafficSign
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {osi3.TrafficSign} TrafficSign
         */
        TrafficSign.fromObject = function fromObject(object) {
            if (object instanceof $root.osi3.TrafficSign)
                return object;
            let message = new $root.osi3.TrafficSign();
            if (object.id != null) {
                if (typeof object.id !== "object")
                    throw TypeError(".osi3.TrafficSign.id: object expected");
                message.id = $root.osi3.Identifier.fromObject(object.id);
            }
            if (object.mainSign != null) {
                if (typeof object.mainSign !== "object")
                    throw TypeError(".osi3.TrafficSign.mainSign: object expected");
                message.mainSign = $root.osi3.TrafficSign.MainSign.fromObject(object.mainSign);
            }
            if (object.supplementarySign) {
                if (!Array.isArray(object.supplementarySign))
                    throw TypeError(".osi3.TrafficSign.supplementarySign: array expected");
                message.supplementarySign = [];
                for (let i = 0; i < object.supplementarySign.length; ++i) {
                    if (typeof object.supplementarySign[i] !== "object")
                        throw TypeError(".osi3.TrafficSign.supplementarySign: object expected");
                    message.supplementarySign[i] = $root.osi3.TrafficSign.SupplementarySign.fromObject(object.supplementarySign[i]);
                }
            }
            if (object.sourceReference) {
                if (!Array.isArray(object.sourceReference))
                    throw TypeError(".osi3.TrafficSign.sourceReference: array expected");
                message.sourceReference = [];
                for (let i = 0; i < object.sourceReference.length; ++i) {
                    if (typeof object.sourceReference[i] !== "object")
                        throw TypeError(".osi3.TrafficSign.sourceReference: object expected");
                    message.sourceReference[i] = $root.osi3.ExternalReference.fromObject(object.sourceReference[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a TrafficSign message. Also converts values to other types if specified.
         * @function toObject
         * @memberof osi3.TrafficSign
         * @static
         * @param {osi3.TrafficSign} message TrafficSign
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TrafficSign.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.supplementarySign = [];
                object.sourceReference = [];
            }
            if (options.defaults) {
                object.id = null;
                object.mainSign = null;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = $root.osi3.Identifier.toObject(message.id, options);
            if (message.mainSign != null && message.hasOwnProperty("mainSign"))
                object.mainSign = $root.osi3.TrafficSign.MainSign.toObject(message.mainSign, options);
            if (message.supplementarySign && message.supplementarySign.length) {
                object.supplementarySign = [];
                for (let j = 0; j < message.supplementarySign.length; ++j)
                    object.supplementarySign[j] = $root.osi3.TrafficSign.SupplementarySign.toObject(message.supplementarySign[j], options);
            }
            if (message.sourceReference && message.sourceReference.length) {
                object.sourceReference = [];
                for (let j = 0; j < message.sourceReference.length; ++j)
                    object.sourceReference[j] = $root.osi3.ExternalReference.toObject(message.sourceReference[j], options);
            }
            return object;
        };

        /**
         * Converts this TrafficSign to JSON.
         * @function toJSON
         * @memberof osi3.TrafficSign
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TrafficSign.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for TrafficSign
         * @function getTypeUrl
         * @memberof osi3.TrafficSign
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TrafficSign.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/osi3.TrafficSign";
        };

        TrafficSign.MainSign = (function() {

            /**
             * Properties of a MainSign.
             * @memberof osi3.TrafficSign
             * @interface IMainSign
             * @property {osi3.IBaseStationary|null} [base] MainSign base
             * @property {osi3.TrafficSign.MainSign.IClassification|null} [classification] MainSign classification
             * @property {string|null} [modelReference] MainSign modelReference
             */

            /**
             * Constructs a new MainSign.
             * @memberof osi3.TrafficSign
             * @classdesc Represents a MainSign.
             * @implements IMainSign
             * @constructor
             * @param {osi3.TrafficSign.IMainSign=} [properties] Properties to set
             */
            function MainSign(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MainSign base.
             * @member {osi3.IBaseStationary|null|undefined} base
             * @memberof osi3.TrafficSign.MainSign
             * @instance
             */
            MainSign.prototype.base = null;

            /**
             * MainSign classification.
             * @member {osi3.TrafficSign.MainSign.IClassification|null|undefined} classification
             * @memberof osi3.TrafficSign.MainSign
             * @instance
             */
            MainSign.prototype.classification = null;

            /**
             * MainSign modelReference.
             * @member {string} modelReference
             * @memberof osi3.TrafficSign.MainSign
             * @instance
             */
            MainSign.prototype.modelReference = "";

            /**
             * Creates a new MainSign instance using the specified properties.
             * @function create
             * @memberof osi3.TrafficSign.MainSign
             * @static
             * @param {osi3.TrafficSign.IMainSign=} [properties] Properties to set
             * @returns {osi3.TrafficSign.MainSign} MainSign instance
             */
            MainSign.create = function create(properties) {
                return new MainSign(properties);
            };

            /**
             * Encodes the specified MainSign message. Does not implicitly {@link osi3.TrafficSign.MainSign.verify|verify} messages.
             * @function encode
             * @memberof osi3.TrafficSign.MainSign
             * @static
             * @param {osi3.TrafficSign.IMainSign} message MainSign message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MainSign.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.base != null && Object.hasOwnProperty.call(message, "base"))
                    $root.osi3.BaseStationary.encode(message.base, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.classification != null && Object.hasOwnProperty.call(message, "classification"))
                    $root.osi3.TrafficSign.MainSign.Classification.encode(message.classification, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.modelReference != null && Object.hasOwnProperty.call(message, "modelReference"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.modelReference);
                return writer;
            };

            /**
             * Encodes the specified MainSign message, length delimited. Does not implicitly {@link osi3.TrafficSign.MainSign.verify|verify} messages.
             * @function encodeDelimited
             * @memberof osi3.TrafficSign.MainSign
             * @static
             * @param {osi3.TrafficSign.IMainSign} message MainSign message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MainSign.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MainSign message from the specified reader or buffer.
             * @function decode
             * @memberof osi3.TrafficSign.MainSign
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {osi3.TrafficSign.MainSign} MainSign
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MainSign.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.osi3.TrafficSign.MainSign();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.base = $root.osi3.BaseStationary.decode(reader, reader.uint32());
                            break;
                        }
                    case 2: {
                            message.classification = $root.osi3.TrafficSign.MainSign.Classification.decode(reader, reader.uint32());
                            break;
                        }
                    case 3: {
                            message.modelReference = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MainSign message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof osi3.TrafficSign.MainSign
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {osi3.TrafficSign.MainSign} MainSign
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MainSign.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MainSign message.
             * @function verify
             * @memberof osi3.TrafficSign.MainSign
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MainSign.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.base != null && message.hasOwnProperty("base")) {
                    let error = $root.osi3.BaseStationary.verify(message.base);
                    if (error)
                        return "base." + error;
                }
                if (message.classification != null && message.hasOwnProperty("classification")) {
                    let error = $root.osi3.TrafficSign.MainSign.Classification.verify(message.classification);
                    if (error)
                        return "classification." + error;
                }
                if (message.modelReference != null && message.hasOwnProperty("modelReference"))
                    if (!$util.isString(message.modelReference))
                        return "modelReference: string expected";
                return null;
            };

            /**
             * Creates a MainSign message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof osi3.TrafficSign.MainSign
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {osi3.TrafficSign.MainSign} MainSign
             */
            MainSign.fromObject = function fromObject(object) {
                if (object instanceof $root.osi3.TrafficSign.MainSign)
                    return object;
                let message = new $root.osi3.TrafficSign.MainSign();
                if (object.base != null) {
                    if (typeof object.base !== "object")
                        throw TypeError(".osi3.TrafficSign.MainSign.base: object expected");
                    message.base = $root.osi3.BaseStationary.fromObject(object.base);
                }
                if (object.classification != null) {
                    if (typeof object.classification !== "object")
                        throw TypeError(".osi3.TrafficSign.MainSign.classification: object expected");
                    message.classification = $root.osi3.TrafficSign.MainSign.Classification.fromObject(object.classification);
                }
                if (object.modelReference != null)
                    message.modelReference = String(object.modelReference);
                return message;
            };

            /**
             * Creates a plain object from a MainSign message. Also converts values to other types if specified.
             * @function toObject
             * @memberof osi3.TrafficSign.MainSign
             * @static
             * @param {osi3.TrafficSign.MainSign} message MainSign
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MainSign.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.base = null;
                    object.classification = null;
                    object.modelReference = "";
                }
                if (message.base != null && message.hasOwnProperty("base"))
                    object.base = $root.osi3.BaseStationary.toObject(message.base, options);
                if (message.classification != null && message.hasOwnProperty("classification"))
                    object.classification = $root.osi3.TrafficSign.MainSign.Classification.toObject(message.classification, options);
                if (message.modelReference != null && message.hasOwnProperty("modelReference"))
                    object.modelReference = message.modelReference;
                return object;
            };

            /**
             * Converts this MainSign to JSON.
             * @function toJSON
             * @memberof osi3.TrafficSign.MainSign
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MainSign.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for MainSign
             * @function getTypeUrl
             * @memberof osi3.TrafficSign.MainSign
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            MainSign.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/osi3.TrafficSign.MainSign";
            };

            MainSign.Classification = (function() {

                /**
                 * Properties of a Classification.
                 * @memberof osi3.TrafficSign.MainSign
                 * @interface IClassification
                 * @property {osi3.TrafficSign.Variability|null} [variability] Classification variability
                 * @property {osi3.TrafficSign.MainSign.Classification.Type|null} [type] Classification type
                 * @property {osi3.ITrafficSignValue|null} [value] Classification value
                 * @property {osi3.TrafficSign.MainSign.Classification.DirectionScope|null} [directionScope] Classification directionScope
                 * @property {Array.<osi3.IIdentifier>|null} [assignedLaneId] Classification assignedLaneId
                 * @property {boolean|null} [verticallyMirrored] Classification verticallyMirrored
                 * @property {boolean|null} [isOutOfService] Classification isOutOfService
                 * @property {string|null} [country] Classification country
                 * @property {string|null} [countryRevision] Classification countryRevision
                 * @property {string|null} [code] Classification code
                 * @property {string|null} [subCode] Classification subCode
                 * @property {Array.<osi3.ILogicalLaneAssignment>|null} [logicalLaneAssignment] Classification logicalLaneAssignment
                 */

                /**
                 * Constructs a new Classification.
                 * @memberof osi3.TrafficSign.MainSign
                 * @classdesc Represents a Classification.
                 * @implements IClassification
                 * @constructor
                 * @param {osi3.TrafficSign.MainSign.IClassification=} [properties] Properties to set
                 */
                function Classification(properties) {
                    this.assignedLaneId = [];
                    this.logicalLaneAssignment = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Classification variability.
                 * @member {osi3.TrafficSign.Variability} variability
                 * @memberof osi3.TrafficSign.MainSign.Classification
                 * @instance
                 */
                Classification.prototype.variability = 0;

                /**
                 * Classification type.
                 * @member {osi3.TrafficSign.MainSign.Classification.Type} type
                 * @memberof osi3.TrafficSign.MainSign.Classification
                 * @instance
                 */
                Classification.prototype.type = 0;

                /**
                 * Classification value.
                 * @member {osi3.ITrafficSignValue|null|undefined} value
                 * @memberof osi3.TrafficSign.MainSign.Classification
                 * @instance
                 */
                Classification.prototype.value = null;

                /**
                 * Classification directionScope.
                 * @member {osi3.TrafficSign.MainSign.Classification.DirectionScope} directionScope
                 * @memberof osi3.TrafficSign.MainSign.Classification
                 * @instance
                 */
                Classification.prototype.directionScope = 0;

                /**
                 * Classification assignedLaneId.
                 * @member {Array.<osi3.IIdentifier>} assignedLaneId
                 * @memberof osi3.TrafficSign.MainSign.Classification
                 * @instance
                 */
                Classification.prototype.assignedLaneId = $util.emptyArray;

                /**
                 * Classification verticallyMirrored.
                 * @member {boolean} verticallyMirrored
                 * @memberof osi3.TrafficSign.MainSign.Classification
                 * @instance
                 */
                Classification.prototype.verticallyMirrored = false;

                /**
                 * Classification isOutOfService.
                 * @member {boolean} isOutOfService
                 * @memberof osi3.TrafficSign.MainSign.Classification
                 * @instance
                 */
                Classification.prototype.isOutOfService = false;

                /**
                 * Classification country.
                 * @member {string} country
                 * @memberof osi3.TrafficSign.MainSign.Classification
                 * @instance
                 */
                Classification.prototype.country = "";

                /**
                 * Classification countryRevision.
                 * @member {string} countryRevision
                 * @memberof osi3.TrafficSign.MainSign.Classification
                 * @instance
                 */
                Classification.prototype.countryRevision = "";

                /**
                 * Classification code.
                 * @member {string} code
                 * @memberof osi3.TrafficSign.MainSign.Classification
                 * @instance
                 */
                Classification.prototype.code = "";

                /**
                 * Classification subCode.
                 * @member {string} subCode
                 * @memberof osi3.TrafficSign.MainSign.Classification
                 * @instance
                 */
                Classification.prototype.subCode = "";

                /**
                 * Classification logicalLaneAssignment.
                 * @member {Array.<osi3.ILogicalLaneAssignment>} logicalLaneAssignment
                 * @memberof osi3.TrafficSign.MainSign.Classification
                 * @instance
                 */
                Classification.prototype.logicalLaneAssignment = $util.emptyArray;

                /**
                 * Creates a new Classification instance using the specified properties.
                 * @function create
                 * @memberof osi3.TrafficSign.MainSign.Classification
                 * @static
                 * @param {osi3.TrafficSign.MainSign.IClassification=} [properties] Properties to set
                 * @returns {osi3.TrafficSign.MainSign.Classification} Classification instance
                 */
                Classification.create = function create(properties) {
                    return new Classification(properties);
                };

                /**
                 * Encodes the specified Classification message. Does not implicitly {@link osi3.TrafficSign.MainSign.Classification.verify|verify} messages.
                 * @function encode
                 * @memberof osi3.TrafficSign.MainSign.Classification
                 * @static
                 * @param {osi3.TrafficSign.MainSign.IClassification} message Classification message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Classification.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.variability != null && Object.hasOwnProperty.call(message, "variability"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.variability);
                    if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
                    if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                        $root.osi3.TrafficSignValue.encode(message.value, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.directionScope != null && Object.hasOwnProperty.call(message, "directionScope"))
                        writer.uint32(/* id 4, wireType 0 =*/32).int32(message.directionScope);
                    if (message.assignedLaneId != null && message.assignedLaneId.length)
                        for (let i = 0; i < message.assignedLaneId.length; ++i)
                            $root.osi3.Identifier.encode(message.assignedLaneId[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.verticallyMirrored != null && Object.hasOwnProperty.call(message, "verticallyMirrored"))
                        writer.uint32(/* id 6, wireType 0 =*/48).bool(message.verticallyMirrored);
                    if (message.isOutOfService != null && Object.hasOwnProperty.call(message, "isOutOfService"))
                        writer.uint32(/* id 7, wireType 0 =*/56).bool(message.isOutOfService);
                    if (message.country != null && Object.hasOwnProperty.call(message, "country"))
                        writer.uint32(/* id 8, wireType 2 =*/66).string(message.country);
                    if (message.countryRevision != null && Object.hasOwnProperty.call(message, "countryRevision"))
                        writer.uint32(/* id 9, wireType 2 =*/74).string(message.countryRevision);
                    if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                        writer.uint32(/* id 10, wireType 2 =*/82).string(message.code);
                    if (message.subCode != null && Object.hasOwnProperty.call(message, "subCode"))
                        writer.uint32(/* id 11, wireType 2 =*/90).string(message.subCode);
                    if (message.logicalLaneAssignment != null && message.logicalLaneAssignment.length)
                        for (let i = 0; i < message.logicalLaneAssignment.length; ++i)
                            $root.osi3.LogicalLaneAssignment.encode(message.logicalLaneAssignment[i], writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified Classification message, length delimited. Does not implicitly {@link osi3.TrafficSign.MainSign.Classification.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof osi3.TrafficSign.MainSign.Classification
                 * @static
                 * @param {osi3.TrafficSign.MainSign.IClassification} message Classification message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Classification.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Classification message from the specified reader or buffer.
                 * @function decode
                 * @memberof osi3.TrafficSign.MainSign.Classification
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {osi3.TrafficSign.MainSign.Classification} Classification
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Classification.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.osi3.TrafficSign.MainSign.Classification();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                message.variability = reader.int32();
                                break;
                            }
                        case 2: {
                                message.type = reader.int32();
                                break;
                            }
                        case 3: {
                                message.value = $root.osi3.TrafficSignValue.decode(reader, reader.uint32());
                                break;
                            }
                        case 4: {
                                message.directionScope = reader.int32();
                                break;
                            }
                        case 5: {
                                if (!(message.assignedLaneId && message.assignedLaneId.length))
                                    message.assignedLaneId = [];
                                message.assignedLaneId.push($root.osi3.Identifier.decode(reader, reader.uint32()));
                                break;
                            }
                        case 6: {
                                message.verticallyMirrored = reader.bool();
                                break;
                            }
                        case 7: {
                                message.isOutOfService = reader.bool();
                                break;
                            }
                        case 8: {
                                message.country = reader.string();
                                break;
                            }
                        case 9: {
                                message.countryRevision = reader.string();
                                break;
                            }
                        case 10: {
                                message.code = reader.string();
                                break;
                            }
                        case 11: {
                                message.subCode = reader.string();
                                break;
                            }
                        case 12: {
                                if (!(message.logicalLaneAssignment && message.logicalLaneAssignment.length))
                                    message.logicalLaneAssignment = [];
                                message.logicalLaneAssignment.push($root.osi3.LogicalLaneAssignment.decode(reader, reader.uint32()));
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Classification message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof osi3.TrafficSign.MainSign.Classification
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {osi3.TrafficSign.MainSign.Classification} Classification
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Classification.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Classification message.
                 * @function verify
                 * @memberof osi3.TrafficSign.MainSign.Classification
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Classification.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.variability != null && message.hasOwnProperty("variability"))
                        switch (message.variability) {
                        default:
                            return "variability: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                            break;
                        }
                    if (message.type != null && message.hasOwnProperty("type"))
                        switch (message.type) {
                        default:
                            return "type: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 87:
                        case 110:
                        case 200:
                        case 197:
                        case 188:
                        case 96:
                        case 94:
                        case 97:
                        case 102:
                        case 210:
                        case 101:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                        case 7:
                        case 8:
                        case 9:
                        case 93:
                        case 95:
                        case 98:
                        case 10:
                        case 12:
                        case 11:
                        case 13:
                        case 100:
                        case 14:
                        case 15:
                        case 103:
                        case 106:
                        case 107:
                        case 109:
                        case 144:
                        case 112:
                        case 135:
                        case 16:
                        case 17:
                        case 18:
                        case 19:
                        case 20:
                        case 21:
                        case 22:
                        case 24:
                        case 23:
                        case 26:
                        case 25:
                        case 27:
                        case 28:
                        case 29:
                        case 30:
                        case 31:
                        case 32:
                        case 33:
                        case 128:
                        case 129:
                        case 130:
                        case 137:
                        case 138:
                        case 145:
                        case 146:
                        case 147:
                        case 148:
                        case 149:
                        case 150:
                        case 151:
                        case 152:
                        case 153:
                        case 154:
                        case 34:
                        case 35:
                        case 36:
                        case 37:
                        case 38:
                        case 39:
                        case 40:
                        case 41:
                        case 155:
                        case 156:
                        case 157:
                        case 158:
                        case 159:
                        case 160:
                        case 161:
                        case 162:
                        case 163:
                        case 42:
                        case 43:
                        case 164:
                        case 165:
                        case 166:
                        case 167:
                        case 168:
                        case 169:
                        case 44:
                        case 170:
                        case 171:
                        case 45:
                        case 46:
                        case 47:
                        case 48:
                        case 49:
                        case 50:
                        case 51:
                        case 52:
                        case 53:
                        case 54:
                        case 55:
                        case 56:
                        case 57:
                        case 58:
                        case 59:
                        case 60:
                        case 61:
                        case 62:
                        case 63:
                        case 64:
                        case 65:
                        case 66:
                        case 67:
                        case 68:
                        case 69:
                        case 70:
                        case 71:
                        case 72:
                        case 73:
                        case 74:
                        case 75:
                        case 76:
                        case 172:
                        case 173:
                        case 174:
                        case 175:
                        case 176:
                        case 177:
                        case 178:
                        case 179:
                        case 77:
                        case 78:
                        case 79:
                        case 80:
                        case 81:
                        case 82:
                        case 83:
                        case 84:
                        case 85:
                        case 183:
                        case 184:
                        case 185:
                        case 86:
                        case 186:
                        case 187:
                        case 189:
                        case 190:
                        case 191:
                        case 194:
                        case 195:
                        case 196:
                        case 198:
                        case 201:
                        case 202:
                        case 203:
                        case 204:
                        case 205:
                        case 206:
                        case 207:
                        case 208:
                        case 209:
                        case 213:
                        case 214:
                        case 215:
                        case 216:
                        case 217:
                        case 218:
                        case 219:
                        case 220:
                        case 221:
                        case 222:
                        case 223:
                        case 224:
                        case 225:
                        case 226:
                        case 227:
                        case 228:
                        case 229:
                        case 230:
                        case 231:
                        case 232:
                        case 233:
                        case 234:
                        case 235:
                        case 236:
                        case 237:
                        case 238:
                        case 239:
                        case 240:
                        case 143:
                        case 108:
                        case 127:
                        case 136:
                        case 118:
                        case 119:
                        case 120:
                        case 121:
                        case 122:
                        case 123:
                        case 124:
                        case 125:
                        case 126:
                        case 88:
                        case 180:
                        case 181:
                        case 182:
                        case 131:
                        case 132:
                        case 133:
                        case 134:
                        case 111:
                        case 199:
                        case 211:
                        case 212:
                        case 192:
                        case 193:
                        case 90:
                        case 89:
                        case 115:
                        case 116:
                        case 117:
                        case 142:
                        case 141:
                        case 91:
                        case 140:
                        case 139:
                        case 114:
                        case 113:
                        case 104:
                        case 105:
                        case 99:
                        case 92:
                            break;
                        }
                    if (message.value != null && message.hasOwnProperty("value")) {
                        let error = $root.osi3.TrafficSignValue.verify(message.value);
                        if (error)
                            return "value." + error;
                    }
                    if (message.directionScope != null && message.hasOwnProperty("directionScope"))
                        switch (message.directionScope) {
                        default:
                            return "directionScope: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                            break;
                        }
                    if (message.assignedLaneId != null && message.hasOwnProperty("assignedLaneId")) {
                        if (!Array.isArray(message.assignedLaneId))
                            return "assignedLaneId: array expected";
                        for (let i = 0; i < message.assignedLaneId.length; ++i) {
                            let error = $root.osi3.Identifier.verify(message.assignedLaneId[i]);
                            if (error)
                                return "assignedLaneId." + error;
                        }
                    }
                    if (message.verticallyMirrored != null && message.hasOwnProperty("verticallyMirrored"))
                        if (typeof message.verticallyMirrored !== "boolean")
                            return "verticallyMirrored: boolean expected";
                    if (message.isOutOfService != null && message.hasOwnProperty("isOutOfService"))
                        if (typeof message.isOutOfService !== "boolean")
                            return "isOutOfService: boolean expected";
                    if (message.country != null && message.hasOwnProperty("country"))
                        if (!$util.isString(message.country))
                            return "country: string expected";
                    if (message.countryRevision != null && message.hasOwnProperty("countryRevision"))
                        if (!$util.isString(message.countryRevision))
                            return "countryRevision: string expected";
                    if (message.code != null && message.hasOwnProperty("code"))
                        if (!$util.isString(message.code))
                            return "code: string expected";
                    if (message.subCode != null && message.hasOwnProperty("subCode"))
                        if (!$util.isString(message.subCode))
                            return "subCode: string expected";
                    if (message.logicalLaneAssignment != null && message.hasOwnProperty("logicalLaneAssignment")) {
                        if (!Array.isArray(message.logicalLaneAssignment))
                            return "logicalLaneAssignment: array expected";
                        for (let i = 0; i < message.logicalLaneAssignment.length; ++i) {
                            let error = $root.osi3.LogicalLaneAssignment.verify(message.logicalLaneAssignment[i]);
                            if (error)
                                return "logicalLaneAssignment." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a Classification message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof osi3.TrafficSign.MainSign.Classification
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {osi3.TrafficSign.MainSign.Classification} Classification
                 */
                Classification.fromObject = function fromObject(object) {
                    if (object instanceof $root.osi3.TrafficSign.MainSign.Classification)
                        return object;
                    let message = new $root.osi3.TrafficSign.MainSign.Classification();
                    switch (object.variability) {
                    default:
                        if (typeof object.variability === "number") {
                            message.variability = object.variability;
                            break;
                        }
                        break;
                    case "VARIABILITY_UNKNOWN":
                    case 0:
                        message.variability = 0;
                        break;
                    case "VARIABILITY_OTHER":
                    case 1:
                        message.variability = 1;
                        break;
                    case "VARIABILITY_FIXED":
                    case 2:
                        message.variability = 2;
                        break;
                    case "VARIABILITY_VARIABLE":
                    case 3:
                        message.variability = 3;
                        break;
                    case "VARIABILITY_MOVABLE":
                    case 4:
                        message.variability = 4;
                        break;
                    case "VARIABILITY_MUTABLE":
                    case 5:
                        message.variability = 5;
                        break;
                    case "VARIABILITY_MOVABLE_AND_MUTABLE":
                    case 6:
                        message.variability = 6;
                        break;
                    }
                    switch (object.type) {
                    default:
                        if (typeof object.type === "number") {
                            message.type = object.type;
                            break;
                        }
                        break;
                    case "TYPE_UNKNOWN":
                    case 0:
                        message.type = 0;
                        break;
                    case "TYPE_OTHER":
                    case 1:
                        message.type = 1;
                        break;
                    case "TYPE_DANGER_SPOT":
                    case 2:
                        message.type = 2;
                        break;
                    case "TYPE_ZEBRA_CROSSING":
                    case 87:
                        message.type = 87;
                        break;
                    case "TYPE_FLIGHT":
                    case 110:
                        message.type = 110;
                        break;
                    case "TYPE_CATTLE":
                    case 200:
                        message.type = 200;
                        break;
                    case "TYPE_HORSE_RIDERS":
                    case 197:
                        message.type = 197;
                        break;
                    case "TYPE_AMPHIBIANS":
                    case 188:
                        message.type = 188;
                        break;
                    case "TYPE_FALLING_ROCKS":
                    case 96:
                        message.type = 96;
                        break;
                    case "TYPE_SNOW_OR_ICE":
                    case 94:
                        message.type = 94;
                        break;
                    case "TYPE_LOOSE_GRAVEL":
                    case 97:
                        message.type = 97;
                        break;
                    case "TYPE_WATERSIDE":
                    case 102:
                        message.type = 102;
                        break;
                    case "TYPE_CLEARANCE":
                    case 210:
                        message.type = 210;
                        break;
                    case "TYPE_MOVABLE_BRIDGE":
                    case 101:
                        message.type = 101;
                        break;
                    case "TYPE_RIGHT_BEFORE_LEFT_NEXT_INTERSECTION":
                    case 3:
                        message.type = 3;
                        break;
                    case "TYPE_TURN_LEFT":
                    case 4:
                        message.type = 4;
                        break;
                    case "TYPE_TURN_RIGHT":
                    case 5:
                        message.type = 5;
                        break;
                    case "TYPE_DOUBLE_TURN_LEFT":
                    case 6:
                        message.type = 6;
                        break;
                    case "TYPE_DOUBLE_TURN_RIGHT":
                    case 7:
                        message.type = 7;
                        break;
                    case "TYPE_HILL_DOWNWARDS":
                    case 8:
                        message.type = 8;
                        break;
                    case "TYPE_HILL_UPWARDS":
                    case 9:
                        message.type = 9;
                        break;
                    case "TYPE_UNEVEN_ROAD":
                    case 93:
                        message.type = 93;
                        break;
                    case "TYPE_ROAD_SLIPPERY_WET_OR_DIRTY":
                    case 95:
                        message.type = 95;
                        break;
                    case "TYPE_SIDE_WINDS":
                    case 98:
                        message.type = 98;
                        break;
                    case "TYPE_ROAD_NARROWING":
                    case 10:
                        message.type = 10;
                        break;
                    case "TYPE_ROAD_NARROWING_RIGHT":
                    case 12:
                        message.type = 12;
                        break;
                    case "TYPE_ROAD_NARROWING_LEFT":
                    case 11:
                        message.type = 11;
                        break;
                    case "TYPE_ROAD_WORKS":
                    case 13:
                        message.type = 13;
                        break;
                    case "TYPE_TRAFFIC_QUEUES":
                    case 100:
                        message.type = 100;
                        break;
                    case "TYPE_TWO_WAY_TRAFFIC":
                    case 14:
                        message.type = 14;
                        break;
                    case "TYPE_ATTENTION_TRAFFIC_LIGHT":
                    case 15:
                        message.type = 15;
                        break;
                    case "TYPE_PEDESTRIANS":
                    case 103:
                        message.type = 103;
                        break;
                    case "TYPE_CHILDREN_CROSSING":
                    case 106:
                        message.type = 106;
                        break;
                    case "TYPE_CYCLE_ROUTE":
                    case 107:
                        message.type = 107;
                        break;
                    case "TYPE_DEER_CROSSING":
                    case 109:
                        message.type = 109;
                        break;
                    case "TYPE_UNGATED_LEVEL_CROSSING":
                    case 144:
                        message.type = 144;
                        break;
                    case "TYPE_LEVEL_CROSSING_MARKER":
                    case 112:
                        message.type = 112;
                        break;
                    case "TYPE_RAILWAY_TRAFFIC_PRIORITY":
                    case 135:
                        message.type = 135;
                        break;
                    case "TYPE_GIVE_WAY":
                    case 16:
                        message.type = 16;
                        break;
                    case "TYPE_STOP":
                    case 17:
                        message.type = 17;
                        break;
                    case "TYPE_PRIORITY_TO_OPPOSITE_DIRECTION":
                    case 18:
                        message.type = 18;
                        break;
                    case "TYPE_PRIORITY_TO_OPPOSITE_DIRECTION_UPSIDE_DOWN":
                    case 19:
                        message.type = 19;
                        break;
                    case "TYPE_PRESCRIBED_LEFT_TURN":
                    case 20:
                        message.type = 20;
                        break;
                    case "TYPE_PRESCRIBED_RIGHT_TURN":
                    case 21:
                        message.type = 21;
                        break;
                    case "TYPE_PRESCRIBED_STRAIGHT":
                    case 22:
                        message.type = 22;
                        break;
                    case "TYPE_PRESCRIBED_RIGHT_WAY":
                    case 24:
                        message.type = 24;
                        break;
                    case "TYPE_PRESCRIBED_LEFT_WAY":
                    case 23:
                        message.type = 23;
                        break;
                    case "TYPE_PRESCRIBED_RIGHT_TURN_AND_STRAIGHT":
                    case 26:
                        message.type = 26;
                        break;
                    case "TYPE_PRESCRIBED_LEFT_TURN_AND_STRAIGHT":
                    case 25:
                        message.type = 25;
                        break;
                    case "TYPE_PRESCRIBED_LEFT_TURN_AND_RIGHT_TURN":
                    case 27:
                        message.type = 27;
                        break;
                    case "TYPE_PRESCRIBED_LEFT_TURN_RIGHT_TURN_AND_STRAIGHT":
                    case 28:
                        message.type = 28;
                        break;
                    case "TYPE_ROUNDABOUT":
                    case 29:
                        message.type = 29;
                        break;
                    case "TYPE_ONEWAY_LEFT":
                    case 30:
                        message.type = 30;
                        break;
                    case "TYPE_ONEWAY_RIGHT":
                    case 31:
                        message.type = 31;
                        break;
                    case "TYPE_PASS_LEFT":
                    case 32:
                        message.type = 32;
                        break;
                    case "TYPE_PASS_RIGHT":
                    case 33:
                        message.type = 33;
                        break;
                    case "TYPE_SIDE_LANE_OPEN_FOR_TRAFFIC":
                    case 128:
                        message.type = 128;
                        break;
                    case "TYPE_SIDE_LANE_CLOSED_FOR_TRAFFIC":
                    case 129:
                        message.type = 129;
                        break;
                    case "TYPE_SIDE_LANE_CLOSING_FOR_TRAFFIC":
                    case 130:
                        message.type = 130;
                        break;
                    case "TYPE_BUS_STOP":
                    case 137:
                        message.type = 137;
                        break;
                    case "TYPE_TAXI_STAND":
                    case 138:
                        message.type = 138;
                        break;
                    case "TYPE_BICYCLES_ONLY":
                    case 145:
                        message.type = 145;
                        break;
                    case "TYPE_HORSE_RIDERS_ONLY":
                    case 146:
                        message.type = 146;
                        break;
                    case "TYPE_PEDESTRIANS_ONLY":
                    case 147:
                        message.type = 147;
                        break;
                    case "TYPE_BICYCLES_PEDESTRIANS_SHARED_ONLY":
                    case 148:
                        message.type = 148;
                        break;
                    case "TYPE_BICYCLES_PEDESTRIANS_SEPARATED_LEFT_ONLY":
                    case 149:
                        message.type = 149;
                        break;
                    case "TYPE_BICYCLES_PEDESTRIANS_SEPARATED_RIGHT_ONLY":
                    case 150:
                        message.type = 150;
                        break;
                    case "TYPE_PEDESTRIAN_ZONE_BEGIN":
                    case 151:
                        message.type = 151;
                        break;
                    case "TYPE_PEDESTRIAN_ZONE_END":
                    case 152:
                        message.type = 152;
                        break;
                    case "TYPE_BICYCLE_ROAD_BEGIN":
                    case 153:
                        message.type = 153;
                        break;
                    case "TYPE_BICYCLE_ROAD_END":
                    case 154:
                        message.type = 154;
                        break;
                    case "TYPE_BUS_LANE":
                    case 34:
                        message.type = 34;
                        break;
                    case "TYPE_BUS_LANE_BEGIN":
                    case 35:
                        message.type = 35;
                        break;
                    case "TYPE_BUS_LANE_END":
                    case 36:
                        message.type = 36;
                        break;
                    case "TYPE_ALL_PROHIBITED":
                    case 37:
                        message.type = 37;
                        break;
                    case "TYPE_MOTORIZED_MULTITRACK_PROHIBITED":
                    case 38:
                        message.type = 38;
                        break;
                    case "TYPE_TRUCKS_PROHIBITED":
                    case 39:
                        message.type = 39;
                        break;
                    case "TYPE_BICYCLES_PROHIBITED":
                    case 40:
                        message.type = 40;
                        break;
                    case "TYPE_MOTORCYCLES_PROHIBITED":
                    case 41:
                        message.type = 41;
                        break;
                    case "TYPE_MOPEDS_PROHIBITED":
                    case 155:
                        message.type = 155;
                        break;
                    case "TYPE_HORSE_RIDERS_PROHIBITED":
                    case 156:
                        message.type = 156;
                        break;
                    case "TYPE_HORSE_CARRIAGES_PROHIBITED":
                    case 157:
                        message.type = 157;
                        break;
                    case "TYPE_CATTLE_PROHIBITED":
                    case 158:
                        message.type = 158;
                        break;
                    case "TYPE_BUSES_PROHIBITED":
                    case 159:
                        message.type = 159;
                        break;
                    case "TYPE_CARS_PROHIBITED":
                    case 160:
                        message.type = 160;
                        break;
                    case "TYPE_CARS_TRAILERS_PROHIBITED":
                    case 161:
                        message.type = 161;
                        break;
                    case "TYPE_TRUCKS_TRAILERS_PROHIBITED":
                    case 162:
                        message.type = 162;
                        break;
                    case "TYPE_TRACTORS_PROHIBITED":
                    case 163:
                        message.type = 163;
                        break;
                    case "TYPE_PEDESTRIANS_PROHIBITED":
                    case 42:
                        message.type = 42;
                        break;
                    case "TYPE_MOTOR_VEHICLES_PROHIBITED":
                    case 43:
                        message.type = 43;
                        break;
                    case "TYPE_HAZARDOUS_GOODS_VEHICLES_PROHIBITED":
                    case 164:
                        message.type = 164;
                        break;
                    case "TYPE_OVER_WEIGHT_VEHICLES_PROHIBITED":
                    case 165:
                        message.type = 165;
                        break;
                    case "TYPE_VEHICLES_AXLE_OVER_WEIGHT_PROHIBITED":
                    case 166:
                        message.type = 166;
                        break;
                    case "TYPE_VEHICLES_EXCESS_WIDTH_PROHIBITED":
                    case 167:
                        message.type = 167;
                        break;
                    case "TYPE_VEHICLES_EXCESS_HEIGHT_PROHIBITED":
                    case 168:
                        message.type = 168;
                        break;
                    case "TYPE_VEHICLES_EXCESS_LENGTH_PROHIBITED":
                    case 169:
                        message.type = 169;
                        break;
                    case "TYPE_DO_NOT_ENTER":
                    case 44:
                        message.type = 44;
                        break;
                    case "TYPE_SNOW_CHAINS_REQUIRED":
                    case 170:
                        message.type = 170;
                        break;
                    case "TYPE_WATER_POLLUTANT_VEHICLES_PROHIBITED":
                    case 171:
                        message.type = 171;
                        break;
                    case "TYPE_ENVIRONMENTAL_ZONE_BEGIN":
                    case 45:
                        message.type = 45;
                        break;
                    case "TYPE_ENVIRONMENTAL_ZONE_END":
                    case 46:
                        message.type = 46;
                        break;
                    case "TYPE_NO_U_TURN_LEFT":
                    case 47:
                        message.type = 47;
                        break;
                    case "TYPE_NO_U_TURN_RIGHT":
                    case 48:
                        message.type = 48;
                        break;
                    case "TYPE_PRESCRIBED_U_TURN_LEFT":
                    case 49:
                        message.type = 49;
                        break;
                    case "TYPE_PRESCRIBED_U_TURN_RIGHT":
                    case 50:
                        message.type = 50;
                        break;
                    case "TYPE_MINIMUM_DISTANCE_FOR_TRUCKS":
                    case 51:
                        message.type = 51;
                        break;
                    case "TYPE_SPEED_LIMIT_BEGIN":
                    case 52:
                        message.type = 52;
                        break;
                    case "TYPE_SPEED_LIMIT_ZONE_BEGIN":
                    case 53:
                        message.type = 53;
                        break;
                    case "TYPE_SPEED_LIMIT_ZONE_END":
                    case 54:
                        message.type = 54;
                        break;
                    case "TYPE_MINIMUM_SPEED_BEGIN":
                    case 55:
                        message.type = 55;
                        break;
                    case "TYPE_OVERTAKING_BAN_BEGIN":
                    case 56:
                        message.type = 56;
                        break;
                    case "TYPE_OVERTAKING_BAN_FOR_TRUCKS_BEGIN":
                    case 57:
                        message.type = 57;
                        break;
                    case "TYPE_SPEED_LIMIT_END":
                    case 58:
                        message.type = 58;
                        break;
                    case "TYPE_MINIMUM_SPEED_END":
                    case 59:
                        message.type = 59;
                        break;
                    case "TYPE_OVERTAKING_BAN_END":
                    case 60:
                        message.type = 60;
                        break;
                    case "TYPE_OVERTAKING_BAN_FOR_TRUCKS_END":
                    case 61:
                        message.type = 61;
                        break;
                    case "TYPE_ALL_RESTRICTIONS_END":
                    case 62:
                        message.type = 62;
                        break;
                    case "TYPE_NO_STOPPING":
                    case 63:
                        message.type = 63;
                        break;
                    case "TYPE_NO_PARKING":
                    case 64:
                        message.type = 64;
                        break;
                    case "TYPE_NO_PARKING_ZONE_BEGIN":
                    case 65:
                        message.type = 65;
                        break;
                    case "TYPE_NO_PARKING_ZONE_END":
                    case 66:
                        message.type = 66;
                        break;
                    case "TYPE_RIGHT_OF_WAY_NEXT_INTERSECTION":
                    case 67:
                        message.type = 67;
                        break;
                    case "TYPE_RIGHT_OF_WAY_BEGIN":
                    case 68:
                        message.type = 68;
                        break;
                    case "TYPE_RIGHT_OF_WAY_END":
                    case 69:
                        message.type = 69;
                        break;
                    case "TYPE_PRIORITY_OVER_OPPOSITE_DIRECTION":
                    case 70:
                        message.type = 70;
                        break;
                    case "TYPE_PRIORITY_OVER_OPPOSITE_DIRECTION_UPSIDE_DOWN":
                    case 71:
                        message.type = 71;
                        break;
                    case "TYPE_TOWN_BEGIN":
                    case 72:
                        message.type = 72;
                        break;
                    case "TYPE_TOWN_END":
                    case 73:
                        message.type = 73;
                        break;
                    case "TYPE_CAR_PARKING":
                    case 74:
                        message.type = 74;
                        break;
                    case "TYPE_CAR_PARKING_ZONE_BEGIN":
                    case 75:
                        message.type = 75;
                        break;
                    case "TYPE_CAR_PARKING_ZONE_END":
                    case 76:
                        message.type = 76;
                        break;
                    case "TYPE_SIDEWALK_HALF_PARKING_LEFT":
                    case 172:
                        message.type = 172;
                        break;
                    case "TYPE_SIDEWALK_HALF_PARKING_RIGHT":
                    case 173:
                        message.type = 173;
                        break;
                    case "TYPE_SIDEWALK_PARKING_LEFT":
                    case 174:
                        message.type = 174;
                        break;
                    case "TYPE_SIDEWALK_PARKING_RIGHT":
                    case 175:
                        message.type = 175;
                        break;
                    case "TYPE_SIDEWALK_PERPENDICULAR_HALF_PARKING_LEFT":
                    case 176:
                        message.type = 176;
                        break;
                    case "TYPE_SIDEWALK_PERPENDICULAR_HALF_PARKING_RIGHT":
                    case 177:
                        message.type = 177;
                        break;
                    case "TYPE_SIDEWALK_PERPENDICULAR_PARKING_LEFT":
                    case 178:
                        message.type = 178;
                        break;
                    case "TYPE_SIDEWALK_PERPENDICULAR_PARKING_RIGHT":
                    case 179:
                        message.type = 179;
                        break;
                    case "TYPE_LIVING_STREET_BEGIN":
                    case 77:
                        message.type = 77;
                        break;
                    case "TYPE_LIVING_STREET_END":
                    case 78:
                        message.type = 78;
                        break;
                    case "TYPE_TUNNEL":
                    case 79:
                        message.type = 79;
                        break;
                    case "TYPE_EMERGENCY_STOPPING_LEFT":
                    case 80:
                        message.type = 80;
                        break;
                    case "TYPE_EMERGENCY_STOPPING_RIGHT":
                    case 81:
                        message.type = 81;
                        break;
                    case "TYPE_HIGHWAY_BEGIN":
                    case 82:
                        message.type = 82;
                        break;
                    case "TYPE_HIGHWAY_END":
                    case 83:
                        message.type = 83;
                        break;
                    case "TYPE_EXPRESSWAY_BEGIN":
                    case 84:
                        message.type = 84;
                        break;
                    case "TYPE_EXPRESSWAY_END":
                    case 85:
                        message.type = 85;
                        break;
                    case "TYPE_NAMED_HIGHWAY_EXIT":
                    case 183:
                        message.type = 183;
                        break;
                    case "TYPE_NAMED_EXPRESSWAY_EXIT":
                    case 184:
                        message.type = 184;
                        break;
                    case "TYPE_NAMED_ROAD_EXIT":
                    case 185:
                        message.type = 185;
                        break;
                    case "TYPE_HIGHWAY_EXIT":
                    case 86:
                        message.type = 86;
                        break;
                    case "TYPE_EXPRESSWAY_EXIT":
                    case 186:
                        message.type = 186;
                        break;
                    case "TYPE_ONEWAY_STREET":
                    case 187:
                        message.type = 187;
                        break;
                    case "TYPE_CROSSING_GUARDS":
                    case 189:
                        message.type = 189;
                        break;
                    case "TYPE_DEADEND":
                    case 190:
                        message.type = 190;
                        break;
                    case "TYPE_DEADEND_EXCLUDING_DESIGNATED_ACTORS":
                    case 191:
                        message.type = 191;
                        break;
                    case "TYPE_FIRST_AID_STATION":
                    case 194:
                        message.type = 194;
                        break;
                    case "TYPE_POLICE_STATION":
                    case 195:
                        message.type = 195;
                        break;
                    case "TYPE_TELEPHONE":
                    case 196:
                        message.type = 196;
                        break;
                    case "TYPE_FILLING_STATION":
                    case 198:
                        message.type = 198;
                        break;
                    case "TYPE_HOTEL":
                    case 201:
                        message.type = 201;
                        break;
                    case "TYPE_INN":
                    case 202:
                        message.type = 202;
                        break;
                    case "TYPE_KIOSK":
                    case 203:
                        message.type = 203;
                        break;
                    case "TYPE_TOILET":
                    case 204:
                        message.type = 204;
                        break;
                    case "TYPE_CHAPEL":
                    case 205:
                        message.type = 205;
                        break;
                    case "TYPE_TOURIST_INFO":
                    case 206:
                        message.type = 206;
                        break;
                    case "TYPE_REPAIR_SERVICE":
                    case 207:
                        message.type = 207;
                        break;
                    case "TYPE_PEDESTRIAN_UNDERPASS":
                    case 208:
                        message.type = 208;
                        break;
                    case "TYPE_PEDESTRIAN_BRIDGE":
                    case 209:
                        message.type = 209;
                        break;
                    case "TYPE_CAMPER_PLACE":
                    case 213:
                        message.type = 213;
                        break;
                    case "TYPE_ADVISORY_SPEED_LIMIT_BEGIN":
                    case 214:
                        message.type = 214;
                        break;
                    case "TYPE_ADVISORY_SPEED_LIMIT_END":
                    case 215:
                        message.type = 215;
                        break;
                    case "TYPE_PLACE_NAME":
                    case 216:
                        message.type = 216;
                        break;
                    case "TYPE_TOURIST_ATTRACTION":
                    case 217:
                        message.type = 217;
                        break;
                    case "TYPE_TOURIST_ROUTE":
                    case 218:
                        message.type = 218;
                        break;
                    case "TYPE_TOURIST_AREA":
                    case 219:
                        message.type = 219;
                        break;
                    case "TYPE_SHOULDER_NOT_PASSABLE_MOTOR_VEHICLES":
                    case 220:
                        message.type = 220;
                        break;
                    case "TYPE_SHOULDER_UNSAFE_TRUCKS_TRACTORS":
                    case 221:
                        message.type = 221;
                        break;
                    case "TYPE_TOLL_BEGIN":
                    case 222:
                        message.type = 222;
                        break;
                    case "TYPE_TOLL_END":
                    case 223:
                        message.type = 223;
                        break;
                    case "TYPE_TOLL_ROAD":
                    case 224:
                        message.type = 224;
                        break;
                    case "TYPE_CUSTOMS":
                    case 225:
                        message.type = 225;
                        break;
                    case "TYPE_INTERNATIONAL_BORDER_INFO":
                    case 226:
                        message.type = 226;
                        break;
                    case "TYPE_STREETLIGHT_RED_BAND":
                    case 227:
                        message.type = 227;
                        break;
                    case "TYPE_FEDERAL_HIGHWAY_ROUTE_NUMBER":
                    case 228:
                        message.type = 228;
                        break;
                    case "TYPE_HIGHWAY_ROUTE_NUMBER":
                    case 229:
                        message.type = 229;
                        break;
                    case "TYPE_HIGHWAY_INTERCHANGE_NUMBER":
                    case 230:
                        message.type = 230;
                        break;
                    case "TYPE_EUROPEAN_ROUTE_NUMBER":
                    case 231:
                        message.type = 231;
                        break;
                    case "TYPE_FEDERAL_HIGHWAY_DIRECTION_LEFT":
                    case 232:
                        message.type = 232;
                        break;
                    case "TYPE_FEDERAL_HIGHWAY_DIRECTION_RIGHT":
                    case 233:
                        message.type = 233;
                        break;
                    case "TYPE_PRIMARY_ROAD_DIRECTION_LEFT":
                    case 234:
                        message.type = 234;
                        break;
                    case "TYPE_PRIMARY_ROAD_DIRECTION_RIGHT":
                    case 235:
                        message.type = 235;
                        break;
                    case "TYPE_SECONDARY_ROAD_DIRECTION_LEFT":
                    case 236:
                        message.type = 236;
                        break;
                    case "TYPE_SECONDARY_ROAD_DIRECTION_RIGHT":
                    case 237:
                        message.type = 237;
                        break;
                    case "TYPE_DIRECTION_DESIGNATED_ACTORS_LEFT":
                    case 238:
                        message.type = 238;
                        break;
                    case "TYPE_DIRECTION_DESIGNATED_ACTORS_RIGHT":
                    case 239:
                        message.type = 239;
                        break;
                    case "TYPE_ROUTING_DESIGNATED_ACTORS":
                    case 240:
                        message.type = 240;
                        break;
                    case "TYPE_DIRECTION_TO_HIGHWAY_LEFT":
                    case 143:
                        message.type = 143;
                        break;
                    case "TYPE_DIRECTION_TO_HIGHWAY_RIGHT":
                    case 108:
                        message.type = 108;
                        break;
                    case "TYPE_DIRECTION_TO_LOCAL_DESTINATION_LEFT":
                    case 127:
                        message.type = 127;
                        break;
                    case "TYPE_DIRECTION_TO_LOCAL_DESTINATION_RIGHT":
                    case 136:
                        message.type = 136;
                        break;
                    case "TYPE_CONSOLIDATED_DIRECTIONS":
                    case 118:
                        message.type = 118;
                        break;
                    case "TYPE_STREET_NAME":
                    case 119:
                        message.type = 119;
                        break;
                    case "TYPE_DIRECTION_PREANNOUNCEMENT":
                    case 120:
                        message.type = 120;
                        break;
                    case "TYPE_DIRECTION_PREANNOUNCEMENT_LANE_CONFIG":
                    case 121:
                        message.type = 121;
                        break;
                    case "TYPE_DIRECTION_PREANNOUNCEMENT_HIGHWAY_ENTRIES":
                    case 122:
                        message.type = 122;
                        break;
                    case "TYPE_HIGHWAY_ANNOUNCEMENT":
                    case 123:
                        message.type = 123;
                        break;
                    case "TYPE_OTHER_ROAD_ANNOUNCEMENT":
                    case 124:
                        message.type = 124;
                        break;
                    case "TYPE_HIGHWAY_ANNOUNCEMENT_TRUCK_STOP":
                    case 125:
                        message.type = 125;
                        break;
                    case "TYPE_HIGHWAY_PREANNOUNCEMENT_DIRECTIONS":
                    case 126:
                        message.type = 126;
                        break;
                    case "TYPE_POLE_EXIT":
                    case 88:
                        message.type = 88;
                        break;
                    case "TYPE_HIGHWAY_DISTANCE_BOARD":
                    case 180:
                        message.type = 180;
                        break;
                    case "TYPE_DETOUR_LEFT":
                    case 181:
                        message.type = 181;
                        break;
                    case "TYPE_DETOUR_RIGHT":
                    case 182:
                        message.type = 182;
                        break;
                    case "TYPE_NUMBERED_DETOUR":
                    case 131:
                        message.type = 131;
                        break;
                    case "TYPE_DETOUR_BEGIN":
                    case 132:
                        message.type = 132;
                        break;
                    case "TYPE_DETOUR_END":
                    case 133:
                        message.type = 133;
                        break;
                    case "TYPE_DETOUR_ROUTING_BOARD":
                    case 134:
                        message.type = 134;
                        break;
                    case "TYPE_OPTIONAL_DETOUR":
                    case 111:
                        message.type = 111;
                        break;
                    case "TYPE_OPTIONAL_DETOUR_ROUTING":
                    case 199:
                        message.type = 199;
                        break;
                    case "TYPE_ROUTE_RECOMMENDATION":
                    case 211:
                        message.type = 211;
                        break;
                    case "TYPE_ROUTE_RECOMMENDATION_END":
                    case 212:
                        message.type = 212;
                        break;
                    case "TYPE_ANNOUNCE_LANE_TRANSITION_LEFT":
                    case 192:
                        message.type = 192;
                        break;
                    case "TYPE_ANNOUNCE_LANE_TRANSITION_RIGHT":
                    case 193:
                        message.type = 193;
                        break;
                    case "TYPE_ANNOUNCE_RIGHT_LANE_END":
                    case 90:
                        message.type = 90;
                        break;
                    case "TYPE_ANNOUNCE_LEFT_LANE_END":
                    case 89:
                        message.type = 89;
                        break;
                    case "TYPE_ANNOUNCE_RIGHT_LANE_BEGIN":
                    case 115:
                        message.type = 115;
                        break;
                    case "TYPE_ANNOUNCE_LEFT_LANE_BEGIN":
                    case 116:
                        message.type = 116;
                        break;
                    case "TYPE_ANNOUNCE_LANE_CONSOLIDATION":
                    case 117:
                        message.type = 117;
                        break;
                    case "TYPE_DETOUR_CITY_BLOCK":
                    case 142:
                        message.type = 142;
                        break;
                    case "TYPE_GATE":
                    case 141:
                        message.type = 141;
                        break;
                    case "TYPE_POLE_WARNING":
                    case 91:
                        message.type = 91;
                        break;
                    case "TYPE_TRAFFIC_CONE":
                    case 140:
                        message.type = 140;
                        break;
                    case "TYPE_MOBILE_LANE_CLOSURE":
                    case 139:
                        message.type = 139;
                        break;
                    case "TYPE_REFLECTOR_POST":
                    case 114:
                        message.type = 114;
                        break;
                    case "TYPE_DIRECTIONAL_BOARD_WARNING":
                    case 113:
                        message.type = 113;
                        break;
                    case "TYPE_GUIDING_PLATE":
                    case 104:
                        message.type = 104;
                        break;
                    case "TYPE_GUIDING_PLATE_WEDGES":
                    case 105:
                        message.type = 105;
                        break;
                    case "TYPE_PARKING_HAZARD":
                    case 99:
                        message.type = 99;
                        break;
                    case "TYPE_TRAFFIC_LIGHT_GREEN_ARROW":
                    case 92:
                        message.type = 92;
                        break;
                    }
                    if (object.value != null) {
                        if (typeof object.value !== "object")
                            throw TypeError(".osi3.TrafficSign.MainSign.Classification.value: object expected");
                        message.value = $root.osi3.TrafficSignValue.fromObject(object.value);
                    }
                    switch (object.directionScope) {
                    default:
                        if (typeof object.directionScope === "number") {
                            message.directionScope = object.directionScope;
                            break;
                        }
                        break;
                    case "DIRECTION_SCOPE_UNKNOWN":
                    case 0:
                        message.directionScope = 0;
                        break;
                    case "DIRECTION_SCOPE_OTHER":
                    case 1:
                        message.directionScope = 1;
                        break;
                    case "DIRECTION_SCOPE_NO_DIRECTION":
                    case 2:
                        message.directionScope = 2;
                        break;
                    case "DIRECTION_SCOPE_LEFT":
                    case 3:
                        message.directionScope = 3;
                        break;
                    case "DIRECTION_SCOPE_RIGHT":
                    case 4:
                        message.directionScope = 4;
                        break;
                    case "DIRECTION_SCOPE_LEFT_RIGHT":
                    case 5:
                        message.directionScope = 5;
                        break;
                    }
                    if (object.assignedLaneId) {
                        if (!Array.isArray(object.assignedLaneId))
                            throw TypeError(".osi3.TrafficSign.MainSign.Classification.assignedLaneId: array expected");
                        message.assignedLaneId = [];
                        for (let i = 0; i < object.assignedLaneId.length; ++i) {
                            if (typeof object.assignedLaneId[i] !== "object")
                                throw TypeError(".osi3.TrafficSign.MainSign.Classification.assignedLaneId: object expected");
                            message.assignedLaneId[i] = $root.osi3.Identifier.fromObject(object.assignedLaneId[i]);
                        }
                    }
                    if (object.verticallyMirrored != null)
                        message.verticallyMirrored = Boolean(object.verticallyMirrored);
                    if (object.isOutOfService != null)
                        message.isOutOfService = Boolean(object.isOutOfService);
                    if (object.country != null)
                        message.country = String(object.country);
                    if (object.countryRevision != null)
                        message.countryRevision = String(object.countryRevision);
                    if (object.code != null)
                        message.code = String(object.code);
                    if (object.subCode != null)
                        message.subCode = String(object.subCode);
                    if (object.logicalLaneAssignment) {
                        if (!Array.isArray(object.logicalLaneAssignment))
                            throw TypeError(".osi3.TrafficSign.MainSign.Classification.logicalLaneAssignment: array expected");
                        message.logicalLaneAssignment = [];
                        for (let i = 0; i < object.logicalLaneAssignment.length; ++i) {
                            if (typeof object.logicalLaneAssignment[i] !== "object")
                                throw TypeError(".osi3.TrafficSign.MainSign.Classification.logicalLaneAssignment: object expected");
                            message.logicalLaneAssignment[i] = $root.osi3.LogicalLaneAssignment.fromObject(object.logicalLaneAssignment[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Classification message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof osi3.TrafficSign.MainSign.Classification
                 * @static
                 * @param {osi3.TrafficSign.MainSign.Classification} message Classification
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Classification.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults) {
                        object.assignedLaneId = [];
                        object.logicalLaneAssignment = [];
                    }
                    if (options.defaults) {
                        object.variability = options.enums === String ? "VARIABILITY_UNKNOWN" : 0;
                        object.type = options.enums === String ? "TYPE_UNKNOWN" : 0;
                        object.value = null;
                        object.directionScope = options.enums === String ? "DIRECTION_SCOPE_UNKNOWN" : 0;
                        object.verticallyMirrored = false;
                        object.isOutOfService = false;
                        object.country = "";
                        object.countryRevision = "";
                        object.code = "";
                        object.subCode = "";
                    }
                    if (message.variability != null && message.hasOwnProperty("variability"))
                        object.variability = options.enums === String ? $root.osi3.TrafficSign.Variability[message.variability] === undefined ? message.variability : $root.osi3.TrafficSign.Variability[message.variability] : message.variability;
                    if (message.type != null && message.hasOwnProperty("type"))
                        object.type = options.enums === String ? $root.osi3.TrafficSign.MainSign.Classification.Type[message.type] === undefined ? message.type : $root.osi3.TrafficSign.MainSign.Classification.Type[message.type] : message.type;
                    if (message.value != null && message.hasOwnProperty("value"))
                        object.value = $root.osi3.TrafficSignValue.toObject(message.value, options);
                    if (message.directionScope != null && message.hasOwnProperty("directionScope"))
                        object.directionScope = options.enums === String ? $root.osi3.TrafficSign.MainSign.Classification.DirectionScope[message.directionScope] === undefined ? message.directionScope : $root.osi3.TrafficSign.MainSign.Classification.DirectionScope[message.directionScope] : message.directionScope;
                    if (message.assignedLaneId && message.assignedLaneId.length) {
                        object.assignedLaneId = [];
                        for (let j = 0; j < message.assignedLaneId.length; ++j)
                            object.assignedLaneId[j] = $root.osi3.Identifier.toObject(message.assignedLaneId[j], options);
                    }
                    if (message.verticallyMirrored != null && message.hasOwnProperty("verticallyMirrored"))
                        object.verticallyMirrored = message.verticallyMirrored;
                    if (message.isOutOfService != null && message.hasOwnProperty("isOutOfService"))
                        object.isOutOfService = message.isOutOfService;
                    if (message.country != null && message.hasOwnProperty("country"))
                        object.country = message.country;
                    if (message.countryRevision != null && message.hasOwnProperty("countryRevision"))
                        object.countryRevision = message.countryRevision;
                    if (message.code != null && message.hasOwnProperty("code"))
                        object.code = message.code;
                    if (message.subCode != null && message.hasOwnProperty("subCode"))
                        object.subCode = message.subCode;
                    if (message.logicalLaneAssignment && message.logicalLaneAssignment.length) {
                        object.logicalLaneAssignment = [];
                        for (let j = 0; j < message.logicalLaneAssignment.length; ++j)
                            object.logicalLaneAssignment[j] = $root.osi3.LogicalLaneAssignment.toObject(message.logicalLaneAssignment[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this Classification to JSON.
                 * @function toJSON
                 * @memberof osi3.TrafficSign.MainSign.Classification
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Classification.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for Classification
                 * @function getTypeUrl
                 * @memberof osi3.TrafficSign.MainSign.Classification
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                Classification.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/osi3.TrafficSign.MainSign.Classification";
                };

                /**
                 * Type enum.
                 * @name osi3.TrafficSign.MainSign.Classification.Type
                 * @enum {number}
                 * @property {number} TYPE_UNKNOWN=0 TYPE_UNKNOWN value
                 * @property {number} TYPE_OTHER=1 TYPE_OTHER value
                 * @property {number} TYPE_DANGER_SPOT=2 TYPE_DANGER_SPOT value
                 * @property {number} TYPE_ZEBRA_CROSSING=87 TYPE_ZEBRA_CROSSING value
                 * @property {number} TYPE_FLIGHT=110 TYPE_FLIGHT value
                 * @property {number} TYPE_CATTLE=200 TYPE_CATTLE value
                 * @property {number} TYPE_HORSE_RIDERS=197 TYPE_HORSE_RIDERS value
                 * @property {number} TYPE_AMPHIBIANS=188 TYPE_AMPHIBIANS value
                 * @property {number} TYPE_FALLING_ROCKS=96 TYPE_FALLING_ROCKS value
                 * @property {number} TYPE_SNOW_OR_ICE=94 TYPE_SNOW_OR_ICE value
                 * @property {number} TYPE_LOOSE_GRAVEL=97 TYPE_LOOSE_GRAVEL value
                 * @property {number} TYPE_WATERSIDE=102 TYPE_WATERSIDE value
                 * @property {number} TYPE_CLEARANCE=210 TYPE_CLEARANCE value
                 * @property {number} TYPE_MOVABLE_BRIDGE=101 TYPE_MOVABLE_BRIDGE value
                 * @property {number} TYPE_RIGHT_BEFORE_LEFT_NEXT_INTERSECTION=3 TYPE_RIGHT_BEFORE_LEFT_NEXT_INTERSECTION value
                 * @property {number} TYPE_TURN_LEFT=4 TYPE_TURN_LEFT value
                 * @property {number} TYPE_TURN_RIGHT=5 TYPE_TURN_RIGHT value
                 * @property {number} TYPE_DOUBLE_TURN_LEFT=6 TYPE_DOUBLE_TURN_LEFT value
                 * @property {number} TYPE_DOUBLE_TURN_RIGHT=7 TYPE_DOUBLE_TURN_RIGHT value
                 * @property {number} TYPE_HILL_DOWNWARDS=8 TYPE_HILL_DOWNWARDS value
                 * @property {number} TYPE_HILL_UPWARDS=9 TYPE_HILL_UPWARDS value
                 * @property {number} TYPE_UNEVEN_ROAD=93 TYPE_UNEVEN_ROAD value
                 * @property {number} TYPE_ROAD_SLIPPERY_WET_OR_DIRTY=95 TYPE_ROAD_SLIPPERY_WET_OR_DIRTY value
                 * @property {number} TYPE_SIDE_WINDS=98 TYPE_SIDE_WINDS value
                 * @property {number} TYPE_ROAD_NARROWING=10 TYPE_ROAD_NARROWING value
                 * @property {number} TYPE_ROAD_NARROWING_RIGHT=12 TYPE_ROAD_NARROWING_RIGHT value
                 * @property {number} TYPE_ROAD_NARROWING_LEFT=11 TYPE_ROAD_NARROWING_LEFT value
                 * @property {number} TYPE_ROAD_WORKS=13 TYPE_ROAD_WORKS value
                 * @property {number} TYPE_TRAFFIC_QUEUES=100 TYPE_TRAFFIC_QUEUES value
                 * @property {number} TYPE_TWO_WAY_TRAFFIC=14 TYPE_TWO_WAY_TRAFFIC value
                 * @property {number} TYPE_ATTENTION_TRAFFIC_LIGHT=15 TYPE_ATTENTION_TRAFFIC_LIGHT value
                 * @property {number} TYPE_PEDESTRIANS=103 TYPE_PEDESTRIANS value
                 * @property {number} TYPE_CHILDREN_CROSSING=106 TYPE_CHILDREN_CROSSING value
                 * @property {number} TYPE_CYCLE_ROUTE=107 TYPE_CYCLE_ROUTE value
                 * @property {number} TYPE_DEER_CROSSING=109 TYPE_DEER_CROSSING value
                 * @property {number} TYPE_UNGATED_LEVEL_CROSSING=144 TYPE_UNGATED_LEVEL_CROSSING value
                 * @property {number} TYPE_LEVEL_CROSSING_MARKER=112 TYPE_LEVEL_CROSSING_MARKER value
                 * @property {number} TYPE_RAILWAY_TRAFFIC_PRIORITY=135 TYPE_RAILWAY_TRAFFIC_PRIORITY value
                 * @property {number} TYPE_GIVE_WAY=16 TYPE_GIVE_WAY value
                 * @property {number} TYPE_STOP=17 TYPE_STOP value
                 * @property {number} TYPE_PRIORITY_TO_OPPOSITE_DIRECTION=18 TYPE_PRIORITY_TO_OPPOSITE_DIRECTION value
                 * @property {number} TYPE_PRIORITY_TO_OPPOSITE_DIRECTION_UPSIDE_DOWN=19 TYPE_PRIORITY_TO_OPPOSITE_DIRECTION_UPSIDE_DOWN value
                 * @property {number} TYPE_PRESCRIBED_LEFT_TURN=20 TYPE_PRESCRIBED_LEFT_TURN value
                 * @property {number} TYPE_PRESCRIBED_RIGHT_TURN=21 TYPE_PRESCRIBED_RIGHT_TURN value
                 * @property {number} TYPE_PRESCRIBED_STRAIGHT=22 TYPE_PRESCRIBED_STRAIGHT value
                 * @property {number} TYPE_PRESCRIBED_RIGHT_WAY=24 TYPE_PRESCRIBED_RIGHT_WAY value
                 * @property {number} TYPE_PRESCRIBED_LEFT_WAY=23 TYPE_PRESCRIBED_LEFT_WAY value
                 * @property {number} TYPE_PRESCRIBED_RIGHT_TURN_AND_STRAIGHT=26 TYPE_PRESCRIBED_RIGHT_TURN_AND_STRAIGHT value
                 * @property {number} TYPE_PRESCRIBED_LEFT_TURN_AND_STRAIGHT=25 TYPE_PRESCRIBED_LEFT_TURN_AND_STRAIGHT value
                 * @property {number} TYPE_PRESCRIBED_LEFT_TURN_AND_RIGHT_TURN=27 TYPE_PRESCRIBED_LEFT_TURN_AND_RIGHT_TURN value
                 * @property {number} TYPE_PRESCRIBED_LEFT_TURN_RIGHT_TURN_AND_STRAIGHT=28 TYPE_PRESCRIBED_LEFT_TURN_RIGHT_TURN_AND_STRAIGHT value
                 * @property {number} TYPE_ROUNDABOUT=29 TYPE_ROUNDABOUT value
                 * @property {number} TYPE_ONEWAY_LEFT=30 TYPE_ONEWAY_LEFT value
                 * @property {number} TYPE_ONEWAY_RIGHT=31 TYPE_ONEWAY_RIGHT value
                 * @property {number} TYPE_PASS_LEFT=32 TYPE_PASS_LEFT value
                 * @property {number} TYPE_PASS_RIGHT=33 TYPE_PASS_RIGHT value
                 * @property {number} TYPE_SIDE_LANE_OPEN_FOR_TRAFFIC=128 TYPE_SIDE_LANE_OPEN_FOR_TRAFFIC value
                 * @property {number} TYPE_SIDE_LANE_CLOSED_FOR_TRAFFIC=129 TYPE_SIDE_LANE_CLOSED_FOR_TRAFFIC value
                 * @property {number} TYPE_SIDE_LANE_CLOSING_FOR_TRAFFIC=130 TYPE_SIDE_LANE_CLOSING_FOR_TRAFFIC value
                 * @property {number} TYPE_BUS_STOP=137 TYPE_BUS_STOP value
                 * @property {number} TYPE_TAXI_STAND=138 TYPE_TAXI_STAND value
                 * @property {number} TYPE_BICYCLES_ONLY=145 TYPE_BICYCLES_ONLY value
                 * @property {number} TYPE_HORSE_RIDERS_ONLY=146 TYPE_HORSE_RIDERS_ONLY value
                 * @property {number} TYPE_PEDESTRIANS_ONLY=147 TYPE_PEDESTRIANS_ONLY value
                 * @property {number} TYPE_BICYCLES_PEDESTRIANS_SHARED_ONLY=148 TYPE_BICYCLES_PEDESTRIANS_SHARED_ONLY value
                 * @property {number} TYPE_BICYCLES_PEDESTRIANS_SEPARATED_LEFT_ONLY=149 TYPE_BICYCLES_PEDESTRIANS_SEPARATED_LEFT_ONLY value
                 * @property {number} TYPE_BICYCLES_PEDESTRIANS_SEPARATED_RIGHT_ONLY=150 TYPE_BICYCLES_PEDESTRIANS_SEPARATED_RIGHT_ONLY value
                 * @property {number} TYPE_PEDESTRIAN_ZONE_BEGIN=151 TYPE_PEDESTRIAN_ZONE_BEGIN value
                 * @property {number} TYPE_PEDESTRIAN_ZONE_END=152 TYPE_PEDESTRIAN_ZONE_END value
                 * @property {number} TYPE_BICYCLE_ROAD_BEGIN=153 TYPE_BICYCLE_ROAD_BEGIN value
                 * @property {number} TYPE_BICYCLE_ROAD_END=154 TYPE_BICYCLE_ROAD_END value
                 * @property {number} TYPE_BUS_LANE=34 TYPE_BUS_LANE value
                 * @property {number} TYPE_BUS_LANE_BEGIN=35 TYPE_BUS_LANE_BEGIN value
                 * @property {number} TYPE_BUS_LANE_END=36 TYPE_BUS_LANE_END value
                 * @property {number} TYPE_ALL_PROHIBITED=37 TYPE_ALL_PROHIBITED value
                 * @property {number} TYPE_MOTORIZED_MULTITRACK_PROHIBITED=38 TYPE_MOTORIZED_MULTITRACK_PROHIBITED value
                 * @property {number} TYPE_TRUCKS_PROHIBITED=39 TYPE_TRUCKS_PROHIBITED value
                 * @property {number} TYPE_BICYCLES_PROHIBITED=40 TYPE_BICYCLES_PROHIBITED value
                 * @property {number} TYPE_MOTORCYCLES_PROHIBITED=41 TYPE_MOTORCYCLES_PROHIBITED value
                 * @property {number} TYPE_MOPEDS_PROHIBITED=155 TYPE_MOPEDS_PROHIBITED value
                 * @property {number} TYPE_HORSE_RIDERS_PROHIBITED=156 TYPE_HORSE_RIDERS_PROHIBITED value
                 * @property {number} TYPE_HORSE_CARRIAGES_PROHIBITED=157 TYPE_HORSE_CARRIAGES_PROHIBITED value
                 * @property {number} TYPE_CATTLE_PROHIBITED=158 TYPE_CATTLE_PROHIBITED value
                 * @property {number} TYPE_BUSES_PROHIBITED=159 TYPE_BUSES_PROHIBITED value
                 * @property {number} TYPE_CARS_PROHIBITED=160 TYPE_CARS_PROHIBITED value
                 * @property {number} TYPE_CARS_TRAILERS_PROHIBITED=161 TYPE_CARS_TRAILERS_PROHIBITED value
                 * @property {number} TYPE_TRUCKS_TRAILERS_PROHIBITED=162 TYPE_TRUCKS_TRAILERS_PROHIBITED value
                 * @property {number} TYPE_TRACTORS_PROHIBITED=163 TYPE_TRACTORS_PROHIBITED value
                 * @property {number} TYPE_PEDESTRIANS_PROHIBITED=42 TYPE_PEDESTRIANS_PROHIBITED value
                 * @property {number} TYPE_MOTOR_VEHICLES_PROHIBITED=43 TYPE_MOTOR_VEHICLES_PROHIBITED value
                 * @property {number} TYPE_HAZARDOUS_GOODS_VEHICLES_PROHIBITED=164 TYPE_HAZARDOUS_GOODS_VEHICLES_PROHIBITED value
                 * @property {number} TYPE_OVER_WEIGHT_VEHICLES_PROHIBITED=165 TYPE_OVER_WEIGHT_VEHICLES_PROHIBITED value
                 * @property {number} TYPE_VEHICLES_AXLE_OVER_WEIGHT_PROHIBITED=166 TYPE_VEHICLES_AXLE_OVER_WEIGHT_PROHIBITED value
                 * @property {number} TYPE_VEHICLES_EXCESS_WIDTH_PROHIBITED=167 TYPE_VEHICLES_EXCESS_WIDTH_PROHIBITED value
                 * @property {number} TYPE_VEHICLES_EXCESS_HEIGHT_PROHIBITED=168 TYPE_VEHICLES_EXCESS_HEIGHT_PROHIBITED value
                 * @property {number} TYPE_VEHICLES_EXCESS_LENGTH_PROHIBITED=169 TYPE_VEHICLES_EXCESS_LENGTH_PROHIBITED value
                 * @property {number} TYPE_DO_NOT_ENTER=44 TYPE_DO_NOT_ENTER value
                 * @property {number} TYPE_SNOW_CHAINS_REQUIRED=170 TYPE_SNOW_CHAINS_REQUIRED value
                 * @property {number} TYPE_WATER_POLLUTANT_VEHICLES_PROHIBITED=171 TYPE_WATER_POLLUTANT_VEHICLES_PROHIBITED value
                 * @property {number} TYPE_ENVIRONMENTAL_ZONE_BEGIN=45 TYPE_ENVIRONMENTAL_ZONE_BEGIN value
                 * @property {number} TYPE_ENVIRONMENTAL_ZONE_END=46 TYPE_ENVIRONMENTAL_ZONE_END value
                 * @property {number} TYPE_NO_U_TURN_LEFT=47 TYPE_NO_U_TURN_LEFT value
                 * @property {number} TYPE_NO_U_TURN_RIGHT=48 TYPE_NO_U_TURN_RIGHT value
                 * @property {number} TYPE_PRESCRIBED_U_TURN_LEFT=49 TYPE_PRESCRIBED_U_TURN_LEFT value
                 * @property {number} TYPE_PRESCRIBED_U_TURN_RIGHT=50 TYPE_PRESCRIBED_U_TURN_RIGHT value
                 * @property {number} TYPE_MINIMUM_DISTANCE_FOR_TRUCKS=51 TYPE_MINIMUM_DISTANCE_FOR_TRUCKS value
                 * @property {number} TYPE_SPEED_LIMIT_BEGIN=52 TYPE_SPEED_LIMIT_BEGIN value
                 * @property {number} TYPE_SPEED_LIMIT_ZONE_BEGIN=53 TYPE_SPEED_LIMIT_ZONE_BEGIN value
                 * @property {number} TYPE_SPEED_LIMIT_ZONE_END=54 TYPE_SPEED_LIMIT_ZONE_END value
                 * @property {number} TYPE_MINIMUM_SPEED_BEGIN=55 TYPE_MINIMUM_SPEED_BEGIN value
                 * @property {number} TYPE_OVERTAKING_BAN_BEGIN=56 TYPE_OVERTAKING_BAN_BEGIN value
                 * @property {number} TYPE_OVERTAKING_BAN_FOR_TRUCKS_BEGIN=57 TYPE_OVERTAKING_BAN_FOR_TRUCKS_BEGIN value
                 * @property {number} TYPE_SPEED_LIMIT_END=58 TYPE_SPEED_LIMIT_END value
                 * @property {number} TYPE_MINIMUM_SPEED_END=59 TYPE_MINIMUM_SPEED_END value
                 * @property {number} TYPE_OVERTAKING_BAN_END=60 TYPE_OVERTAKING_BAN_END value
                 * @property {number} TYPE_OVERTAKING_BAN_FOR_TRUCKS_END=61 TYPE_OVERTAKING_BAN_FOR_TRUCKS_END value
                 * @property {number} TYPE_ALL_RESTRICTIONS_END=62 TYPE_ALL_RESTRICTIONS_END value
                 * @property {number} TYPE_NO_STOPPING=63 TYPE_NO_STOPPING value
                 * @property {number} TYPE_NO_PARKING=64 TYPE_NO_PARKING value
                 * @property {number} TYPE_NO_PARKING_ZONE_BEGIN=65 TYPE_NO_PARKING_ZONE_BEGIN value
                 * @property {number} TYPE_NO_PARKING_ZONE_END=66 TYPE_NO_PARKING_ZONE_END value
                 * @property {number} TYPE_RIGHT_OF_WAY_NEXT_INTERSECTION=67 TYPE_RIGHT_OF_WAY_NEXT_INTERSECTION value
                 * @property {number} TYPE_RIGHT_OF_WAY_BEGIN=68 TYPE_RIGHT_OF_WAY_BEGIN value
                 * @property {number} TYPE_RIGHT_OF_WAY_END=69 TYPE_RIGHT_OF_WAY_END value
                 * @property {number} TYPE_PRIORITY_OVER_OPPOSITE_DIRECTION=70 TYPE_PRIORITY_OVER_OPPOSITE_DIRECTION value
                 * @property {number} TYPE_PRIORITY_OVER_OPPOSITE_DIRECTION_UPSIDE_DOWN=71 TYPE_PRIORITY_OVER_OPPOSITE_DIRECTION_UPSIDE_DOWN value
                 * @property {number} TYPE_TOWN_BEGIN=72 TYPE_TOWN_BEGIN value
                 * @property {number} TYPE_TOWN_END=73 TYPE_TOWN_END value
                 * @property {number} TYPE_CAR_PARKING=74 TYPE_CAR_PARKING value
                 * @property {number} TYPE_CAR_PARKING_ZONE_BEGIN=75 TYPE_CAR_PARKING_ZONE_BEGIN value
                 * @property {number} TYPE_CAR_PARKING_ZONE_END=76 TYPE_CAR_PARKING_ZONE_END value
                 * @property {number} TYPE_SIDEWALK_HALF_PARKING_LEFT=172 TYPE_SIDEWALK_HALF_PARKING_LEFT value
                 * @property {number} TYPE_SIDEWALK_HALF_PARKING_RIGHT=173 TYPE_SIDEWALK_HALF_PARKING_RIGHT value
                 * @property {number} TYPE_SIDEWALK_PARKING_LEFT=174 TYPE_SIDEWALK_PARKING_LEFT value
                 * @property {number} TYPE_SIDEWALK_PARKING_RIGHT=175 TYPE_SIDEWALK_PARKING_RIGHT value
                 * @property {number} TYPE_SIDEWALK_PERPENDICULAR_HALF_PARKING_LEFT=176 TYPE_SIDEWALK_PERPENDICULAR_HALF_PARKING_LEFT value
                 * @property {number} TYPE_SIDEWALK_PERPENDICULAR_HALF_PARKING_RIGHT=177 TYPE_SIDEWALK_PERPENDICULAR_HALF_PARKING_RIGHT value
                 * @property {number} TYPE_SIDEWALK_PERPENDICULAR_PARKING_LEFT=178 TYPE_SIDEWALK_PERPENDICULAR_PARKING_LEFT value
                 * @property {number} TYPE_SIDEWALK_PERPENDICULAR_PARKING_RIGHT=179 TYPE_SIDEWALK_PERPENDICULAR_PARKING_RIGHT value
                 * @property {number} TYPE_LIVING_STREET_BEGIN=77 TYPE_LIVING_STREET_BEGIN value
                 * @property {number} TYPE_LIVING_STREET_END=78 TYPE_LIVING_STREET_END value
                 * @property {number} TYPE_TUNNEL=79 TYPE_TUNNEL value
                 * @property {number} TYPE_EMERGENCY_STOPPING_LEFT=80 TYPE_EMERGENCY_STOPPING_LEFT value
                 * @property {number} TYPE_EMERGENCY_STOPPING_RIGHT=81 TYPE_EMERGENCY_STOPPING_RIGHT value
                 * @property {number} TYPE_HIGHWAY_BEGIN=82 TYPE_HIGHWAY_BEGIN value
                 * @property {number} TYPE_HIGHWAY_END=83 TYPE_HIGHWAY_END value
                 * @property {number} TYPE_EXPRESSWAY_BEGIN=84 TYPE_EXPRESSWAY_BEGIN value
                 * @property {number} TYPE_EXPRESSWAY_END=85 TYPE_EXPRESSWAY_END value
                 * @property {number} TYPE_NAMED_HIGHWAY_EXIT=183 TYPE_NAMED_HIGHWAY_EXIT value
                 * @property {number} TYPE_NAMED_EXPRESSWAY_EXIT=184 TYPE_NAMED_EXPRESSWAY_EXIT value
                 * @property {number} TYPE_NAMED_ROAD_EXIT=185 TYPE_NAMED_ROAD_EXIT value
                 * @property {number} TYPE_HIGHWAY_EXIT=86 TYPE_HIGHWAY_EXIT value
                 * @property {number} TYPE_EXPRESSWAY_EXIT=186 TYPE_EXPRESSWAY_EXIT value
                 * @property {number} TYPE_ONEWAY_STREET=187 TYPE_ONEWAY_STREET value
                 * @property {number} TYPE_CROSSING_GUARDS=189 TYPE_CROSSING_GUARDS value
                 * @property {number} TYPE_DEADEND=190 TYPE_DEADEND value
                 * @property {number} TYPE_DEADEND_EXCLUDING_DESIGNATED_ACTORS=191 TYPE_DEADEND_EXCLUDING_DESIGNATED_ACTORS value
                 * @property {number} TYPE_FIRST_AID_STATION=194 TYPE_FIRST_AID_STATION value
                 * @property {number} TYPE_POLICE_STATION=195 TYPE_POLICE_STATION value
                 * @property {number} TYPE_TELEPHONE=196 TYPE_TELEPHONE value
                 * @property {number} TYPE_FILLING_STATION=198 TYPE_FILLING_STATION value
                 * @property {number} TYPE_HOTEL=201 TYPE_HOTEL value
                 * @property {number} TYPE_INN=202 TYPE_INN value
                 * @property {number} TYPE_KIOSK=203 TYPE_KIOSK value
                 * @property {number} TYPE_TOILET=204 TYPE_TOILET value
                 * @property {number} TYPE_CHAPEL=205 TYPE_CHAPEL value
                 * @property {number} TYPE_TOURIST_INFO=206 TYPE_TOURIST_INFO value
                 * @property {number} TYPE_REPAIR_SERVICE=207 TYPE_REPAIR_SERVICE value
                 * @property {number} TYPE_PEDESTRIAN_UNDERPASS=208 TYPE_PEDESTRIAN_UNDERPASS value
                 * @property {number} TYPE_PEDESTRIAN_BRIDGE=209 TYPE_PEDESTRIAN_BRIDGE value
                 * @property {number} TYPE_CAMPER_PLACE=213 TYPE_CAMPER_PLACE value
                 * @property {number} TYPE_ADVISORY_SPEED_LIMIT_BEGIN=214 TYPE_ADVISORY_SPEED_LIMIT_BEGIN value
                 * @property {number} TYPE_ADVISORY_SPEED_LIMIT_END=215 TYPE_ADVISORY_SPEED_LIMIT_END value
                 * @property {number} TYPE_PLACE_NAME=216 TYPE_PLACE_NAME value
                 * @property {number} TYPE_TOURIST_ATTRACTION=217 TYPE_TOURIST_ATTRACTION value
                 * @property {number} TYPE_TOURIST_ROUTE=218 TYPE_TOURIST_ROUTE value
                 * @property {number} TYPE_TOURIST_AREA=219 TYPE_TOURIST_AREA value
                 * @property {number} TYPE_SHOULDER_NOT_PASSABLE_MOTOR_VEHICLES=220 TYPE_SHOULDER_NOT_PASSABLE_MOTOR_VEHICLES value
                 * @property {number} TYPE_SHOULDER_UNSAFE_TRUCKS_TRACTORS=221 TYPE_SHOULDER_UNSAFE_TRUCKS_TRACTORS value
                 * @property {number} TYPE_TOLL_BEGIN=222 TYPE_TOLL_BEGIN value
                 * @property {number} TYPE_TOLL_END=223 TYPE_TOLL_END value
                 * @property {number} TYPE_TOLL_ROAD=224 TYPE_TOLL_ROAD value
                 * @property {number} TYPE_CUSTOMS=225 TYPE_CUSTOMS value
                 * @property {number} TYPE_INTERNATIONAL_BORDER_INFO=226 TYPE_INTERNATIONAL_BORDER_INFO value
                 * @property {number} TYPE_STREETLIGHT_RED_BAND=227 TYPE_STREETLIGHT_RED_BAND value
                 * @property {number} TYPE_FEDERAL_HIGHWAY_ROUTE_NUMBER=228 TYPE_FEDERAL_HIGHWAY_ROUTE_NUMBER value
                 * @property {number} TYPE_HIGHWAY_ROUTE_NUMBER=229 TYPE_HIGHWAY_ROUTE_NUMBER value
                 * @property {number} TYPE_HIGHWAY_INTERCHANGE_NUMBER=230 TYPE_HIGHWAY_INTERCHANGE_NUMBER value
                 * @property {number} TYPE_EUROPEAN_ROUTE_NUMBER=231 TYPE_EUROPEAN_ROUTE_NUMBER value
                 * @property {number} TYPE_FEDERAL_HIGHWAY_DIRECTION_LEFT=232 TYPE_FEDERAL_HIGHWAY_DIRECTION_LEFT value
                 * @property {number} TYPE_FEDERAL_HIGHWAY_DIRECTION_RIGHT=233 TYPE_FEDERAL_HIGHWAY_DIRECTION_RIGHT value
                 * @property {number} TYPE_PRIMARY_ROAD_DIRECTION_LEFT=234 TYPE_PRIMARY_ROAD_DIRECTION_LEFT value
                 * @property {number} TYPE_PRIMARY_ROAD_DIRECTION_RIGHT=235 TYPE_PRIMARY_ROAD_DIRECTION_RIGHT value
                 * @property {number} TYPE_SECONDARY_ROAD_DIRECTION_LEFT=236 TYPE_SECONDARY_ROAD_DIRECTION_LEFT value
                 * @property {number} TYPE_SECONDARY_ROAD_DIRECTION_RIGHT=237 TYPE_SECONDARY_ROAD_DIRECTION_RIGHT value
                 * @property {number} TYPE_DIRECTION_DESIGNATED_ACTORS_LEFT=238 TYPE_DIRECTION_DESIGNATED_ACTORS_LEFT value
                 * @property {number} TYPE_DIRECTION_DESIGNATED_ACTORS_RIGHT=239 TYPE_DIRECTION_DESIGNATED_ACTORS_RIGHT value
                 * @property {number} TYPE_ROUTING_DESIGNATED_ACTORS=240 TYPE_ROUTING_DESIGNATED_ACTORS value
                 * @property {number} TYPE_DIRECTION_TO_HIGHWAY_LEFT=143 TYPE_DIRECTION_TO_HIGHWAY_LEFT value
                 * @property {number} TYPE_DIRECTION_TO_HIGHWAY_RIGHT=108 TYPE_DIRECTION_TO_HIGHWAY_RIGHT value
                 * @property {number} TYPE_DIRECTION_TO_LOCAL_DESTINATION_LEFT=127 TYPE_DIRECTION_TO_LOCAL_DESTINATION_LEFT value
                 * @property {number} TYPE_DIRECTION_TO_LOCAL_DESTINATION_RIGHT=136 TYPE_DIRECTION_TO_LOCAL_DESTINATION_RIGHT value
                 * @property {number} TYPE_CONSOLIDATED_DIRECTIONS=118 TYPE_CONSOLIDATED_DIRECTIONS value
                 * @property {number} TYPE_STREET_NAME=119 TYPE_STREET_NAME value
                 * @property {number} TYPE_DIRECTION_PREANNOUNCEMENT=120 TYPE_DIRECTION_PREANNOUNCEMENT value
                 * @property {number} TYPE_DIRECTION_PREANNOUNCEMENT_LANE_CONFIG=121 TYPE_DIRECTION_PREANNOUNCEMENT_LANE_CONFIG value
                 * @property {number} TYPE_DIRECTION_PREANNOUNCEMENT_HIGHWAY_ENTRIES=122 TYPE_DIRECTION_PREANNOUNCEMENT_HIGHWAY_ENTRIES value
                 * @property {number} TYPE_HIGHWAY_ANNOUNCEMENT=123 TYPE_HIGHWAY_ANNOUNCEMENT value
                 * @property {number} TYPE_OTHER_ROAD_ANNOUNCEMENT=124 TYPE_OTHER_ROAD_ANNOUNCEMENT value
                 * @property {number} TYPE_HIGHWAY_ANNOUNCEMENT_TRUCK_STOP=125 TYPE_HIGHWAY_ANNOUNCEMENT_TRUCK_STOP value
                 * @property {number} TYPE_HIGHWAY_PREANNOUNCEMENT_DIRECTIONS=126 TYPE_HIGHWAY_PREANNOUNCEMENT_DIRECTIONS value
                 * @property {number} TYPE_POLE_EXIT=88 TYPE_POLE_EXIT value
                 * @property {number} TYPE_HIGHWAY_DISTANCE_BOARD=180 TYPE_HIGHWAY_DISTANCE_BOARD value
                 * @property {number} TYPE_DETOUR_LEFT=181 TYPE_DETOUR_LEFT value
                 * @property {number} TYPE_DETOUR_RIGHT=182 TYPE_DETOUR_RIGHT value
                 * @property {number} TYPE_NUMBERED_DETOUR=131 TYPE_NUMBERED_DETOUR value
                 * @property {number} TYPE_DETOUR_BEGIN=132 TYPE_DETOUR_BEGIN value
                 * @property {number} TYPE_DETOUR_END=133 TYPE_DETOUR_END value
                 * @property {number} TYPE_DETOUR_ROUTING_BOARD=134 TYPE_DETOUR_ROUTING_BOARD value
                 * @property {number} TYPE_OPTIONAL_DETOUR=111 TYPE_OPTIONAL_DETOUR value
                 * @property {number} TYPE_OPTIONAL_DETOUR_ROUTING=199 TYPE_OPTIONAL_DETOUR_ROUTING value
                 * @property {number} TYPE_ROUTE_RECOMMENDATION=211 TYPE_ROUTE_RECOMMENDATION value
                 * @property {number} TYPE_ROUTE_RECOMMENDATION_END=212 TYPE_ROUTE_RECOMMENDATION_END value
                 * @property {number} TYPE_ANNOUNCE_LANE_TRANSITION_LEFT=192 TYPE_ANNOUNCE_LANE_TRANSITION_LEFT value
                 * @property {number} TYPE_ANNOUNCE_LANE_TRANSITION_RIGHT=193 TYPE_ANNOUNCE_LANE_TRANSITION_RIGHT value
                 * @property {number} TYPE_ANNOUNCE_RIGHT_LANE_END=90 TYPE_ANNOUNCE_RIGHT_LANE_END value
                 * @property {number} TYPE_ANNOUNCE_LEFT_LANE_END=89 TYPE_ANNOUNCE_LEFT_LANE_END value
                 * @property {number} TYPE_ANNOUNCE_RIGHT_LANE_BEGIN=115 TYPE_ANNOUNCE_RIGHT_LANE_BEGIN value
                 * @property {number} TYPE_ANNOUNCE_LEFT_LANE_BEGIN=116 TYPE_ANNOUNCE_LEFT_LANE_BEGIN value
                 * @property {number} TYPE_ANNOUNCE_LANE_CONSOLIDATION=117 TYPE_ANNOUNCE_LANE_CONSOLIDATION value
                 * @property {number} TYPE_DETOUR_CITY_BLOCK=142 TYPE_DETOUR_CITY_BLOCK value
                 * @property {number} TYPE_GATE=141 TYPE_GATE value
                 * @property {number} TYPE_POLE_WARNING=91 TYPE_POLE_WARNING value
                 * @property {number} TYPE_TRAFFIC_CONE=140 TYPE_TRAFFIC_CONE value
                 * @property {number} TYPE_MOBILE_LANE_CLOSURE=139 TYPE_MOBILE_LANE_CLOSURE value
                 * @property {number} TYPE_REFLECTOR_POST=114 TYPE_REFLECTOR_POST value
                 * @property {number} TYPE_DIRECTIONAL_BOARD_WARNING=113 TYPE_DIRECTIONAL_BOARD_WARNING value
                 * @property {number} TYPE_GUIDING_PLATE=104 TYPE_GUIDING_PLATE value
                 * @property {number} TYPE_GUIDING_PLATE_WEDGES=105 TYPE_GUIDING_PLATE_WEDGES value
                 * @property {number} TYPE_PARKING_HAZARD=99 TYPE_PARKING_HAZARD value
                 * @property {number} TYPE_TRAFFIC_LIGHT_GREEN_ARROW=92 TYPE_TRAFFIC_LIGHT_GREEN_ARROW value
                 */
                Classification.Type = (function() {
                    const valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "TYPE_UNKNOWN"] = 0;
                    values[valuesById[1] = "TYPE_OTHER"] = 1;
                    values[valuesById[2] = "TYPE_DANGER_SPOT"] = 2;
                    values[valuesById[87] = "TYPE_ZEBRA_CROSSING"] = 87;
                    values[valuesById[110] = "TYPE_FLIGHT"] = 110;
                    values[valuesById[200] = "TYPE_CATTLE"] = 200;
                    values[valuesById[197] = "TYPE_HORSE_RIDERS"] = 197;
                    values[valuesById[188] = "TYPE_AMPHIBIANS"] = 188;
                    values[valuesById[96] = "TYPE_FALLING_ROCKS"] = 96;
                    values[valuesById[94] = "TYPE_SNOW_OR_ICE"] = 94;
                    values[valuesById[97] = "TYPE_LOOSE_GRAVEL"] = 97;
                    values[valuesById[102] = "TYPE_WATERSIDE"] = 102;
                    values[valuesById[210] = "TYPE_CLEARANCE"] = 210;
                    values[valuesById[101] = "TYPE_MOVABLE_BRIDGE"] = 101;
                    values[valuesById[3] = "TYPE_RIGHT_BEFORE_LEFT_NEXT_INTERSECTION"] = 3;
                    values[valuesById[4] = "TYPE_TURN_LEFT"] = 4;
                    values[valuesById[5] = "TYPE_TURN_RIGHT"] = 5;
                    values[valuesById[6] = "TYPE_DOUBLE_TURN_LEFT"] = 6;
                    values[valuesById[7] = "TYPE_DOUBLE_TURN_RIGHT"] = 7;
                    values[valuesById[8] = "TYPE_HILL_DOWNWARDS"] = 8;
                    values[valuesById[9] = "TYPE_HILL_UPWARDS"] = 9;
                    values[valuesById[93] = "TYPE_UNEVEN_ROAD"] = 93;
                    values[valuesById[95] = "TYPE_ROAD_SLIPPERY_WET_OR_DIRTY"] = 95;
                    values[valuesById[98] = "TYPE_SIDE_WINDS"] = 98;
                    values[valuesById[10] = "TYPE_ROAD_NARROWING"] = 10;
                    values[valuesById[12] = "TYPE_ROAD_NARROWING_RIGHT"] = 12;
                    values[valuesById[11] = "TYPE_ROAD_NARROWING_LEFT"] = 11;
                    values[valuesById[13] = "TYPE_ROAD_WORKS"] = 13;
                    values[valuesById[100] = "TYPE_TRAFFIC_QUEUES"] = 100;
                    values[valuesById[14] = "TYPE_TWO_WAY_TRAFFIC"] = 14;
                    values[valuesById[15] = "TYPE_ATTENTION_TRAFFIC_LIGHT"] = 15;
                    values[valuesById[103] = "TYPE_PEDESTRIANS"] = 103;
                    values[valuesById[106] = "TYPE_CHILDREN_CROSSING"] = 106;
                    values[valuesById[107] = "TYPE_CYCLE_ROUTE"] = 107;
                    values[valuesById[109] = "TYPE_DEER_CROSSING"] = 109;
                    values[valuesById[144] = "TYPE_UNGATED_LEVEL_CROSSING"] = 144;
                    values[valuesById[112] = "TYPE_LEVEL_CROSSING_MARKER"] = 112;
                    values[valuesById[135] = "TYPE_RAILWAY_TRAFFIC_PRIORITY"] = 135;
                    values[valuesById[16] = "TYPE_GIVE_WAY"] = 16;
                    values[valuesById[17] = "TYPE_STOP"] = 17;
                    values[valuesById[18] = "TYPE_PRIORITY_TO_OPPOSITE_DIRECTION"] = 18;
                    values[valuesById[19] = "TYPE_PRIORITY_TO_OPPOSITE_DIRECTION_UPSIDE_DOWN"] = 19;
                    values[valuesById[20] = "TYPE_PRESCRIBED_LEFT_TURN"] = 20;
                    values[valuesById[21] = "TYPE_PRESCRIBED_RIGHT_TURN"] = 21;
                    values[valuesById[22] = "TYPE_PRESCRIBED_STRAIGHT"] = 22;
                    values[valuesById[24] = "TYPE_PRESCRIBED_RIGHT_WAY"] = 24;
                    values[valuesById[23] = "TYPE_PRESCRIBED_LEFT_WAY"] = 23;
                    values[valuesById[26] = "TYPE_PRESCRIBED_RIGHT_TURN_AND_STRAIGHT"] = 26;
                    values[valuesById[25] = "TYPE_PRESCRIBED_LEFT_TURN_AND_STRAIGHT"] = 25;
                    values[valuesById[27] = "TYPE_PRESCRIBED_LEFT_TURN_AND_RIGHT_TURN"] = 27;
                    values[valuesById[28] = "TYPE_PRESCRIBED_LEFT_TURN_RIGHT_TURN_AND_STRAIGHT"] = 28;
                    values[valuesById[29] = "TYPE_ROUNDABOUT"] = 29;
                    values[valuesById[30] = "TYPE_ONEWAY_LEFT"] = 30;
                    values[valuesById[31] = "TYPE_ONEWAY_RIGHT"] = 31;
                    values[valuesById[32] = "TYPE_PASS_LEFT"] = 32;
                    values[valuesById[33] = "TYPE_PASS_RIGHT"] = 33;
                    values[valuesById[128] = "TYPE_SIDE_LANE_OPEN_FOR_TRAFFIC"] = 128;
                    values[valuesById[129] = "TYPE_SIDE_LANE_CLOSED_FOR_TRAFFIC"] = 129;
                    values[valuesById[130] = "TYPE_SIDE_LANE_CLOSING_FOR_TRAFFIC"] = 130;
                    values[valuesById[137] = "TYPE_BUS_STOP"] = 137;
                    values[valuesById[138] = "TYPE_TAXI_STAND"] = 138;
                    values[valuesById[145] = "TYPE_BICYCLES_ONLY"] = 145;
                    values[valuesById[146] = "TYPE_HORSE_RIDERS_ONLY"] = 146;
                    values[valuesById[147] = "TYPE_PEDESTRIANS_ONLY"] = 147;
                    values[valuesById[148] = "TYPE_BICYCLES_PEDESTRIANS_SHARED_ONLY"] = 148;
                    values[valuesById[149] = "TYPE_BICYCLES_PEDESTRIANS_SEPARATED_LEFT_ONLY"] = 149;
                    values[valuesById[150] = "TYPE_BICYCLES_PEDESTRIANS_SEPARATED_RIGHT_ONLY"] = 150;
                    values[valuesById[151] = "TYPE_PEDESTRIAN_ZONE_BEGIN"] = 151;
                    values[valuesById[152] = "TYPE_PEDESTRIAN_ZONE_END"] = 152;
                    values[valuesById[153] = "TYPE_BICYCLE_ROAD_BEGIN"] = 153;
                    values[valuesById[154] = "TYPE_BICYCLE_ROAD_END"] = 154;
                    values[valuesById[34] = "TYPE_BUS_LANE"] = 34;
                    values[valuesById[35] = "TYPE_BUS_LANE_BEGIN"] = 35;
                    values[valuesById[36] = "TYPE_BUS_LANE_END"] = 36;
                    values[valuesById[37] = "TYPE_ALL_PROHIBITED"] = 37;
                    values[valuesById[38] = "TYPE_MOTORIZED_MULTITRACK_PROHIBITED"] = 38;
                    values[valuesById[39] = "TYPE_TRUCKS_PROHIBITED"] = 39;
                    values[valuesById[40] = "TYPE_BICYCLES_PROHIBITED"] = 40;
                    values[valuesById[41] = "TYPE_MOTORCYCLES_PROHIBITED"] = 41;
                    values[valuesById[155] = "TYPE_MOPEDS_PROHIBITED"] = 155;
                    values[valuesById[156] = "TYPE_HORSE_RIDERS_PROHIBITED"] = 156;
                    values[valuesById[157] = "TYPE_HORSE_CARRIAGES_PROHIBITED"] = 157;
                    values[valuesById[158] = "TYPE_CATTLE_PROHIBITED"] = 158;
                    values[valuesById[159] = "TYPE_BUSES_PROHIBITED"] = 159;
                    values[valuesById[160] = "TYPE_CARS_PROHIBITED"] = 160;
                    values[valuesById[161] = "TYPE_CARS_TRAILERS_PROHIBITED"] = 161;
                    values[valuesById[162] = "TYPE_TRUCKS_TRAILERS_PROHIBITED"] = 162;
                    values[valuesById[163] = "TYPE_TRACTORS_PROHIBITED"] = 163;
                    values[valuesById[42] = "TYPE_PEDESTRIANS_PROHIBITED"] = 42;
                    values[valuesById[43] = "TYPE_MOTOR_VEHICLES_PROHIBITED"] = 43;
                    values[valuesById[164] = "TYPE_HAZARDOUS_GOODS_VEHICLES_PROHIBITED"] = 164;
                    values[valuesById[165] = "TYPE_OVER_WEIGHT_VEHICLES_PROHIBITED"] = 165;
                    values[valuesById[166] = "TYPE_VEHICLES_AXLE_OVER_WEIGHT_PROHIBITED"] = 166;
                    values[valuesById[167] = "TYPE_VEHICLES_EXCESS_WIDTH_PROHIBITED"] = 167;
                    values[valuesById[168] = "TYPE_VEHICLES_EXCESS_HEIGHT_PROHIBITED"] = 168;
                    values[valuesById[169] = "TYPE_VEHICLES_EXCESS_LENGTH_PROHIBITED"] = 169;
                    values[valuesById[44] = "TYPE_DO_NOT_ENTER"] = 44;
                    values[valuesById[170] = "TYPE_SNOW_CHAINS_REQUIRED"] = 170;
                    values[valuesById[171] = "TYPE_WATER_POLLUTANT_VEHICLES_PROHIBITED"] = 171;
                    values[valuesById[45] = "TYPE_ENVIRONMENTAL_ZONE_BEGIN"] = 45;
                    values[valuesById[46] = "TYPE_ENVIRONMENTAL_ZONE_END"] = 46;
                    values[valuesById[47] = "TYPE_NO_U_TURN_LEFT"] = 47;
                    values[valuesById[48] = "TYPE_NO_U_TURN_RIGHT"] = 48;
                    values[valuesById[49] = "TYPE_PRESCRIBED_U_TURN_LEFT"] = 49;
                    values[valuesById[50] = "TYPE_PRESCRIBED_U_TURN_RIGHT"] = 50;
                    values[valuesById[51] = "TYPE_MINIMUM_DISTANCE_FOR_TRUCKS"] = 51;
                    values[valuesById[52] = "TYPE_SPEED_LIMIT_BEGIN"] = 52;
                    values[valuesById[53] = "TYPE_SPEED_LIMIT_ZONE_BEGIN"] = 53;
                    values[valuesById[54] = "TYPE_SPEED_LIMIT_ZONE_END"] = 54;
                    values[valuesById[55] = "TYPE_MINIMUM_SPEED_BEGIN"] = 55;
                    values[valuesById[56] = "TYPE_OVERTAKING_BAN_BEGIN"] = 56;
                    values[valuesById[57] = "TYPE_OVERTAKING_BAN_FOR_TRUCKS_BEGIN"] = 57;
                    values[valuesById[58] = "TYPE_SPEED_LIMIT_END"] = 58;
                    values[valuesById[59] = "TYPE_MINIMUM_SPEED_END"] = 59;
                    values[valuesById[60] = "TYPE_OVERTAKING_BAN_END"] = 60;
                    values[valuesById[61] = "TYPE_OVERTAKING_BAN_FOR_TRUCKS_END"] = 61;
                    values[valuesById[62] = "TYPE_ALL_RESTRICTIONS_END"] = 62;
                    values[valuesById[63] = "TYPE_NO_STOPPING"] = 63;
                    values[valuesById[64] = "TYPE_NO_PARKING"] = 64;
                    values[valuesById[65] = "TYPE_NO_PARKING_ZONE_BEGIN"] = 65;
                    values[valuesById[66] = "TYPE_NO_PARKING_ZONE_END"] = 66;
                    values[valuesById[67] = "TYPE_RIGHT_OF_WAY_NEXT_INTERSECTION"] = 67;
                    values[valuesById[68] = "TYPE_RIGHT_OF_WAY_BEGIN"] = 68;
                    values[valuesById[69] = "TYPE_RIGHT_OF_WAY_END"] = 69;
                    values[valuesById[70] = "TYPE_PRIORITY_OVER_OPPOSITE_DIRECTION"] = 70;
                    values[valuesById[71] = "TYPE_PRIORITY_OVER_OPPOSITE_DIRECTION_UPSIDE_DOWN"] = 71;
                    values[valuesById[72] = "TYPE_TOWN_BEGIN"] = 72;
                    values[valuesById[73] = "TYPE_TOWN_END"] = 73;
                    values[valuesById[74] = "TYPE_CAR_PARKING"] = 74;
                    values[valuesById[75] = "TYPE_CAR_PARKING_ZONE_BEGIN"] = 75;
                    values[valuesById[76] = "TYPE_CAR_PARKING_ZONE_END"] = 76;
                    values[valuesById[172] = "TYPE_SIDEWALK_HALF_PARKING_LEFT"] = 172;
                    values[valuesById[173] = "TYPE_SIDEWALK_HALF_PARKING_RIGHT"] = 173;
                    values[valuesById[174] = "TYPE_SIDEWALK_PARKING_LEFT"] = 174;
                    values[valuesById[175] = "TYPE_SIDEWALK_PARKING_RIGHT"] = 175;
                    values[valuesById[176] = "TYPE_SIDEWALK_PERPENDICULAR_HALF_PARKING_LEFT"] = 176;
                    values[valuesById[177] = "TYPE_SIDEWALK_PERPENDICULAR_HALF_PARKING_RIGHT"] = 177;
                    values[valuesById[178] = "TYPE_SIDEWALK_PERPENDICULAR_PARKING_LEFT"] = 178;
                    values[valuesById[179] = "TYPE_SIDEWALK_PERPENDICULAR_PARKING_RIGHT"] = 179;
                    values[valuesById[77] = "TYPE_LIVING_STREET_BEGIN"] = 77;
                    values[valuesById[78] = "TYPE_LIVING_STREET_END"] = 78;
                    values[valuesById[79] = "TYPE_TUNNEL"] = 79;
                    values[valuesById[80] = "TYPE_EMERGENCY_STOPPING_LEFT"] = 80;
                    values[valuesById[81] = "TYPE_EMERGENCY_STOPPING_RIGHT"] = 81;
                    values[valuesById[82] = "TYPE_HIGHWAY_BEGIN"] = 82;
                    values[valuesById[83] = "TYPE_HIGHWAY_END"] = 83;
                    values[valuesById[84] = "TYPE_EXPRESSWAY_BEGIN"] = 84;
                    values[valuesById[85] = "TYPE_EXPRESSWAY_END"] = 85;
                    values[valuesById[183] = "TYPE_NAMED_HIGHWAY_EXIT"] = 183;
                    values[valuesById[184] = "TYPE_NAMED_EXPRESSWAY_EXIT"] = 184;
                    values[valuesById[185] = "TYPE_NAMED_ROAD_EXIT"] = 185;
                    values[valuesById[86] = "TYPE_HIGHWAY_EXIT"] = 86;
                    values[valuesById[186] = "TYPE_EXPRESSWAY_EXIT"] = 186;
                    values[valuesById[187] = "TYPE_ONEWAY_STREET"] = 187;
                    values[valuesById[189] = "TYPE_CROSSING_GUARDS"] = 189;
                    values[valuesById[190] = "TYPE_DEADEND"] = 190;
                    values[valuesById[191] = "TYPE_DEADEND_EXCLUDING_DESIGNATED_ACTORS"] = 191;
                    values[valuesById[194] = "TYPE_FIRST_AID_STATION"] = 194;
                    values[valuesById[195] = "TYPE_POLICE_STATION"] = 195;
                    values[valuesById[196] = "TYPE_TELEPHONE"] = 196;
                    values[valuesById[198] = "TYPE_FILLING_STATION"] = 198;
                    values[valuesById[201] = "TYPE_HOTEL"] = 201;
                    values[valuesById[202] = "TYPE_INN"] = 202;
                    values[valuesById[203] = "TYPE_KIOSK"] = 203;
                    values[valuesById[204] = "TYPE_TOILET"] = 204;
                    values[valuesById[205] = "TYPE_CHAPEL"] = 205;
                    values[valuesById[206] = "TYPE_TOURIST_INFO"] = 206;
                    values[valuesById[207] = "TYPE_REPAIR_SERVICE"] = 207;
                    values[valuesById[208] = "TYPE_PEDESTRIAN_UNDERPASS"] = 208;
                    values[valuesById[209] = "TYPE_PEDESTRIAN_BRIDGE"] = 209;
                    values[valuesById[213] = "TYPE_CAMPER_PLACE"] = 213;
                    values[valuesById[214] = "TYPE_ADVISORY_SPEED_LIMIT_BEGIN"] = 214;
                    values[valuesById[215] = "TYPE_ADVISORY_SPEED_LIMIT_END"] = 215;
                    values[valuesById[216] = "TYPE_PLACE_NAME"] = 216;
                    values[valuesById[217] = "TYPE_TOURIST_ATTRACTION"] = 217;
                    values[valuesById[218] = "TYPE_TOURIST_ROUTE"] = 218;
                    values[valuesById[219] = "TYPE_TOURIST_AREA"] = 219;
                    values[valuesById[220] = "TYPE_SHOULDER_NOT_PASSABLE_MOTOR_VEHICLES"] = 220;
                    values[valuesById[221] = "TYPE_SHOULDER_UNSAFE_TRUCKS_TRACTORS"] = 221;
                    values[valuesById[222] = "TYPE_TOLL_BEGIN"] = 222;
                    values[valuesById[223] = "TYPE_TOLL_END"] = 223;
                    values[valuesById[224] = "TYPE_TOLL_ROAD"] = 224;
                    values[valuesById[225] = "TYPE_CUSTOMS"] = 225;
                    values[valuesById[226] = "TYPE_INTERNATIONAL_BORDER_INFO"] = 226;
                    values[valuesById[227] = "TYPE_STREETLIGHT_RED_BAND"] = 227;
                    values[valuesById[228] = "TYPE_FEDERAL_HIGHWAY_ROUTE_NUMBER"] = 228;
                    values[valuesById[229] = "TYPE_HIGHWAY_ROUTE_NUMBER"] = 229;
                    values[valuesById[230] = "TYPE_HIGHWAY_INTERCHANGE_NUMBER"] = 230;
                    values[valuesById[231] = "TYPE_EUROPEAN_ROUTE_NUMBER"] = 231;
                    values[valuesById[232] = "TYPE_FEDERAL_HIGHWAY_DIRECTION_LEFT"] = 232;
                    values[valuesById[233] = "TYPE_FEDERAL_HIGHWAY_DIRECTION_RIGHT"] = 233;
                    values[valuesById[234] = "TYPE_PRIMARY_ROAD_DIRECTION_LEFT"] = 234;
                    values[valuesById[235] = "TYPE_PRIMARY_ROAD_DIRECTION_RIGHT"] = 235;
                    values[valuesById[236] = "TYPE_SECONDARY_ROAD_DIRECTION_LEFT"] = 236;
                    values[valuesById[237] = "TYPE_SECONDARY_ROAD_DIRECTION_RIGHT"] = 237;
                    values[valuesById[238] = "TYPE_DIRECTION_DESIGNATED_ACTORS_LEFT"] = 238;
                    values[valuesById[239] = "TYPE_DIRECTION_DESIGNATED_ACTORS_RIGHT"] = 239;
                    values[valuesById[240] = "TYPE_ROUTING_DESIGNATED_ACTORS"] = 240;
                    values[valuesById[143] = "TYPE_DIRECTION_TO_HIGHWAY_LEFT"] = 143;
                    values[valuesById[108] = "TYPE_DIRECTION_TO_HIGHWAY_RIGHT"] = 108;
                    values[valuesById[127] = "TYPE_DIRECTION_TO_LOCAL_DESTINATION_LEFT"] = 127;
                    values[valuesById[136] = "TYPE_DIRECTION_TO_LOCAL_DESTINATION_RIGHT"] = 136;
                    values[valuesById[118] = "TYPE_CONSOLIDATED_DIRECTIONS"] = 118;
                    values[valuesById[119] = "TYPE_STREET_NAME"] = 119;
                    values[valuesById[120] = "TYPE_DIRECTION_PREANNOUNCEMENT"] = 120;
                    values[valuesById[121] = "TYPE_DIRECTION_PREANNOUNCEMENT_LANE_CONFIG"] = 121;
                    values[valuesById[122] = "TYPE_DIRECTION_PREANNOUNCEMENT_HIGHWAY_ENTRIES"] = 122;
                    values[valuesById[123] = "TYPE_HIGHWAY_ANNOUNCEMENT"] = 123;
                    values[valuesById[124] = "TYPE_OTHER_ROAD_ANNOUNCEMENT"] = 124;
                    values[valuesById[125] = "TYPE_HIGHWAY_ANNOUNCEMENT_TRUCK_STOP"] = 125;
                    values[valuesById[126] = "TYPE_HIGHWAY_PREANNOUNCEMENT_DIRECTIONS"] = 126;
                    values[valuesById[88] = "TYPE_POLE_EXIT"] = 88;
                    values[valuesById[180] = "TYPE_HIGHWAY_DISTANCE_BOARD"] = 180;
                    values[valuesById[181] = "TYPE_DETOUR_LEFT"] = 181;
                    values[valuesById[182] = "TYPE_DETOUR_RIGHT"] = 182;
                    values[valuesById[131] = "TYPE_NUMBERED_DETOUR"] = 131;
                    values[valuesById[132] = "TYPE_DETOUR_BEGIN"] = 132;
                    values[valuesById[133] = "TYPE_DETOUR_END"] = 133;
                    values[valuesById[134] = "TYPE_DETOUR_ROUTING_BOARD"] = 134;
                    values[valuesById[111] = "TYPE_OPTIONAL_DETOUR"] = 111;
                    values[valuesById[199] = "TYPE_OPTIONAL_DETOUR_ROUTING"] = 199;
                    values[valuesById[211] = "TYPE_ROUTE_RECOMMENDATION"] = 211;
                    values[valuesById[212] = "TYPE_ROUTE_RECOMMENDATION_END"] = 212;
                    values[valuesById[192] = "TYPE_ANNOUNCE_LANE_TRANSITION_LEFT"] = 192;
                    values[valuesById[193] = "TYPE_ANNOUNCE_LANE_TRANSITION_RIGHT"] = 193;
                    values[valuesById[90] = "TYPE_ANNOUNCE_RIGHT_LANE_END"] = 90;
                    values[valuesById[89] = "TYPE_ANNOUNCE_LEFT_LANE_END"] = 89;
                    values[valuesById[115] = "TYPE_ANNOUNCE_RIGHT_LANE_BEGIN"] = 115;
                    values[valuesById[116] = "TYPE_ANNOUNCE_LEFT_LANE_BEGIN"] = 116;
                    values[valuesById[117] = "TYPE_ANNOUNCE_LANE_CONSOLIDATION"] = 117;
                    values[valuesById[142] = "TYPE_DETOUR_CITY_BLOCK"] = 142;
                    values[valuesById[141] = "TYPE_GATE"] = 141;
                    values[valuesById[91] = "TYPE_POLE_WARNING"] = 91;
                    values[valuesById[140] = "TYPE_TRAFFIC_CONE"] = 140;
                    values[valuesById[139] = "TYPE_MOBILE_LANE_CLOSURE"] = 139;
                    values[valuesById[114] = "TYPE_REFLECTOR_POST"] = 114;
                    values[valuesById[113] = "TYPE_DIRECTIONAL_BOARD_WARNING"] = 113;
                    values[valuesById[104] = "TYPE_GUIDING_PLATE"] = 104;
                    values[valuesById[105] = "TYPE_GUIDING_PLATE_WEDGES"] = 105;
                    values[valuesById[99] = "TYPE_PARKING_HAZARD"] = 99;
                    values[valuesById[92] = "TYPE_TRAFFIC_LIGHT_GREEN_ARROW"] = 92;
                    return values;
                })();

                /**
                 * DirectionScope enum.
                 * @name osi3.TrafficSign.MainSign.Classification.DirectionScope
                 * @enum {number}
                 * @property {number} DIRECTION_SCOPE_UNKNOWN=0 DIRECTION_SCOPE_UNKNOWN value
                 * @property {number} DIRECTION_SCOPE_OTHER=1 DIRECTION_SCOPE_OTHER value
                 * @property {number} DIRECTION_SCOPE_NO_DIRECTION=2 DIRECTION_SCOPE_NO_DIRECTION value
                 * @property {number} DIRECTION_SCOPE_LEFT=3 DIRECTION_SCOPE_LEFT value
                 * @property {number} DIRECTION_SCOPE_RIGHT=4 DIRECTION_SCOPE_RIGHT value
                 * @property {number} DIRECTION_SCOPE_LEFT_RIGHT=5 DIRECTION_SCOPE_LEFT_RIGHT value
                 */
                Classification.DirectionScope = (function() {
                    const valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "DIRECTION_SCOPE_UNKNOWN"] = 0;
                    values[valuesById[1] = "DIRECTION_SCOPE_OTHER"] = 1;
                    values[valuesById[2] = "DIRECTION_SCOPE_NO_DIRECTION"] = 2;
                    values[valuesById[3] = "DIRECTION_SCOPE_LEFT"] = 3;
                    values[valuesById[4] = "DIRECTION_SCOPE_RIGHT"] = 4;
                    values[valuesById[5] = "DIRECTION_SCOPE_LEFT_RIGHT"] = 5;
                    return values;
                })();

                return Classification;
            })();

            return MainSign;
        })();

        TrafficSign.SupplementarySign = (function() {

            /**
             * Properties of a SupplementarySign.
             * @memberof osi3.TrafficSign
             * @interface ISupplementarySign
             * @property {osi3.IBaseStationary|null} [base] SupplementarySign base
             * @property {osi3.TrafficSign.SupplementarySign.IClassification|null} [classification] SupplementarySign classification
             * @property {string|null} [modelReference] SupplementarySign modelReference
             */

            /**
             * Constructs a new SupplementarySign.
             * @memberof osi3.TrafficSign
             * @classdesc Represents a SupplementarySign.
             * @implements ISupplementarySign
             * @constructor
             * @param {osi3.TrafficSign.ISupplementarySign=} [properties] Properties to set
             */
            function SupplementarySign(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SupplementarySign base.
             * @member {osi3.IBaseStationary|null|undefined} base
             * @memberof osi3.TrafficSign.SupplementarySign
             * @instance
             */
            SupplementarySign.prototype.base = null;

            /**
             * SupplementarySign classification.
             * @member {osi3.TrafficSign.SupplementarySign.IClassification|null|undefined} classification
             * @memberof osi3.TrafficSign.SupplementarySign
             * @instance
             */
            SupplementarySign.prototype.classification = null;

            /**
             * SupplementarySign modelReference.
             * @member {string} modelReference
             * @memberof osi3.TrafficSign.SupplementarySign
             * @instance
             */
            SupplementarySign.prototype.modelReference = "";

            /**
             * Creates a new SupplementarySign instance using the specified properties.
             * @function create
             * @memberof osi3.TrafficSign.SupplementarySign
             * @static
             * @param {osi3.TrafficSign.ISupplementarySign=} [properties] Properties to set
             * @returns {osi3.TrafficSign.SupplementarySign} SupplementarySign instance
             */
            SupplementarySign.create = function create(properties) {
                return new SupplementarySign(properties);
            };

            /**
             * Encodes the specified SupplementarySign message. Does not implicitly {@link osi3.TrafficSign.SupplementarySign.verify|verify} messages.
             * @function encode
             * @memberof osi3.TrafficSign.SupplementarySign
             * @static
             * @param {osi3.TrafficSign.ISupplementarySign} message SupplementarySign message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SupplementarySign.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.base != null && Object.hasOwnProperty.call(message, "base"))
                    $root.osi3.BaseStationary.encode(message.base, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.classification != null && Object.hasOwnProperty.call(message, "classification"))
                    $root.osi3.TrafficSign.SupplementarySign.Classification.encode(message.classification, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.modelReference != null && Object.hasOwnProperty.call(message, "modelReference"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.modelReference);
                return writer;
            };

            /**
             * Encodes the specified SupplementarySign message, length delimited. Does not implicitly {@link osi3.TrafficSign.SupplementarySign.verify|verify} messages.
             * @function encodeDelimited
             * @memberof osi3.TrafficSign.SupplementarySign
             * @static
             * @param {osi3.TrafficSign.ISupplementarySign} message SupplementarySign message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SupplementarySign.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SupplementarySign message from the specified reader or buffer.
             * @function decode
             * @memberof osi3.TrafficSign.SupplementarySign
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {osi3.TrafficSign.SupplementarySign} SupplementarySign
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SupplementarySign.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.osi3.TrafficSign.SupplementarySign();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.base = $root.osi3.BaseStationary.decode(reader, reader.uint32());
                            break;
                        }
                    case 2: {
                            message.classification = $root.osi3.TrafficSign.SupplementarySign.Classification.decode(reader, reader.uint32());
                            break;
                        }
                    case 3: {
                            message.modelReference = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SupplementarySign message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof osi3.TrafficSign.SupplementarySign
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {osi3.TrafficSign.SupplementarySign} SupplementarySign
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SupplementarySign.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SupplementarySign message.
             * @function verify
             * @memberof osi3.TrafficSign.SupplementarySign
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SupplementarySign.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.base != null && message.hasOwnProperty("base")) {
                    let error = $root.osi3.BaseStationary.verify(message.base);
                    if (error)
                        return "base." + error;
                }
                if (message.classification != null && message.hasOwnProperty("classification")) {
                    let error = $root.osi3.TrafficSign.SupplementarySign.Classification.verify(message.classification);
                    if (error)
                        return "classification." + error;
                }
                if (message.modelReference != null && message.hasOwnProperty("modelReference"))
                    if (!$util.isString(message.modelReference))
                        return "modelReference: string expected";
                return null;
            };

            /**
             * Creates a SupplementarySign message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof osi3.TrafficSign.SupplementarySign
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {osi3.TrafficSign.SupplementarySign} SupplementarySign
             */
            SupplementarySign.fromObject = function fromObject(object) {
                if (object instanceof $root.osi3.TrafficSign.SupplementarySign)
                    return object;
                let message = new $root.osi3.TrafficSign.SupplementarySign();
                if (object.base != null) {
                    if (typeof object.base !== "object")
                        throw TypeError(".osi3.TrafficSign.SupplementarySign.base: object expected");
                    message.base = $root.osi3.BaseStationary.fromObject(object.base);
                }
                if (object.classification != null) {
                    if (typeof object.classification !== "object")
                        throw TypeError(".osi3.TrafficSign.SupplementarySign.classification: object expected");
                    message.classification = $root.osi3.TrafficSign.SupplementarySign.Classification.fromObject(object.classification);
                }
                if (object.modelReference != null)
                    message.modelReference = String(object.modelReference);
                return message;
            };

            /**
             * Creates a plain object from a SupplementarySign message. Also converts values to other types if specified.
             * @function toObject
             * @memberof osi3.TrafficSign.SupplementarySign
             * @static
             * @param {osi3.TrafficSign.SupplementarySign} message SupplementarySign
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SupplementarySign.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.base = null;
                    object.classification = null;
                    object.modelReference = "";
                }
                if (message.base != null && message.hasOwnProperty("base"))
                    object.base = $root.osi3.BaseStationary.toObject(message.base, options);
                if (message.classification != null && message.hasOwnProperty("classification"))
                    object.classification = $root.osi3.TrafficSign.SupplementarySign.Classification.toObject(message.classification, options);
                if (message.modelReference != null && message.hasOwnProperty("modelReference"))
                    object.modelReference = message.modelReference;
                return object;
            };

            /**
             * Converts this SupplementarySign to JSON.
             * @function toJSON
             * @memberof osi3.TrafficSign.SupplementarySign
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SupplementarySign.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SupplementarySign
             * @function getTypeUrl
             * @memberof osi3.TrafficSign.SupplementarySign
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SupplementarySign.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/osi3.TrafficSign.SupplementarySign";
            };

            SupplementarySign.Classification = (function() {

                /**
                 * Properties of a Classification.
                 * @memberof osi3.TrafficSign.SupplementarySign
                 * @interface IClassification
                 * @property {osi3.TrafficSign.Variability|null} [variability] Classification variability
                 * @property {osi3.TrafficSign.SupplementarySign.Classification.Type|null} [type] Classification type
                 * @property {Array.<osi3.ITrafficSignValue>|null} [value] Classification value
                 * @property {Array.<osi3.IIdentifier>|null} [assignedLaneId] Classification assignedLaneId
                 * @property {Array.<osi3.TrafficSign.SupplementarySign.Classification.Actor>|null} [actor] Classification actor
                 * @property {Array.<osi3.TrafficSign.SupplementarySign.Classification.IArrow>|null} [arrow] Classification arrow
                 * @property {boolean|null} [isOutOfService] Classification isOutOfService
                 * @property {string|null} [country] Classification country
                 * @property {string|null} [countryRevision] Classification countryRevision
                 * @property {string|null} [code] Classification code
                 * @property {string|null} [subCode] Classification subCode
                 * @property {Array.<osi3.ILogicalLaneAssignment>|null} [logicalLaneAssignment] Classification logicalLaneAssignment
                 */

                /**
                 * Constructs a new Classification.
                 * @memberof osi3.TrafficSign.SupplementarySign
                 * @classdesc Represents a Classification.
                 * @implements IClassification
                 * @constructor
                 * @param {osi3.TrafficSign.SupplementarySign.IClassification=} [properties] Properties to set
                 */
                function Classification(properties) {
                    this.value = [];
                    this.assignedLaneId = [];
                    this.actor = [];
                    this.arrow = [];
                    this.logicalLaneAssignment = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Classification variability.
                 * @member {osi3.TrafficSign.Variability} variability
                 * @memberof osi3.TrafficSign.SupplementarySign.Classification
                 * @instance
                 */
                Classification.prototype.variability = 0;

                /**
                 * Classification type.
                 * @member {osi3.TrafficSign.SupplementarySign.Classification.Type} type
                 * @memberof osi3.TrafficSign.SupplementarySign.Classification
                 * @instance
                 */
                Classification.prototype.type = 0;

                /**
                 * Classification value.
                 * @member {Array.<osi3.ITrafficSignValue>} value
                 * @memberof osi3.TrafficSign.SupplementarySign.Classification
                 * @instance
                 */
                Classification.prototype.value = $util.emptyArray;

                /**
                 * Classification assignedLaneId.
                 * @member {Array.<osi3.IIdentifier>} assignedLaneId
                 * @memberof osi3.TrafficSign.SupplementarySign.Classification
                 * @instance
                 */
                Classification.prototype.assignedLaneId = $util.emptyArray;

                /**
                 * Classification actor.
                 * @member {Array.<osi3.TrafficSign.SupplementarySign.Classification.Actor>} actor
                 * @memberof osi3.TrafficSign.SupplementarySign.Classification
                 * @instance
                 */
                Classification.prototype.actor = $util.emptyArray;

                /**
                 * Classification arrow.
                 * @member {Array.<osi3.TrafficSign.SupplementarySign.Classification.IArrow>} arrow
                 * @memberof osi3.TrafficSign.SupplementarySign.Classification
                 * @instance
                 */
                Classification.prototype.arrow = $util.emptyArray;

                /**
                 * Classification isOutOfService.
                 * @member {boolean} isOutOfService
                 * @memberof osi3.TrafficSign.SupplementarySign.Classification
                 * @instance
                 */
                Classification.prototype.isOutOfService = false;

                /**
                 * Classification country.
                 * @member {string} country
                 * @memberof osi3.TrafficSign.SupplementarySign.Classification
                 * @instance
                 */
                Classification.prototype.country = "";

                /**
                 * Classification countryRevision.
                 * @member {string} countryRevision
                 * @memberof osi3.TrafficSign.SupplementarySign.Classification
                 * @instance
                 */
                Classification.prototype.countryRevision = "";

                /**
                 * Classification code.
                 * @member {string} code
                 * @memberof osi3.TrafficSign.SupplementarySign.Classification
                 * @instance
                 */
                Classification.prototype.code = "";

                /**
                 * Classification subCode.
                 * @member {string} subCode
                 * @memberof osi3.TrafficSign.SupplementarySign.Classification
                 * @instance
                 */
                Classification.prototype.subCode = "";

                /**
                 * Classification logicalLaneAssignment.
                 * @member {Array.<osi3.ILogicalLaneAssignment>} logicalLaneAssignment
                 * @memberof osi3.TrafficSign.SupplementarySign.Classification
                 * @instance
                 */
                Classification.prototype.logicalLaneAssignment = $util.emptyArray;

                /**
                 * Creates a new Classification instance using the specified properties.
                 * @function create
                 * @memberof osi3.TrafficSign.SupplementarySign.Classification
                 * @static
                 * @param {osi3.TrafficSign.SupplementarySign.IClassification=} [properties] Properties to set
                 * @returns {osi3.TrafficSign.SupplementarySign.Classification} Classification instance
                 */
                Classification.create = function create(properties) {
                    return new Classification(properties);
                };

                /**
                 * Encodes the specified Classification message. Does not implicitly {@link osi3.TrafficSign.SupplementarySign.Classification.verify|verify} messages.
                 * @function encode
                 * @memberof osi3.TrafficSign.SupplementarySign.Classification
                 * @static
                 * @param {osi3.TrafficSign.SupplementarySign.IClassification} message Classification message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Classification.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.variability != null && Object.hasOwnProperty.call(message, "variability"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.variability);
                    if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
                    if (message.value != null && message.value.length)
                        for (let i = 0; i < message.value.length; ++i)
                            $root.osi3.TrafficSignValue.encode(message.value[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.assignedLaneId != null && message.assignedLaneId.length)
                        for (let i = 0; i < message.assignedLaneId.length; ++i)
                            $root.osi3.Identifier.encode(message.assignedLaneId[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.actor != null && message.actor.length)
                        for (let i = 0; i < message.actor.length; ++i)
                            writer.uint32(/* id 5, wireType 0 =*/40).int32(message.actor[i]);
                    if (message.arrow != null && message.arrow.length)
                        for (let i = 0; i < message.arrow.length; ++i)
                            $root.osi3.TrafficSign.SupplementarySign.Classification.Arrow.encode(message.arrow[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                    if (message.isOutOfService != null && Object.hasOwnProperty.call(message, "isOutOfService"))
                        writer.uint32(/* id 7, wireType 0 =*/56).bool(message.isOutOfService);
                    if (message.country != null && Object.hasOwnProperty.call(message, "country"))
                        writer.uint32(/* id 8, wireType 2 =*/66).string(message.country);
                    if (message.countryRevision != null && Object.hasOwnProperty.call(message, "countryRevision"))
                        writer.uint32(/* id 9, wireType 2 =*/74).string(message.countryRevision);
                    if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                        writer.uint32(/* id 10, wireType 2 =*/82).string(message.code);
                    if (message.subCode != null && Object.hasOwnProperty.call(message, "subCode"))
                        writer.uint32(/* id 11, wireType 2 =*/90).string(message.subCode);
                    if (message.logicalLaneAssignment != null && message.logicalLaneAssignment.length)
                        for (let i = 0; i < message.logicalLaneAssignment.length; ++i)
                            $root.osi3.LogicalLaneAssignment.encode(message.logicalLaneAssignment[i], writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified Classification message, length delimited. Does not implicitly {@link osi3.TrafficSign.SupplementarySign.Classification.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof osi3.TrafficSign.SupplementarySign.Classification
                 * @static
                 * @param {osi3.TrafficSign.SupplementarySign.IClassification} message Classification message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Classification.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Classification message from the specified reader or buffer.
                 * @function decode
                 * @memberof osi3.TrafficSign.SupplementarySign.Classification
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {osi3.TrafficSign.SupplementarySign.Classification} Classification
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Classification.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.osi3.TrafficSign.SupplementarySign.Classification();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                message.variability = reader.int32();
                                break;
                            }
                        case 2: {
                                message.type = reader.int32();
                                break;
                            }
                        case 3: {
                                if (!(message.value && message.value.length))
                                    message.value = [];
                                message.value.push($root.osi3.TrafficSignValue.decode(reader, reader.uint32()));
                                break;
                            }
                        case 4: {
                                if (!(message.assignedLaneId && message.assignedLaneId.length))
                                    message.assignedLaneId = [];
                                message.assignedLaneId.push($root.osi3.Identifier.decode(reader, reader.uint32()));
                                break;
                            }
                        case 5: {
                                if (!(message.actor && message.actor.length))
                                    message.actor = [];
                                if ((tag & 7) === 2) {
                                    let end2 = reader.uint32() + reader.pos;
                                    while (reader.pos < end2)
                                        message.actor.push(reader.int32());
                                } else
                                    message.actor.push(reader.int32());
                                break;
                            }
                        case 6: {
                                if (!(message.arrow && message.arrow.length))
                                    message.arrow = [];
                                message.arrow.push($root.osi3.TrafficSign.SupplementarySign.Classification.Arrow.decode(reader, reader.uint32()));
                                break;
                            }
                        case 7: {
                                message.isOutOfService = reader.bool();
                                break;
                            }
                        case 8: {
                                message.country = reader.string();
                                break;
                            }
                        case 9: {
                                message.countryRevision = reader.string();
                                break;
                            }
                        case 10: {
                                message.code = reader.string();
                                break;
                            }
                        case 11: {
                                message.subCode = reader.string();
                                break;
                            }
                        case 12: {
                                if (!(message.logicalLaneAssignment && message.logicalLaneAssignment.length))
                                    message.logicalLaneAssignment = [];
                                message.logicalLaneAssignment.push($root.osi3.LogicalLaneAssignment.decode(reader, reader.uint32()));
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Classification message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof osi3.TrafficSign.SupplementarySign.Classification
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {osi3.TrafficSign.SupplementarySign.Classification} Classification
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Classification.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Classification message.
                 * @function verify
                 * @memberof osi3.TrafficSign.SupplementarySign.Classification
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Classification.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.variability != null && message.hasOwnProperty("variability"))
                        switch (message.variability) {
                        default:
                            return "variability: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                            break;
                        }
                    if (message.type != null && message.hasOwnProperty("type"))
                        switch (message.type) {
                        default:
                            return "type: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 41:
                        case 39:
                        case 26:
                        case 30:
                        case 46:
                        case 45:
                        case 3:
                        case 27:
                        case 28:
                        case 32:
                        case 33:
                        case 34:
                        case 29:
                        case 31:
                        case 35:
                        case 36:
                        case 37:
                        case 4:
                        case 25:
                        case 11:
                        case 13:
                        case 12:
                        case 14:
                        case 40:
                        case 9:
                        case 8:
                        case 48:
                        case 47:
                        case 5:
                        case 43:
                        case 6:
                        case 44:
                        case 42:
                        case 38:
                        case 7:
                        case 10:
                        case 19:
                        case 21:
                        case 15:
                        case 16:
                        case 17:
                        case 18:
                        case 20:
                        case 22:
                        case 23:
                        case 24:
                            break;
                        }
                    if (message.value != null && message.hasOwnProperty("value")) {
                        if (!Array.isArray(message.value))
                            return "value: array expected";
                        for (let i = 0; i < message.value.length; ++i) {
                            let error = $root.osi3.TrafficSignValue.verify(message.value[i]);
                            if (error)
                                return "value." + error;
                        }
                    }
                    if (message.assignedLaneId != null && message.hasOwnProperty("assignedLaneId")) {
                        if (!Array.isArray(message.assignedLaneId))
                            return "assignedLaneId: array expected";
                        for (let i = 0; i < message.assignedLaneId.length; ++i) {
                            let error = $root.osi3.Identifier.verify(message.assignedLaneId[i]);
                            if (error)
                                return "assignedLaneId." + error;
                        }
                    }
                    if (message.actor != null && message.hasOwnProperty("actor")) {
                        if (!Array.isArray(message.actor))
                            return "actor: array expected";
                        for (let i = 0; i < message.actor.length; ++i)
                            switch (message.actor[i]) {
                            default:
                                return "actor: enum value[] expected";
                            case 0:
                            case 1:
                            case 2:
                            case 3:
                            case 4:
                            case 5:
                            case 6:
                            case 7:
                            case 8:
                            case 9:
                            case 10:
                            case 11:
                            case 12:
                            case 13:
                            case 14:
                            case 15:
                            case 16:
                            case 17:
                            case 18:
                            case 19:
                            case 20:
                            case 21:
                            case 22:
                            case 23:
                            case 24:
                            case 25:
                            case 26:
                            case 27:
                            case 28:
                            case 29:
                            case 30:
                            case 31:
                            case 32:
                            case 33:
                            case 34:
                            case 35:
                            case 36:
                            case 37:
                            case 38:
                            case 39:
                            case 40:
                            case 41:
                            case 42:
                            case 43:
                            case 44:
                            case 45:
                            case 46:
                            case 47:
                                break;
                            }
                    }
                    if (message.arrow != null && message.hasOwnProperty("arrow")) {
                        if (!Array.isArray(message.arrow))
                            return "arrow: array expected";
                        for (let i = 0; i < message.arrow.length; ++i) {
                            let error = $root.osi3.TrafficSign.SupplementarySign.Classification.Arrow.verify(message.arrow[i]);
                            if (error)
                                return "arrow." + error;
                        }
                    }
                    if (message.isOutOfService != null && message.hasOwnProperty("isOutOfService"))
                        if (typeof message.isOutOfService !== "boolean")
                            return "isOutOfService: boolean expected";
                    if (message.country != null && message.hasOwnProperty("country"))
                        if (!$util.isString(message.country))
                            return "country: string expected";
                    if (message.countryRevision != null && message.hasOwnProperty("countryRevision"))
                        if (!$util.isString(message.countryRevision))
                            return "countryRevision: string expected";
                    if (message.code != null && message.hasOwnProperty("code"))
                        if (!$util.isString(message.code))
                            return "code: string expected";
                    if (message.subCode != null && message.hasOwnProperty("subCode"))
                        if (!$util.isString(message.subCode))
                            return "subCode: string expected";
                    if (message.logicalLaneAssignment != null && message.hasOwnProperty("logicalLaneAssignment")) {
                        if (!Array.isArray(message.logicalLaneAssignment))
                            return "logicalLaneAssignment: array expected";
                        for (let i = 0; i < message.logicalLaneAssignment.length; ++i) {
                            let error = $root.osi3.LogicalLaneAssignment.verify(message.logicalLaneAssignment[i]);
                            if (error)
                                return "logicalLaneAssignment." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a Classification message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof osi3.TrafficSign.SupplementarySign.Classification
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {osi3.TrafficSign.SupplementarySign.Classification} Classification
                 */
                Classification.fromObject = function fromObject(object) {
                    if (object instanceof $root.osi3.TrafficSign.SupplementarySign.Classification)
                        return object;
                    let message = new $root.osi3.TrafficSign.SupplementarySign.Classification();
                    switch (object.variability) {
                    default:
                        if (typeof object.variability === "number") {
                            message.variability = object.variability;
                            break;
                        }
                        break;
                    case "VARIABILITY_UNKNOWN":
                    case 0:
                        message.variability = 0;
                        break;
                    case "VARIABILITY_OTHER":
                    case 1:
                        message.variability = 1;
                        break;
                    case "VARIABILITY_FIXED":
                    case 2:
                        message.variability = 2;
                        break;
                    case "VARIABILITY_VARIABLE":
                    case 3:
                        message.variability = 3;
                        break;
                    case "VARIABILITY_MOVABLE":
                    case 4:
                        message.variability = 4;
                        break;
                    case "VARIABILITY_MUTABLE":
                    case 5:
                        message.variability = 5;
                        break;
                    case "VARIABILITY_MOVABLE_AND_MUTABLE":
                    case 6:
                        message.variability = 6;
                        break;
                    }
                    switch (object.type) {
                    default:
                        if (typeof object.type === "number") {
                            message.type = object.type;
                            break;
                        }
                        break;
                    case "TYPE_UNKNOWN":
                    case 0:
                        message.type = 0;
                        break;
                    case "TYPE_OTHER":
                    case 1:
                        message.type = 1;
                        break;
                    case "TYPE_NO_SIGN":
                    case 2:
                        message.type = 2;
                        break;
                    case "TYPE_TEXT":
                    case 41:
                        message.type = 41;
                        break;
                    case "TYPE_SPACE":
                    case 39:
                        message.type = 39;
                        break;
                    case "TYPE_TIME":
                    case 26:
                        message.type = 26;
                        break;
                    case "TYPE_ARROW":
                    case 30:
                        message.type = 30;
                        break;
                    case "TYPE_CONSTRAINED_TO":
                    case 46:
                        message.type = 46;
                        break;
                    case "TYPE_EXCEPT":
                    case 45:
                        message.type = 45;
                        break;
                    case "TYPE_VALID_FOR_DISTANCE":
                    case 3:
                        message.type = 3;
                        break;
                    case "TYPE_PRIORITY_ROAD_BOTTOM_LEFT_FOUR_WAY":
                    case 27:
                        message.type = 27;
                        break;
                    case "TYPE_PRIORITY_ROAD_TOP_LEFT_FOUR_WAY":
                    case 28:
                        message.type = 28;
                        break;
                    case "TYPE_PRIORITY_ROAD_BOTTOM_LEFT_THREE_WAY_STRAIGHT":
                    case 32:
                        message.type = 32;
                        break;
                    case "TYPE_PRIORITY_ROAD_BOTTOM_LEFT_THREE_WAY_SIDEWAYS":
                    case 33:
                        message.type = 33;
                        break;
                    case "TYPE_PRIORITY_ROAD_TOP_LEFT_THREE_WAY_STRAIGHT":
                    case 34:
                        message.type = 34;
                        break;
                    case "TYPE_PRIORITY_ROAD_BOTTOM_RIGHT_FOUR_WAY":
                    case 29:
                        message.type = 29;
                        break;
                    case "TYPE_PRIORITY_ROAD_TOP_RIGHT_FOUR_WAY":
                    case 31:
                        message.type = 31;
                        break;
                    case "TYPE_PRIORITY_ROAD_BOTTOM_RIGHT_THREE_WAY_STRAIGHT":
                    case 35:
                        message.type = 35;
                        break;
                    case "TYPE_PRIORITY_ROAD_BOTTOM_RIGHT_THREE_WAY_SIDEWAY":
                    case 36:
                        message.type = 36;
                        break;
                    case "TYPE_PRIORITY_ROAD_TOP_RIGHT_THREE_WAY_STRAIGHT":
                    case 37:
                        message.type = 37;
                        break;
                    case "TYPE_VALID_IN_DISTANCE":
                    case 4:
                        message.type = 4;
                        break;
                    case "TYPE_STOP_IN":
                    case 25:
                        message.type = 25;
                        break;
                    case "TYPE_LEFT_ARROW":
                    case 11:
                        message.type = 11;
                        break;
                    case "TYPE_LEFT_BEND_ARROW":
                    case 13:
                        message.type = 13;
                        break;
                    case "TYPE_RIGHT_ARROW":
                    case 12:
                        message.type = 12;
                        break;
                    case "TYPE_RIGHT_BEND_ARROW":
                    case 14:
                        message.type = 14;
                        break;
                    case "TYPE_ACCIDENT":
                    case 40:
                        message.type = 40;
                        break;
                    case "TYPE_SNOW":
                    case 9:
                        message.type = 9;
                        break;
                    case "TYPE_FOG":
                    case 8:
                        message.type = 8;
                        break;
                    case "TYPE_ROLLING_HIGHWAY_INFORMATION":
                    case 48:
                        message.type = 48;
                        break;
                    case "TYPE_SERVICES":
                    case 47:
                        message.type = 47;
                        break;
                    case "TYPE_TIME_RANGE":
                    case 5:
                        message.type = 5;
                        break;
                    case "TYPE_PARKING_DISC_TIME_RESTRICTION":
                    case 43:
                        message.type = 43;
                        break;
                    case "TYPE_WEIGHT":
                    case 6:
                        message.type = 6;
                        break;
                    case "TYPE_WET":
                    case 44:
                        message.type = 44;
                        break;
                    case "TYPE_PARKING_CONSTRAINT":
                    case 42:
                        message.type = 42;
                        break;
                    case "TYPE_NO_WAITING_SIDE_STRIPES":
                    case 38:
                        message.type = 38;
                        break;
                    case "TYPE_RAIN":
                    case 7:
                        message.type = 7;
                        break;
                    case "TYPE_SNOW_RAIN":
                    case 10:
                        message.type = 10;
                        break;
                    case "TYPE_NIGHT":
                    case 19:
                        message.type = 19;
                        break;
                    case "TYPE_STOP_4_WAY":
                    case 21:
                        message.type = 21;
                        break;
                    case "TYPE_TRUCK":
                    case 15:
                        message.type = 15;
                        break;
                    case "TYPE_TRACTORS_MAY_BE_PASSED":
                    case 16:
                        message.type = 16;
                        break;
                    case "TYPE_HAZARDOUS":
                    case 17:
                        message.type = 17;
                        break;
                    case "TYPE_TRAILER":
                    case 18:
                        message.type = 18;
                        break;
                    case "TYPE_ZONE":
                    case 20:
                        message.type = 20;
                        break;
                    case "TYPE_MOTORCYCLE":
                    case 22:
                        message.type = 22;
                        break;
                    case "TYPE_MOTORCYCLE_ALLOWED":
                    case 23:
                        message.type = 23;
                        break;
                    case "TYPE_CAR":
                    case 24:
                        message.type = 24;
                        break;
                    }
                    if (object.value) {
                        if (!Array.isArray(object.value))
                            throw TypeError(".osi3.TrafficSign.SupplementarySign.Classification.value: array expected");
                        message.value = [];
                        for (let i = 0; i < object.value.length; ++i) {
                            if (typeof object.value[i] !== "object")
                                throw TypeError(".osi3.TrafficSign.SupplementarySign.Classification.value: object expected");
                            message.value[i] = $root.osi3.TrafficSignValue.fromObject(object.value[i]);
                        }
                    }
                    if (object.assignedLaneId) {
                        if (!Array.isArray(object.assignedLaneId))
                            throw TypeError(".osi3.TrafficSign.SupplementarySign.Classification.assignedLaneId: array expected");
                        message.assignedLaneId = [];
                        for (let i = 0; i < object.assignedLaneId.length; ++i) {
                            if (typeof object.assignedLaneId[i] !== "object")
                                throw TypeError(".osi3.TrafficSign.SupplementarySign.Classification.assignedLaneId: object expected");
                            message.assignedLaneId[i] = $root.osi3.Identifier.fromObject(object.assignedLaneId[i]);
                        }
                    }
                    if (object.actor) {
                        if (!Array.isArray(object.actor))
                            throw TypeError(".osi3.TrafficSign.SupplementarySign.Classification.actor: array expected");
                        message.actor = [];
                        for (let i = 0; i < object.actor.length; ++i)
                            switch (object.actor[i]) {
                            default:
                                if (typeof object.actor[i] === "number") {
                                    message.actor[i] = object.actor[i];
                                    break;
                                }
                            case "ACTOR_UNKNOWN":
                            case 0:
                                message.actor[i] = 0;
                                break;
                            case "ACTOR_OTHER":
                            case 1:
                                message.actor[i] = 1;
                                break;
                            case "ACTOR_NO_ACTOR":
                            case 2:
                                message.actor[i] = 2;
                                break;
                            case "ACTOR_AGRICULTURAL_VEHICLES":
                            case 3:
                                message.actor[i] = 3;
                                break;
                            case "ACTOR_BICYCLES":
                            case 4:
                                message.actor[i] = 4;
                                break;
                            case "ACTOR_BUSES":
                            case 5:
                                message.actor[i] = 5;
                                break;
                            case "ACTOR_CAMPERS":
                            case 6:
                                message.actor[i] = 6;
                                break;
                            case "ACTOR_CARAVANS":
                            case 7:
                                message.actor[i] = 7;
                                break;
                            case "ACTOR_CARS":
                            case 8:
                                message.actor[i] = 8;
                                break;
                            case "ACTOR_CARS_WITH_CARAVANS":
                            case 9:
                                message.actor[i] = 9;
                                break;
                            case "ACTOR_CARS_WITH_TRAILERS":
                            case 10:
                                message.actor[i] = 10;
                                break;
                            case "ACTOR_CATTLE":
                            case 11:
                                message.actor[i] = 11;
                                break;
                            case "ACTOR_CHILDREN":
                            case 12:
                                message.actor[i] = 12;
                                break;
                            case "ACTOR_CONSTRUCTION_VEHICLES":
                            case 13:
                                message.actor[i] = 13;
                                break;
                            case "ACTOR_DELIVERY_VEHICLES":
                            case 14:
                                message.actor[i] = 14;
                                break;
                            case "ACTOR_DISABLED_PERSONS":
                            case 15:
                                message.actor[i] = 15;
                                break;
                            case "ACTOR_EBIKES":
                            case 16:
                                message.actor[i] = 16;
                                break;
                            case "ACTOR_ELECTRIC_VEHICLES":
                            case 17:
                                message.actor[i] = 17;
                                break;
                            case "ACTOR_EMERGENCY_VEHICLES":
                            case 18:
                                message.actor[i] = 18;
                                break;
                            case "ACTOR_FERRY_USERS":
                            case 19:
                                message.actor[i] = 19;
                                break;
                            case "ACTOR_FORESTRY_VEHICLES":
                            case 20:
                                message.actor[i] = 20;
                                break;
                            case "ACTOR_HAZARDOUS_GOODS_VEHICLES":
                            case 21:
                                message.actor[i] = 21;
                                break;
                            case "ACTOR_HORSE_CARRIAGES":
                            case 22:
                                message.actor[i] = 22;
                                break;
                            case "ACTOR_HORSE_RIDERS":
                            case 23:
                                message.actor[i] = 23;
                                break;
                            case "ACTOR_INLINE_SKATERS":
                            case 24:
                                message.actor[i] = 24;
                                break;
                            case "ACTOR_MEDICAL_VEHICLES":
                            case 25:
                                message.actor[i] = 25;
                                break;
                            case "ACTOR_MILITARY_VEHICLES":
                            case 26:
                                message.actor[i] = 26;
                                break;
                            case "ACTOR_MOPEDS":
                            case 27:
                                message.actor[i] = 27;
                                break;
                            case "ACTOR_MOTORCYCLES":
                            case 28:
                                message.actor[i] = 28;
                                break;
                            case "ACTOR_MOTORIZED_MULTITRACK_VEHICLES":
                            case 29:
                                message.actor[i] = 29;
                                break;
                            case "ACTOR_OPERATIONAL_AND_UTILITY_VEHICLES":
                            case 30:
                                message.actor[i] = 30;
                                break;
                            case "ACTOR_PEDESTRIANS":
                            case 31:
                                message.actor[i] = 31;
                                break;
                            case "ACTOR_PUBLIC_TRANSPORT_VEHICLES":
                            case 32:
                                message.actor[i] = 32;
                                break;
                            case "ACTOR_RAILROAD_TRAFFIC":
                            case 33:
                                message.actor[i] = 33;
                                break;
                            case "ACTOR_RESIDENTS":
                            case 34:
                                message.actor[i] = 34;
                                break;
                            case "ACTOR_SLURRY_TRANSPORT":
                            case 35:
                                message.actor[i] = 35;
                                break;
                            case "ACTOR_TAXIS":
                            case 36:
                                message.actor[i] = 36;
                                break;
                            case "ACTOR_TRACTORS":
                            case 37:
                                message.actor[i] = 37;
                                break;
                            case "ACTOR_TRAILERS":
                            case 38:
                                message.actor[i] = 38;
                                break;
                            case "ACTOR_TRAMS":
                            case 39:
                                message.actor[i] = 39;
                                break;
                            case "ACTOR_TRUCKS":
                            case 40:
                                message.actor[i] = 40;
                                break;
                            case "ACTOR_TRUCKS_WITH_SEMITRAILERS":
                            case 41:
                                message.actor[i] = 41;
                                break;
                            case "ACTOR_TRUCKS_WITH_TRAILERS":
                            case 42:
                                message.actor[i] = 42;
                                break;
                            case "ACTOR_VEHICLES_WITH_GREEN_BADGES":
                            case 43:
                                message.actor[i] = 43;
                                break;
                            case "ACTOR_VEHICLES_WITH_RED_BADGES":
                            case 44:
                                message.actor[i] = 44;
                                break;
                            case "ACTOR_VEHICLES_WITH_YELLOW_BADGES":
                            case 45:
                                message.actor[i] = 45;
                                break;
                            case "ACTOR_WATER_POLLUTANT_VEHICLES":
                            case 46:
                                message.actor[i] = 46;
                                break;
                            case "ACTOR_WINTER_SPORTSPEOPLE":
                            case 47:
                                message.actor[i] = 47;
                                break;
                            }
                    }
                    if (object.arrow) {
                        if (!Array.isArray(object.arrow))
                            throw TypeError(".osi3.TrafficSign.SupplementarySign.Classification.arrow: array expected");
                        message.arrow = [];
                        for (let i = 0; i < object.arrow.length; ++i) {
                            if (typeof object.arrow[i] !== "object")
                                throw TypeError(".osi3.TrafficSign.SupplementarySign.Classification.arrow: object expected");
                            message.arrow[i] = $root.osi3.TrafficSign.SupplementarySign.Classification.Arrow.fromObject(object.arrow[i]);
                        }
                    }
                    if (object.isOutOfService != null)
                        message.isOutOfService = Boolean(object.isOutOfService);
                    if (object.country != null)
                        message.country = String(object.country);
                    if (object.countryRevision != null)
                        message.countryRevision = String(object.countryRevision);
                    if (object.code != null)
                        message.code = String(object.code);
                    if (object.subCode != null)
                        message.subCode = String(object.subCode);
                    if (object.logicalLaneAssignment) {
                        if (!Array.isArray(object.logicalLaneAssignment))
                            throw TypeError(".osi3.TrafficSign.SupplementarySign.Classification.logicalLaneAssignment: array expected");
                        message.logicalLaneAssignment = [];
                        for (let i = 0; i < object.logicalLaneAssignment.length; ++i) {
                            if (typeof object.logicalLaneAssignment[i] !== "object")
                                throw TypeError(".osi3.TrafficSign.SupplementarySign.Classification.logicalLaneAssignment: object expected");
                            message.logicalLaneAssignment[i] = $root.osi3.LogicalLaneAssignment.fromObject(object.logicalLaneAssignment[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Classification message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof osi3.TrafficSign.SupplementarySign.Classification
                 * @static
                 * @param {osi3.TrafficSign.SupplementarySign.Classification} message Classification
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Classification.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults) {
                        object.value = [];
                        object.assignedLaneId = [];
                        object.actor = [];
                        object.arrow = [];
                        object.logicalLaneAssignment = [];
                    }
                    if (options.defaults) {
                        object.variability = options.enums === String ? "VARIABILITY_UNKNOWN" : 0;
                        object.type = options.enums === String ? "TYPE_UNKNOWN" : 0;
                        object.isOutOfService = false;
                        object.country = "";
                        object.countryRevision = "";
                        object.code = "";
                        object.subCode = "";
                    }
                    if (message.variability != null && message.hasOwnProperty("variability"))
                        object.variability = options.enums === String ? $root.osi3.TrafficSign.Variability[message.variability] === undefined ? message.variability : $root.osi3.TrafficSign.Variability[message.variability] : message.variability;
                    if (message.type != null && message.hasOwnProperty("type"))
                        object.type = options.enums === String ? $root.osi3.TrafficSign.SupplementarySign.Classification.Type[message.type] === undefined ? message.type : $root.osi3.TrafficSign.SupplementarySign.Classification.Type[message.type] : message.type;
                    if (message.value && message.value.length) {
                        object.value = [];
                        for (let j = 0; j < message.value.length; ++j)
                            object.value[j] = $root.osi3.TrafficSignValue.toObject(message.value[j], options);
                    }
                    if (message.assignedLaneId && message.assignedLaneId.length) {
                        object.assignedLaneId = [];
                        for (let j = 0; j < message.assignedLaneId.length; ++j)
                            object.assignedLaneId[j] = $root.osi3.Identifier.toObject(message.assignedLaneId[j], options);
                    }
                    if (message.actor && message.actor.length) {
                        object.actor = [];
                        for (let j = 0; j < message.actor.length; ++j)
                            object.actor[j] = options.enums === String ? $root.osi3.TrafficSign.SupplementarySign.Classification.Actor[message.actor[j]] === undefined ? message.actor[j] : $root.osi3.TrafficSign.SupplementarySign.Classification.Actor[message.actor[j]] : message.actor[j];
                    }
                    if (message.arrow && message.arrow.length) {
                        object.arrow = [];
                        for (let j = 0; j < message.arrow.length; ++j)
                            object.arrow[j] = $root.osi3.TrafficSign.SupplementarySign.Classification.Arrow.toObject(message.arrow[j], options);
                    }
                    if (message.isOutOfService != null && message.hasOwnProperty("isOutOfService"))
                        object.isOutOfService = message.isOutOfService;
                    if (message.country != null && message.hasOwnProperty("country"))
                        object.country = message.country;
                    if (message.countryRevision != null && message.hasOwnProperty("countryRevision"))
                        object.countryRevision = message.countryRevision;
                    if (message.code != null && message.hasOwnProperty("code"))
                        object.code = message.code;
                    if (message.subCode != null && message.hasOwnProperty("subCode"))
                        object.subCode = message.subCode;
                    if (message.logicalLaneAssignment && message.logicalLaneAssignment.length) {
                        object.logicalLaneAssignment = [];
                        for (let j = 0; j < message.logicalLaneAssignment.length; ++j)
                            object.logicalLaneAssignment[j] = $root.osi3.LogicalLaneAssignment.toObject(message.logicalLaneAssignment[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this Classification to JSON.
                 * @function toJSON
                 * @memberof osi3.TrafficSign.SupplementarySign.Classification
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Classification.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for Classification
                 * @function getTypeUrl
                 * @memberof osi3.TrafficSign.SupplementarySign.Classification
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                Classification.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/osi3.TrafficSign.SupplementarySign.Classification";
                };

                /**
                 * Type enum.
                 * @name osi3.TrafficSign.SupplementarySign.Classification.Type
                 * @enum {number}
                 * @property {number} TYPE_UNKNOWN=0 TYPE_UNKNOWN value
                 * @property {number} TYPE_OTHER=1 TYPE_OTHER value
                 * @property {number} TYPE_NO_SIGN=2 TYPE_NO_SIGN value
                 * @property {number} TYPE_TEXT=41 TYPE_TEXT value
                 * @property {number} TYPE_SPACE=39 TYPE_SPACE value
                 * @property {number} TYPE_TIME=26 TYPE_TIME value
                 * @property {number} TYPE_ARROW=30 TYPE_ARROW value
                 * @property {number} TYPE_CONSTRAINED_TO=46 TYPE_CONSTRAINED_TO value
                 * @property {number} TYPE_EXCEPT=45 TYPE_EXCEPT value
                 * @property {number} TYPE_VALID_FOR_DISTANCE=3 TYPE_VALID_FOR_DISTANCE value
                 * @property {number} TYPE_PRIORITY_ROAD_BOTTOM_LEFT_FOUR_WAY=27 TYPE_PRIORITY_ROAD_BOTTOM_LEFT_FOUR_WAY value
                 * @property {number} TYPE_PRIORITY_ROAD_TOP_LEFT_FOUR_WAY=28 TYPE_PRIORITY_ROAD_TOP_LEFT_FOUR_WAY value
                 * @property {number} TYPE_PRIORITY_ROAD_BOTTOM_LEFT_THREE_WAY_STRAIGHT=32 TYPE_PRIORITY_ROAD_BOTTOM_LEFT_THREE_WAY_STRAIGHT value
                 * @property {number} TYPE_PRIORITY_ROAD_BOTTOM_LEFT_THREE_WAY_SIDEWAYS=33 TYPE_PRIORITY_ROAD_BOTTOM_LEFT_THREE_WAY_SIDEWAYS value
                 * @property {number} TYPE_PRIORITY_ROAD_TOP_LEFT_THREE_WAY_STRAIGHT=34 TYPE_PRIORITY_ROAD_TOP_LEFT_THREE_WAY_STRAIGHT value
                 * @property {number} TYPE_PRIORITY_ROAD_BOTTOM_RIGHT_FOUR_WAY=29 TYPE_PRIORITY_ROAD_BOTTOM_RIGHT_FOUR_WAY value
                 * @property {number} TYPE_PRIORITY_ROAD_TOP_RIGHT_FOUR_WAY=31 TYPE_PRIORITY_ROAD_TOP_RIGHT_FOUR_WAY value
                 * @property {number} TYPE_PRIORITY_ROAD_BOTTOM_RIGHT_THREE_WAY_STRAIGHT=35 TYPE_PRIORITY_ROAD_BOTTOM_RIGHT_THREE_WAY_STRAIGHT value
                 * @property {number} TYPE_PRIORITY_ROAD_BOTTOM_RIGHT_THREE_WAY_SIDEWAY=36 TYPE_PRIORITY_ROAD_BOTTOM_RIGHT_THREE_WAY_SIDEWAY value
                 * @property {number} TYPE_PRIORITY_ROAD_TOP_RIGHT_THREE_WAY_STRAIGHT=37 TYPE_PRIORITY_ROAD_TOP_RIGHT_THREE_WAY_STRAIGHT value
                 * @property {number} TYPE_VALID_IN_DISTANCE=4 TYPE_VALID_IN_DISTANCE value
                 * @property {number} TYPE_STOP_IN=25 TYPE_STOP_IN value
                 * @property {number} TYPE_LEFT_ARROW=11 TYPE_LEFT_ARROW value
                 * @property {number} TYPE_LEFT_BEND_ARROW=13 TYPE_LEFT_BEND_ARROW value
                 * @property {number} TYPE_RIGHT_ARROW=12 TYPE_RIGHT_ARROW value
                 * @property {number} TYPE_RIGHT_BEND_ARROW=14 TYPE_RIGHT_BEND_ARROW value
                 * @property {number} TYPE_ACCIDENT=40 TYPE_ACCIDENT value
                 * @property {number} TYPE_SNOW=9 TYPE_SNOW value
                 * @property {number} TYPE_FOG=8 TYPE_FOG value
                 * @property {number} TYPE_ROLLING_HIGHWAY_INFORMATION=48 TYPE_ROLLING_HIGHWAY_INFORMATION value
                 * @property {number} TYPE_SERVICES=47 TYPE_SERVICES value
                 * @property {number} TYPE_TIME_RANGE=5 TYPE_TIME_RANGE value
                 * @property {number} TYPE_PARKING_DISC_TIME_RESTRICTION=43 TYPE_PARKING_DISC_TIME_RESTRICTION value
                 * @property {number} TYPE_WEIGHT=6 TYPE_WEIGHT value
                 * @property {number} TYPE_WET=44 TYPE_WET value
                 * @property {number} TYPE_PARKING_CONSTRAINT=42 TYPE_PARKING_CONSTRAINT value
                 * @property {number} TYPE_NO_WAITING_SIDE_STRIPES=38 TYPE_NO_WAITING_SIDE_STRIPES value
                 * @property {number} TYPE_RAIN=7 TYPE_RAIN value
                 * @property {number} TYPE_SNOW_RAIN=10 TYPE_SNOW_RAIN value
                 * @property {number} TYPE_NIGHT=19 TYPE_NIGHT value
                 * @property {number} TYPE_STOP_4_WAY=21 TYPE_STOP_4_WAY value
                 * @property {number} TYPE_TRUCK=15 TYPE_TRUCK value
                 * @property {number} TYPE_TRACTORS_MAY_BE_PASSED=16 TYPE_TRACTORS_MAY_BE_PASSED value
                 * @property {number} TYPE_HAZARDOUS=17 TYPE_HAZARDOUS value
                 * @property {number} TYPE_TRAILER=18 TYPE_TRAILER value
                 * @property {number} TYPE_ZONE=20 TYPE_ZONE value
                 * @property {number} TYPE_MOTORCYCLE=22 TYPE_MOTORCYCLE value
                 * @property {number} TYPE_MOTORCYCLE_ALLOWED=23 TYPE_MOTORCYCLE_ALLOWED value
                 * @property {number} TYPE_CAR=24 TYPE_CAR value
                 */
                Classification.Type = (function() {
                    const valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "TYPE_UNKNOWN"] = 0;
                    values[valuesById[1] = "TYPE_OTHER"] = 1;
                    values[valuesById[2] = "TYPE_NO_SIGN"] = 2;
                    values[valuesById[41] = "TYPE_TEXT"] = 41;
                    values[valuesById[39] = "TYPE_SPACE"] = 39;
                    values[valuesById[26] = "TYPE_TIME"] = 26;
                    values[valuesById[30] = "TYPE_ARROW"] = 30;
                    values[valuesById[46] = "TYPE_CONSTRAINED_TO"] = 46;
                    values[valuesById[45] = "TYPE_EXCEPT"] = 45;
                    values[valuesById[3] = "TYPE_VALID_FOR_DISTANCE"] = 3;
                    values[valuesById[27] = "TYPE_PRIORITY_ROAD_BOTTOM_LEFT_FOUR_WAY"] = 27;
                    values[valuesById[28] = "TYPE_PRIORITY_ROAD_TOP_LEFT_FOUR_WAY"] = 28;
                    values[valuesById[32] = "TYPE_PRIORITY_ROAD_BOTTOM_LEFT_THREE_WAY_STRAIGHT"] = 32;
                    values[valuesById[33] = "TYPE_PRIORITY_ROAD_BOTTOM_LEFT_THREE_WAY_SIDEWAYS"] = 33;
                    values[valuesById[34] = "TYPE_PRIORITY_ROAD_TOP_LEFT_THREE_WAY_STRAIGHT"] = 34;
                    values[valuesById[29] = "TYPE_PRIORITY_ROAD_BOTTOM_RIGHT_FOUR_WAY"] = 29;
                    values[valuesById[31] = "TYPE_PRIORITY_ROAD_TOP_RIGHT_FOUR_WAY"] = 31;
                    values[valuesById[35] = "TYPE_PRIORITY_ROAD_BOTTOM_RIGHT_THREE_WAY_STRAIGHT"] = 35;
                    values[valuesById[36] = "TYPE_PRIORITY_ROAD_BOTTOM_RIGHT_THREE_WAY_SIDEWAY"] = 36;
                    values[valuesById[37] = "TYPE_PRIORITY_ROAD_TOP_RIGHT_THREE_WAY_STRAIGHT"] = 37;
                    values[valuesById[4] = "TYPE_VALID_IN_DISTANCE"] = 4;
                    values[valuesById[25] = "TYPE_STOP_IN"] = 25;
                    values[valuesById[11] = "TYPE_LEFT_ARROW"] = 11;
                    values[valuesById[13] = "TYPE_LEFT_BEND_ARROW"] = 13;
                    values[valuesById[12] = "TYPE_RIGHT_ARROW"] = 12;
                    values[valuesById[14] = "TYPE_RIGHT_BEND_ARROW"] = 14;
                    values[valuesById[40] = "TYPE_ACCIDENT"] = 40;
                    values[valuesById[9] = "TYPE_SNOW"] = 9;
                    values[valuesById[8] = "TYPE_FOG"] = 8;
                    values[valuesById[48] = "TYPE_ROLLING_HIGHWAY_INFORMATION"] = 48;
                    values[valuesById[47] = "TYPE_SERVICES"] = 47;
                    values[valuesById[5] = "TYPE_TIME_RANGE"] = 5;
                    values[valuesById[43] = "TYPE_PARKING_DISC_TIME_RESTRICTION"] = 43;
                    values[valuesById[6] = "TYPE_WEIGHT"] = 6;
                    values[valuesById[44] = "TYPE_WET"] = 44;
                    values[valuesById[42] = "TYPE_PARKING_CONSTRAINT"] = 42;
                    values[valuesById[38] = "TYPE_NO_WAITING_SIDE_STRIPES"] = 38;
                    values[valuesById[7] = "TYPE_RAIN"] = 7;
                    values[valuesById[10] = "TYPE_SNOW_RAIN"] = 10;
                    values[valuesById[19] = "TYPE_NIGHT"] = 19;
                    values[valuesById[21] = "TYPE_STOP_4_WAY"] = 21;
                    values[valuesById[15] = "TYPE_TRUCK"] = 15;
                    values[valuesById[16] = "TYPE_TRACTORS_MAY_BE_PASSED"] = 16;
                    values[valuesById[17] = "TYPE_HAZARDOUS"] = 17;
                    values[valuesById[18] = "TYPE_TRAILER"] = 18;
                    values[valuesById[20] = "TYPE_ZONE"] = 20;
                    values[valuesById[22] = "TYPE_MOTORCYCLE"] = 22;
                    values[valuesById[23] = "TYPE_MOTORCYCLE_ALLOWED"] = 23;
                    values[valuesById[24] = "TYPE_CAR"] = 24;
                    return values;
                })();

                /**
                 * Actor enum.
                 * @name osi3.TrafficSign.SupplementarySign.Classification.Actor
                 * @enum {number}
                 * @property {number} ACTOR_UNKNOWN=0 ACTOR_UNKNOWN value
                 * @property {number} ACTOR_OTHER=1 ACTOR_OTHER value
                 * @property {number} ACTOR_NO_ACTOR=2 ACTOR_NO_ACTOR value
                 * @property {number} ACTOR_AGRICULTURAL_VEHICLES=3 ACTOR_AGRICULTURAL_VEHICLES value
                 * @property {number} ACTOR_BICYCLES=4 ACTOR_BICYCLES value
                 * @property {number} ACTOR_BUSES=5 ACTOR_BUSES value
                 * @property {number} ACTOR_CAMPERS=6 ACTOR_CAMPERS value
                 * @property {number} ACTOR_CARAVANS=7 ACTOR_CARAVANS value
                 * @property {number} ACTOR_CARS=8 ACTOR_CARS value
                 * @property {number} ACTOR_CARS_WITH_CARAVANS=9 ACTOR_CARS_WITH_CARAVANS value
                 * @property {number} ACTOR_CARS_WITH_TRAILERS=10 ACTOR_CARS_WITH_TRAILERS value
                 * @property {number} ACTOR_CATTLE=11 ACTOR_CATTLE value
                 * @property {number} ACTOR_CHILDREN=12 ACTOR_CHILDREN value
                 * @property {number} ACTOR_CONSTRUCTION_VEHICLES=13 ACTOR_CONSTRUCTION_VEHICLES value
                 * @property {number} ACTOR_DELIVERY_VEHICLES=14 ACTOR_DELIVERY_VEHICLES value
                 * @property {number} ACTOR_DISABLED_PERSONS=15 ACTOR_DISABLED_PERSONS value
                 * @property {number} ACTOR_EBIKES=16 ACTOR_EBIKES value
                 * @property {number} ACTOR_ELECTRIC_VEHICLES=17 ACTOR_ELECTRIC_VEHICLES value
                 * @property {number} ACTOR_EMERGENCY_VEHICLES=18 ACTOR_EMERGENCY_VEHICLES value
                 * @property {number} ACTOR_FERRY_USERS=19 ACTOR_FERRY_USERS value
                 * @property {number} ACTOR_FORESTRY_VEHICLES=20 ACTOR_FORESTRY_VEHICLES value
                 * @property {number} ACTOR_HAZARDOUS_GOODS_VEHICLES=21 ACTOR_HAZARDOUS_GOODS_VEHICLES value
                 * @property {number} ACTOR_HORSE_CARRIAGES=22 ACTOR_HORSE_CARRIAGES value
                 * @property {number} ACTOR_HORSE_RIDERS=23 ACTOR_HORSE_RIDERS value
                 * @property {number} ACTOR_INLINE_SKATERS=24 ACTOR_INLINE_SKATERS value
                 * @property {number} ACTOR_MEDICAL_VEHICLES=25 ACTOR_MEDICAL_VEHICLES value
                 * @property {number} ACTOR_MILITARY_VEHICLES=26 ACTOR_MILITARY_VEHICLES value
                 * @property {number} ACTOR_MOPEDS=27 ACTOR_MOPEDS value
                 * @property {number} ACTOR_MOTORCYCLES=28 ACTOR_MOTORCYCLES value
                 * @property {number} ACTOR_MOTORIZED_MULTITRACK_VEHICLES=29 ACTOR_MOTORIZED_MULTITRACK_VEHICLES value
                 * @property {number} ACTOR_OPERATIONAL_AND_UTILITY_VEHICLES=30 ACTOR_OPERATIONAL_AND_UTILITY_VEHICLES value
                 * @property {number} ACTOR_PEDESTRIANS=31 ACTOR_PEDESTRIANS value
                 * @property {number} ACTOR_PUBLIC_TRANSPORT_VEHICLES=32 ACTOR_PUBLIC_TRANSPORT_VEHICLES value
                 * @property {number} ACTOR_RAILROAD_TRAFFIC=33 ACTOR_RAILROAD_TRAFFIC value
                 * @property {number} ACTOR_RESIDENTS=34 ACTOR_RESIDENTS value
                 * @property {number} ACTOR_SLURRY_TRANSPORT=35 ACTOR_SLURRY_TRANSPORT value
                 * @property {number} ACTOR_TAXIS=36 ACTOR_TAXIS value
                 * @property {number} ACTOR_TRACTORS=37 ACTOR_TRACTORS value
                 * @property {number} ACTOR_TRAILERS=38 ACTOR_TRAILERS value
                 * @property {number} ACTOR_TRAMS=39 ACTOR_TRAMS value
                 * @property {number} ACTOR_TRUCKS=40 ACTOR_TRUCKS value
                 * @property {number} ACTOR_TRUCKS_WITH_SEMITRAILERS=41 ACTOR_TRUCKS_WITH_SEMITRAILERS value
                 * @property {number} ACTOR_TRUCKS_WITH_TRAILERS=42 ACTOR_TRUCKS_WITH_TRAILERS value
                 * @property {number} ACTOR_VEHICLES_WITH_GREEN_BADGES=43 ACTOR_VEHICLES_WITH_GREEN_BADGES value
                 * @property {number} ACTOR_VEHICLES_WITH_RED_BADGES=44 ACTOR_VEHICLES_WITH_RED_BADGES value
                 * @property {number} ACTOR_VEHICLES_WITH_YELLOW_BADGES=45 ACTOR_VEHICLES_WITH_YELLOW_BADGES value
                 * @property {number} ACTOR_WATER_POLLUTANT_VEHICLES=46 ACTOR_WATER_POLLUTANT_VEHICLES value
                 * @property {number} ACTOR_WINTER_SPORTSPEOPLE=47 ACTOR_WINTER_SPORTSPEOPLE value
                 */
                Classification.Actor = (function() {
                    const valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "ACTOR_UNKNOWN"] = 0;
                    values[valuesById[1] = "ACTOR_OTHER"] = 1;
                    values[valuesById[2] = "ACTOR_NO_ACTOR"] = 2;
                    values[valuesById[3] = "ACTOR_AGRICULTURAL_VEHICLES"] = 3;
                    values[valuesById[4] = "ACTOR_BICYCLES"] = 4;
                    values[valuesById[5] = "ACTOR_BUSES"] = 5;
                    values[valuesById[6] = "ACTOR_CAMPERS"] = 6;
                    values[valuesById[7] = "ACTOR_CARAVANS"] = 7;
                    values[valuesById[8] = "ACTOR_CARS"] = 8;
                    values[valuesById[9] = "ACTOR_CARS_WITH_CARAVANS"] = 9;
                    values[valuesById[10] = "ACTOR_CARS_WITH_TRAILERS"] = 10;
                    values[valuesById[11] = "ACTOR_CATTLE"] = 11;
                    values[valuesById[12] = "ACTOR_CHILDREN"] = 12;
                    values[valuesById[13] = "ACTOR_CONSTRUCTION_VEHICLES"] = 13;
                    values[valuesById[14] = "ACTOR_DELIVERY_VEHICLES"] = 14;
                    values[valuesById[15] = "ACTOR_DISABLED_PERSONS"] = 15;
                    values[valuesById[16] = "ACTOR_EBIKES"] = 16;
                    values[valuesById[17] = "ACTOR_ELECTRIC_VEHICLES"] = 17;
                    values[valuesById[18] = "ACTOR_EMERGENCY_VEHICLES"] = 18;
                    values[valuesById[19] = "ACTOR_FERRY_USERS"] = 19;
                    values[valuesById[20] = "ACTOR_FORESTRY_VEHICLES"] = 20;
                    values[valuesById[21] = "ACTOR_HAZARDOUS_GOODS_VEHICLES"] = 21;
                    values[valuesById[22] = "ACTOR_HORSE_CARRIAGES"] = 22;
                    values[valuesById[23] = "ACTOR_HORSE_RIDERS"] = 23;
                    values[valuesById[24] = "ACTOR_INLINE_SKATERS"] = 24;
                    values[valuesById[25] = "ACTOR_MEDICAL_VEHICLES"] = 25;
                    values[valuesById[26] = "ACTOR_MILITARY_VEHICLES"] = 26;
                    values[valuesById[27] = "ACTOR_MOPEDS"] = 27;
                    values[valuesById[28] = "ACTOR_MOTORCYCLES"] = 28;
                    values[valuesById[29] = "ACTOR_MOTORIZED_MULTITRACK_VEHICLES"] = 29;
                    values[valuesById[30] = "ACTOR_OPERATIONAL_AND_UTILITY_VEHICLES"] = 30;
                    values[valuesById[31] = "ACTOR_PEDESTRIANS"] = 31;
                    values[valuesById[32] = "ACTOR_PUBLIC_TRANSPORT_VEHICLES"] = 32;
                    values[valuesById[33] = "ACTOR_RAILROAD_TRAFFIC"] = 33;
                    values[valuesById[34] = "ACTOR_RESIDENTS"] = 34;
                    values[valuesById[35] = "ACTOR_SLURRY_TRANSPORT"] = 35;
                    values[valuesById[36] = "ACTOR_TAXIS"] = 36;
                    values[valuesById[37] = "ACTOR_TRACTORS"] = 37;
                    values[valuesById[38] = "ACTOR_TRAILERS"] = 38;
                    values[valuesById[39] = "ACTOR_TRAMS"] = 39;
                    values[valuesById[40] = "ACTOR_TRUCKS"] = 40;
                    values[valuesById[41] = "ACTOR_TRUCKS_WITH_SEMITRAILERS"] = 41;
                    values[valuesById[42] = "ACTOR_TRUCKS_WITH_TRAILERS"] = 42;
                    values[valuesById[43] = "ACTOR_VEHICLES_WITH_GREEN_BADGES"] = 43;
                    values[valuesById[44] = "ACTOR_VEHICLES_WITH_RED_BADGES"] = 44;
                    values[valuesById[45] = "ACTOR_VEHICLES_WITH_YELLOW_BADGES"] = 45;
                    values[valuesById[46] = "ACTOR_WATER_POLLUTANT_VEHICLES"] = 46;
                    values[valuesById[47] = "ACTOR_WINTER_SPORTSPEOPLE"] = 47;
                    return values;
                })();

                Classification.Arrow = (function() {

                    /**
                     * Properties of an Arrow.
                     * @memberof osi3.TrafficSign.SupplementarySign.Classification
                     * @interface IArrow
                     * @property {Array.<osi3.IIdentifier>|null} [laneId] Arrow laneId
                     * @property {Array.<osi3.TrafficSign.SupplementarySign.Classification.Arrow.Direction>|null} [direction] Arrow direction
                     */

                    /**
                     * Constructs a new Arrow.
                     * @memberof osi3.TrafficSign.SupplementarySign.Classification
                     * @classdesc Represents an Arrow.
                     * @implements IArrow
                     * @constructor
                     * @param {osi3.TrafficSign.SupplementarySign.Classification.IArrow=} [properties] Properties to set
                     */
                    function Arrow(properties) {
                        this.laneId = [];
                        this.direction = [];
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Arrow laneId.
                     * @member {Array.<osi3.IIdentifier>} laneId
                     * @memberof osi3.TrafficSign.SupplementarySign.Classification.Arrow
                     * @instance
                     */
                    Arrow.prototype.laneId = $util.emptyArray;

                    /**
                     * Arrow direction.
                     * @member {Array.<osi3.TrafficSign.SupplementarySign.Classification.Arrow.Direction>} direction
                     * @memberof osi3.TrafficSign.SupplementarySign.Classification.Arrow
                     * @instance
                     */
                    Arrow.prototype.direction = $util.emptyArray;

                    /**
                     * Creates a new Arrow instance using the specified properties.
                     * @function create
                     * @memberof osi3.TrafficSign.SupplementarySign.Classification.Arrow
                     * @static
                     * @param {osi3.TrafficSign.SupplementarySign.Classification.IArrow=} [properties] Properties to set
                     * @returns {osi3.TrafficSign.SupplementarySign.Classification.Arrow} Arrow instance
                     */
                    Arrow.create = function create(properties) {
                        return new Arrow(properties);
                    };

                    /**
                     * Encodes the specified Arrow message. Does not implicitly {@link osi3.TrafficSign.SupplementarySign.Classification.Arrow.verify|verify} messages.
                     * @function encode
                     * @memberof osi3.TrafficSign.SupplementarySign.Classification.Arrow
                     * @static
                     * @param {osi3.TrafficSign.SupplementarySign.Classification.IArrow} message Arrow message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Arrow.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.laneId != null && message.laneId.length)
                            for (let i = 0; i < message.laneId.length; ++i)
                                $root.osi3.Identifier.encode(message.laneId[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.direction != null && message.direction.length)
                            for (let i = 0; i < message.direction.length; ++i)
                                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.direction[i]);
                        return writer;
                    };

                    /**
                     * Encodes the specified Arrow message, length delimited. Does not implicitly {@link osi3.TrafficSign.SupplementarySign.Classification.Arrow.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof osi3.TrafficSign.SupplementarySign.Classification.Arrow
                     * @static
                     * @param {osi3.TrafficSign.SupplementarySign.Classification.IArrow} message Arrow message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Arrow.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes an Arrow message from the specified reader or buffer.
                     * @function decode
                     * @memberof osi3.TrafficSign.SupplementarySign.Classification.Arrow
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {osi3.TrafficSign.SupplementarySign.Classification.Arrow} Arrow
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Arrow.decode = function decode(reader, length, error) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.osi3.TrafficSign.SupplementarySign.Classification.Arrow();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            if (tag === error)
                                break;
                            switch (tag >>> 3) {
                            case 1: {
                                    if (!(message.laneId && message.laneId.length))
                                        message.laneId = [];
                                    message.laneId.push($root.osi3.Identifier.decode(reader, reader.uint32()));
                                    break;
                                }
                            case 2: {
                                    if (!(message.direction && message.direction.length))
                                        message.direction = [];
                                    if ((tag & 7) === 2) {
                                        let end2 = reader.uint32() + reader.pos;
                                        while (reader.pos < end2)
                                            message.direction.push(reader.int32());
                                    } else
                                        message.direction.push(reader.int32());
                                    break;
                                }
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes an Arrow message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof osi3.TrafficSign.SupplementarySign.Classification.Arrow
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {osi3.TrafficSign.SupplementarySign.Classification.Arrow} Arrow
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Arrow.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies an Arrow message.
                     * @function verify
                     * @memberof osi3.TrafficSign.SupplementarySign.Classification.Arrow
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Arrow.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.laneId != null && message.hasOwnProperty("laneId")) {
                            if (!Array.isArray(message.laneId))
                                return "laneId: array expected";
                            for (let i = 0; i < message.laneId.length; ++i) {
                                let error = $root.osi3.Identifier.verify(message.laneId[i]);
                                if (error)
                                    return "laneId." + error;
                            }
                        }
                        if (message.direction != null && message.hasOwnProperty("direction")) {
                            if (!Array.isArray(message.direction))
                                return "direction: array expected";
                            for (let i = 0; i < message.direction.length; ++i)
                                switch (message.direction[i]) {
                                default:
                                    return "direction: enum value[] expected";
                                case 0:
                                case 1:
                                case 2:
                                case 3:
                                case 4:
                                case 5:
                                case 6:
                                case 7:
                                case 8:
                                case 9:
                                case 10:
                                case 11:
                                case 12:
                                case 13:
                                case 14:
                                case 15:
                                case 16:
                                case 17:
                                case 18:
                                case 19:
                                case 20:
                                case 21:
                                case 22:
                                case 23:
                                case 24:
                                case 25:
                                case 26:
                                case 27:
                                case 28:
                                case 29:
                                case 30:
                                case 31:
                                case 32:
                                    break;
                                }
                        }
                        return null;
                    };

                    /**
                     * Creates an Arrow message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof osi3.TrafficSign.SupplementarySign.Classification.Arrow
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {osi3.TrafficSign.SupplementarySign.Classification.Arrow} Arrow
                     */
                    Arrow.fromObject = function fromObject(object) {
                        if (object instanceof $root.osi3.TrafficSign.SupplementarySign.Classification.Arrow)
                            return object;
                        let message = new $root.osi3.TrafficSign.SupplementarySign.Classification.Arrow();
                        if (object.laneId) {
                            if (!Array.isArray(object.laneId))
                                throw TypeError(".osi3.TrafficSign.SupplementarySign.Classification.Arrow.laneId: array expected");
                            message.laneId = [];
                            for (let i = 0; i < object.laneId.length; ++i) {
                                if (typeof object.laneId[i] !== "object")
                                    throw TypeError(".osi3.TrafficSign.SupplementarySign.Classification.Arrow.laneId: object expected");
                                message.laneId[i] = $root.osi3.Identifier.fromObject(object.laneId[i]);
                            }
                        }
                        if (object.direction) {
                            if (!Array.isArray(object.direction))
                                throw TypeError(".osi3.TrafficSign.SupplementarySign.Classification.Arrow.direction: array expected");
                            message.direction = [];
                            for (let i = 0; i < object.direction.length; ++i)
                                switch (object.direction[i]) {
                                default:
                                    if (typeof object.direction[i] === "number") {
                                        message.direction[i] = object.direction[i];
                                        break;
                                    }
                                case "DIRECTION_UNKNOWN":
                                case 0:
                                    message.direction[i] = 0;
                                    break;
                                case "DIRECTION_OTHER":
                                case 1:
                                    message.direction[i] = 1;
                                    break;
                                case "DIRECTION_NO_DIRECTION":
                                case 2:
                                    message.direction[i] = 2;
                                    break;
                                case "DIRECTION_DIRECT_0_DEG":
                                case 3:
                                    message.direction[i] = 3;
                                    break;
                                case "DIRECTION_DIRECT_45_DEG_RIGHT":
                                case 4:
                                    message.direction[i] = 4;
                                    break;
                                case "DIRECTION_DIRECT_45_DEG_LEFT":
                                case 5:
                                    message.direction[i] = 5;
                                    break;
                                case "DIRECTION_DIRECT_90_DEG_RIGHT":
                                case 6:
                                    message.direction[i] = 6;
                                    break;
                                case "DIRECTION_DIRECT_90_DEG_LEFT":
                                case 7:
                                    message.direction[i] = 7;
                                    break;
                                case "DIRECTION_DIRECT_135_DEG_RIGHT":
                                case 8:
                                    message.direction[i] = 8;
                                    break;
                                case "DIRECTION_DIRECT_135_DEG_LEFT":
                                case 9:
                                    message.direction[i] = 9;
                                    break;
                                case "DIRECTION_DIRECT_180_DEG":
                                case 10:
                                    message.direction[i] = 10;
                                    break;
                                case "DIRECTION_TURN_45_DEG_RIGHT":
                                case 11:
                                    message.direction[i] = 11;
                                    break;
                                case "DIRECTION_TURN_45_DEG_LEFT":
                                case 12:
                                    message.direction[i] = 12;
                                    break;
                                case "DIRECTION_TURN_90_DEG_RIGHT":
                                case 13:
                                    message.direction[i] = 13;
                                    break;
                                case "DIRECTION_TURN_90_DEG_LEFT":
                                case 14:
                                    message.direction[i] = 14;
                                    break;
                                case "DIRECTION_TURN_135_DEG_RIGHT":
                                case 15:
                                    message.direction[i] = 15;
                                    break;
                                case "DIRECTION_TURN_135_DEG_LEFT":
                                case 16:
                                    message.direction[i] = 16;
                                    break;
                                case "DIRECTION_TURN_180_DEG_RIGHT":
                                case 17:
                                    message.direction[i] = 17;
                                    break;
                                case "DIRECTION_TURN_180_DEG_LEFT":
                                case 18:
                                    message.direction[i] = 18;
                                    break;
                                case "DIRECTION_CIRCLE_0_DEG":
                                case 19:
                                    message.direction[i] = 19;
                                    break;
                                case "DIRECTION_CIRCLE_45_DEG_RIGHT":
                                case 20:
                                    message.direction[i] = 20;
                                    break;
                                case "DIRECTION_CIRCLE_45_DEG_LEFT":
                                case 21:
                                    message.direction[i] = 21;
                                    break;
                                case "DIRECTION_CIRCLE_90_DEG_RIGHT":
                                case 22:
                                    message.direction[i] = 22;
                                    break;
                                case "DIRECTION_CIRCLE_90_DEG_LEFT":
                                case 23:
                                    message.direction[i] = 23;
                                    break;
                                case "DIRECTION_CIRCLE_135_DEG_RIGHT":
                                case 24:
                                    message.direction[i] = 24;
                                    break;
                                case "DIRECTION_CIRCLE_135_DEG_LEFT":
                                case 25:
                                    message.direction[i] = 25;
                                    break;
                                case "DIRECTION_CIRCLE_180_DEG":
                                case 26:
                                    message.direction[i] = 26;
                                    break;
                                case "DIRECTION_KEEP_LEFT_TO_TURN_0_DEG":
                                case 27:
                                    message.direction[i] = 27;
                                    break;
                                case "DIRECTION_KEEP_RIGHT_TO_TURN_0_DEG":
                                case 28:
                                    message.direction[i] = 28;
                                    break;
                                case "DIRECTION_KEEP_LEFT_TO_TURN_90_DEG_RIGHT":
                                case 29:
                                    message.direction[i] = 29;
                                    break;
                                case "DIRECTION_KEEP_RIGHT_TO_TURN_90_DEG_LEFT":
                                case 30:
                                    message.direction[i] = 30;
                                    break;
                                case "DIRECTION_KEEP_LEFT_DRIVE_BACK_TO_TURN_90_DEG_RIGHT":
                                case 31:
                                    message.direction[i] = 31;
                                    break;
                                case "DIRECTION_KEEP_RIGHT_DRIVE_BACK_TO_TURN_90_DEG_LEFT":
                                case 32:
                                    message.direction[i] = 32;
                                    break;
                                }
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from an Arrow message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof osi3.TrafficSign.SupplementarySign.Classification.Arrow
                     * @static
                     * @param {osi3.TrafficSign.SupplementarySign.Classification.Arrow} message Arrow
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Arrow.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.arrays || options.defaults) {
                            object.laneId = [];
                            object.direction = [];
                        }
                        if (message.laneId && message.laneId.length) {
                            object.laneId = [];
                            for (let j = 0; j < message.laneId.length; ++j)
                                object.laneId[j] = $root.osi3.Identifier.toObject(message.laneId[j], options);
                        }
                        if (message.direction && message.direction.length) {
                            object.direction = [];
                            for (let j = 0; j < message.direction.length; ++j)
                                object.direction[j] = options.enums === String ? $root.osi3.TrafficSign.SupplementarySign.Classification.Arrow.Direction[message.direction[j]] === undefined ? message.direction[j] : $root.osi3.TrafficSign.SupplementarySign.Classification.Arrow.Direction[message.direction[j]] : message.direction[j];
                        }
                        return object;
                    };

                    /**
                     * Converts this Arrow to JSON.
                     * @function toJSON
                     * @memberof osi3.TrafficSign.SupplementarySign.Classification.Arrow
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Arrow.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Gets the default type url for Arrow
                     * @function getTypeUrl
                     * @memberof osi3.TrafficSign.SupplementarySign.Classification.Arrow
                     * @static
                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                     * @returns {string} The default type url
                     */
                    Arrow.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                        if (typeUrlPrefix === undefined) {
                            typeUrlPrefix = "type.googleapis.com";
                        }
                        return typeUrlPrefix + "/osi3.TrafficSign.SupplementarySign.Classification.Arrow";
                    };

                    /**
                     * Direction enum.
                     * @name osi3.TrafficSign.SupplementarySign.Classification.Arrow.Direction
                     * @enum {number}
                     * @property {number} DIRECTION_UNKNOWN=0 DIRECTION_UNKNOWN value
                     * @property {number} DIRECTION_OTHER=1 DIRECTION_OTHER value
                     * @property {number} DIRECTION_NO_DIRECTION=2 DIRECTION_NO_DIRECTION value
                     * @property {number} DIRECTION_DIRECT_0_DEG=3 DIRECTION_DIRECT_0_DEG value
                     * @property {number} DIRECTION_DIRECT_45_DEG_RIGHT=4 DIRECTION_DIRECT_45_DEG_RIGHT value
                     * @property {number} DIRECTION_DIRECT_45_DEG_LEFT=5 DIRECTION_DIRECT_45_DEG_LEFT value
                     * @property {number} DIRECTION_DIRECT_90_DEG_RIGHT=6 DIRECTION_DIRECT_90_DEG_RIGHT value
                     * @property {number} DIRECTION_DIRECT_90_DEG_LEFT=7 DIRECTION_DIRECT_90_DEG_LEFT value
                     * @property {number} DIRECTION_DIRECT_135_DEG_RIGHT=8 DIRECTION_DIRECT_135_DEG_RIGHT value
                     * @property {number} DIRECTION_DIRECT_135_DEG_LEFT=9 DIRECTION_DIRECT_135_DEG_LEFT value
                     * @property {number} DIRECTION_DIRECT_180_DEG=10 DIRECTION_DIRECT_180_DEG value
                     * @property {number} DIRECTION_TURN_45_DEG_RIGHT=11 DIRECTION_TURN_45_DEG_RIGHT value
                     * @property {number} DIRECTION_TURN_45_DEG_LEFT=12 DIRECTION_TURN_45_DEG_LEFT value
                     * @property {number} DIRECTION_TURN_90_DEG_RIGHT=13 DIRECTION_TURN_90_DEG_RIGHT value
                     * @property {number} DIRECTION_TURN_90_DEG_LEFT=14 DIRECTION_TURN_90_DEG_LEFT value
                     * @property {number} DIRECTION_TURN_135_DEG_RIGHT=15 DIRECTION_TURN_135_DEG_RIGHT value
                     * @property {number} DIRECTION_TURN_135_DEG_LEFT=16 DIRECTION_TURN_135_DEG_LEFT value
                     * @property {number} DIRECTION_TURN_180_DEG_RIGHT=17 DIRECTION_TURN_180_DEG_RIGHT value
                     * @property {number} DIRECTION_TURN_180_DEG_LEFT=18 DIRECTION_TURN_180_DEG_LEFT value
                     * @property {number} DIRECTION_CIRCLE_0_DEG=19 DIRECTION_CIRCLE_0_DEG value
                     * @property {number} DIRECTION_CIRCLE_45_DEG_RIGHT=20 DIRECTION_CIRCLE_45_DEG_RIGHT value
                     * @property {number} DIRECTION_CIRCLE_45_DEG_LEFT=21 DIRECTION_CIRCLE_45_DEG_LEFT value
                     * @property {number} DIRECTION_CIRCLE_90_DEG_RIGHT=22 DIRECTION_CIRCLE_90_DEG_RIGHT value
                     * @property {number} DIRECTION_CIRCLE_90_DEG_LEFT=23 DIRECTION_CIRCLE_90_DEG_LEFT value
                     * @property {number} DIRECTION_CIRCLE_135_DEG_RIGHT=24 DIRECTION_CIRCLE_135_DEG_RIGHT value
                     * @property {number} DIRECTION_CIRCLE_135_DEG_LEFT=25 DIRECTION_CIRCLE_135_DEG_LEFT value
                     * @property {number} DIRECTION_CIRCLE_180_DEG=26 DIRECTION_CIRCLE_180_DEG value
                     * @property {number} DIRECTION_KEEP_LEFT_TO_TURN_0_DEG=27 DIRECTION_KEEP_LEFT_TO_TURN_0_DEG value
                     * @property {number} DIRECTION_KEEP_RIGHT_TO_TURN_0_DEG=28 DIRECTION_KEEP_RIGHT_TO_TURN_0_DEG value
                     * @property {number} DIRECTION_KEEP_LEFT_TO_TURN_90_DEG_RIGHT=29 DIRECTION_KEEP_LEFT_TO_TURN_90_DEG_RIGHT value
                     * @property {number} DIRECTION_KEEP_RIGHT_TO_TURN_90_DEG_LEFT=30 DIRECTION_KEEP_RIGHT_TO_TURN_90_DEG_LEFT value
                     * @property {number} DIRECTION_KEEP_LEFT_DRIVE_BACK_TO_TURN_90_DEG_RIGHT=31 DIRECTION_KEEP_LEFT_DRIVE_BACK_TO_TURN_90_DEG_RIGHT value
                     * @property {number} DIRECTION_KEEP_RIGHT_DRIVE_BACK_TO_TURN_90_DEG_LEFT=32 DIRECTION_KEEP_RIGHT_DRIVE_BACK_TO_TURN_90_DEG_LEFT value
                     */
                    Arrow.Direction = (function() {
                        const valuesById = {}, values = Object.create(valuesById);
                        values[valuesById[0] = "DIRECTION_UNKNOWN"] = 0;
                        values[valuesById[1] = "DIRECTION_OTHER"] = 1;
                        values[valuesById[2] = "DIRECTION_NO_DIRECTION"] = 2;
                        values[valuesById[3] = "DIRECTION_DIRECT_0_DEG"] = 3;
                        values[valuesById[4] = "DIRECTION_DIRECT_45_DEG_RIGHT"] = 4;
                        values[valuesById[5] = "DIRECTION_DIRECT_45_DEG_LEFT"] = 5;
                        values[valuesById[6] = "DIRECTION_DIRECT_90_DEG_RIGHT"] = 6;
                        values[valuesById[7] = "DIRECTION_DIRECT_90_DEG_LEFT"] = 7;
                        values[valuesById[8] = "DIRECTION_DIRECT_135_DEG_RIGHT"] = 8;
                        values[valuesById[9] = "DIRECTION_DIRECT_135_DEG_LEFT"] = 9;
                        values[valuesById[10] = "DIRECTION_DIRECT_180_DEG"] = 10;
                        values[valuesById[11] = "DIRECTION_TURN_45_DEG_RIGHT"] = 11;
                        values[valuesById[12] = "DIRECTION_TURN_45_DEG_LEFT"] = 12;
                        values[valuesById[13] = "DIRECTION_TURN_90_DEG_RIGHT"] = 13;
                        values[valuesById[14] = "DIRECTION_TURN_90_DEG_LEFT"] = 14;
                        values[valuesById[15] = "DIRECTION_TURN_135_DEG_RIGHT"] = 15;
                        values[valuesById[16] = "DIRECTION_TURN_135_DEG_LEFT"] = 16;
                        values[valuesById[17] = "DIRECTION_TURN_180_DEG_RIGHT"] = 17;
                        values[valuesById[18] = "DIRECTION_TURN_180_DEG_LEFT"] = 18;
                        values[valuesById[19] = "DIRECTION_CIRCLE_0_DEG"] = 19;
                        values[valuesById[20] = "DIRECTION_CIRCLE_45_DEG_RIGHT"] = 20;
                        values[valuesById[21] = "DIRECTION_CIRCLE_45_DEG_LEFT"] = 21;
                        values[valuesById[22] = "DIRECTION_CIRCLE_90_DEG_RIGHT"] = 22;
                        values[valuesById[23] = "DIRECTION_CIRCLE_90_DEG_LEFT"] = 23;
                        values[valuesById[24] = "DIRECTION_CIRCLE_135_DEG_RIGHT"] = 24;
                        values[valuesById[25] = "DIRECTION_CIRCLE_135_DEG_LEFT"] = 25;
                        values[valuesById[26] = "DIRECTION_CIRCLE_180_DEG"] = 26;
                        values[valuesById[27] = "DIRECTION_KEEP_LEFT_TO_TURN_0_DEG"] = 27;
                        values[valuesById[28] = "DIRECTION_KEEP_RIGHT_TO_TURN_0_DEG"] = 28;
                        values[valuesById[29] = "DIRECTION_KEEP_LEFT_TO_TURN_90_DEG_RIGHT"] = 29;
                        values[valuesById[30] = "DIRECTION_KEEP_RIGHT_TO_TURN_90_DEG_LEFT"] = 30;
                        values[valuesById[31] = "DIRECTION_KEEP_LEFT_DRIVE_BACK_TO_TURN_90_DEG_RIGHT"] = 31;
                        values[valuesById[32] = "DIRECTION_KEEP_RIGHT_DRIVE_BACK_TO_TURN_90_DEG_LEFT"] = 32;
                        return values;
                    })();

                    return Arrow;
                })();

                return Classification;
            })();

            return SupplementarySign;
        })();

        /**
         * Variability enum.
         * @name osi3.TrafficSign.Variability
         * @enum {number}
         * @property {number} VARIABILITY_UNKNOWN=0 VARIABILITY_UNKNOWN value
         * @property {number} VARIABILITY_OTHER=1 VARIABILITY_OTHER value
         * @property {number} VARIABILITY_FIXED=2 VARIABILITY_FIXED value
         * @property {number} VARIABILITY_VARIABLE=3 VARIABILITY_VARIABLE value
         * @property {number} VARIABILITY_MOVABLE=4 VARIABILITY_MOVABLE value
         * @property {number} VARIABILITY_MUTABLE=5 VARIABILITY_MUTABLE value
         * @property {number} VARIABILITY_MOVABLE_AND_MUTABLE=6 VARIABILITY_MOVABLE_AND_MUTABLE value
         */
        TrafficSign.Variability = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "VARIABILITY_UNKNOWN"] = 0;
            values[valuesById[1] = "VARIABILITY_OTHER"] = 1;
            values[valuesById[2] = "VARIABILITY_FIXED"] = 2;
            values[valuesById[3] = "VARIABILITY_VARIABLE"] = 3;
            values[valuesById[4] = "VARIABILITY_MOVABLE"] = 4;
            values[valuesById[5] = "VARIABILITY_MUTABLE"] = 5;
            values[valuesById[6] = "VARIABILITY_MOVABLE_AND_MUTABLE"] = 6;
            return values;
        })();

        return TrafficSign;
    })();

    osi3.TrafficLight = (function() {

        /**
         * Properties of a TrafficLight.
         * @memberof osi3
         * @interface ITrafficLight
         * @property {osi3.IIdentifier|null} [id] TrafficLight id
         * @property {osi3.IBaseStationary|null} [base] TrafficLight base
         * @property {osi3.TrafficLight.IClassification|null} [classification] TrafficLight classification
         * @property {string|null} [modelReference] TrafficLight modelReference
         * @property {Array.<osi3.IExternalReference>|null} [sourceReference] TrafficLight sourceReference
         * @property {osi3.IColorDescription|null} [colorDescription] TrafficLight colorDescription
         */

        /**
         * Constructs a new TrafficLight.
         * @memberof osi3
         * @classdesc Represents a TrafficLight.
         * @implements ITrafficLight
         * @constructor
         * @param {osi3.ITrafficLight=} [properties] Properties to set
         */
        function TrafficLight(properties) {
            this.sourceReference = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TrafficLight id.
         * @member {osi3.IIdentifier|null|undefined} id
         * @memberof osi3.TrafficLight
         * @instance
         */
        TrafficLight.prototype.id = null;

        /**
         * TrafficLight base.
         * @member {osi3.IBaseStationary|null|undefined} base
         * @memberof osi3.TrafficLight
         * @instance
         */
        TrafficLight.prototype.base = null;

        /**
         * TrafficLight classification.
         * @member {osi3.TrafficLight.IClassification|null|undefined} classification
         * @memberof osi3.TrafficLight
         * @instance
         */
        TrafficLight.prototype.classification = null;

        /**
         * TrafficLight modelReference.
         * @member {string} modelReference
         * @memberof osi3.TrafficLight
         * @instance
         */
        TrafficLight.prototype.modelReference = "";

        /**
         * TrafficLight sourceReference.
         * @member {Array.<osi3.IExternalReference>} sourceReference
         * @memberof osi3.TrafficLight
         * @instance
         */
        TrafficLight.prototype.sourceReference = $util.emptyArray;

        /**
         * TrafficLight colorDescription.
         * @member {osi3.IColorDescription|null|undefined} colorDescription
         * @memberof osi3.TrafficLight
         * @instance
         */
        TrafficLight.prototype.colorDescription = null;

        /**
         * Creates a new TrafficLight instance using the specified properties.
         * @function create
         * @memberof osi3.TrafficLight
         * @static
         * @param {osi3.ITrafficLight=} [properties] Properties to set
         * @returns {osi3.TrafficLight} TrafficLight instance
         */
        TrafficLight.create = function create(properties) {
            return new TrafficLight(properties);
        };

        /**
         * Encodes the specified TrafficLight message. Does not implicitly {@link osi3.TrafficLight.verify|verify} messages.
         * @function encode
         * @memberof osi3.TrafficLight
         * @static
         * @param {osi3.ITrafficLight} message TrafficLight message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TrafficLight.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                $root.osi3.Identifier.encode(message.id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.base != null && Object.hasOwnProperty.call(message, "base"))
                $root.osi3.BaseStationary.encode(message.base, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.classification != null && Object.hasOwnProperty.call(message, "classification"))
                $root.osi3.TrafficLight.Classification.encode(message.classification, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.modelReference != null && Object.hasOwnProperty.call(message, "modelReference"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.modelReference);
            if (message.sourceReference != null && message.sourceReference.length)
                for (let i = 0; i < message.sourceReference.length; ++i)
                    $root.osi3.ExternalReference.encode(message.sourceReference[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.colorDescription != null && Object.hasOwnProperty.call(message, "colorDescription"))
                $root.osi3.ColorDescription.encode(message.colorDescription, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified TrafficLight message, length delimited. Does not implicitly {@link osi3.TrafficLight.verify|verify} messages.
         * @function encodeDelimited
         * @memberof osi3.TrafficLight
         * @static
         * @param {osi3.ITrafficLight} message TrafficLight message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TrafficLight.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TrafficLight message from the specified reader or buffer.
         * @function decode
         * @memberof osi3.TrafficLight
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {osi3.TrafficLight} TrafficLight
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TrafficLight.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.osi3.TrafficLight();
            while (reader.pos < end) {
                let tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.id = $root.osi3.Identifier.decode(reader, reader.uint32());
                        break;
                    }
                case 2: {
                        message.base = $root.osi3.BaseStationary.decode(reader, reader.uint32());
                        break;
                    }
                case 3: {
                        message.classification = $root.osi3.TrafficLight.Classification.decode(reader, reader.uint32());
                        break;
                    }
                case 4: {
                        message.modelReference = reader.string();
                        break;
                    }
                case 5: {
                        if (!(message.sourceReference && message.sourceReference.length))
                            message.sourceReference = [];
                        message.sourceReference.push($root.osi3.ExternalReference.decode(reader, reader.uint32()));
                        break;
                    }
                case 6: {
                        message.colorDescription = $root.osi3.ColorDescription.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TrafficLight message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof osi3.TrafficLight
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {osi3.TrafficLight} TrafficLight
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TrafficLight.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TrafficLight message.
         * @function verify
         * @memberof osi3.TrafficLight
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TrafficLight.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id")) {
                let error = $root.osi3.Identifier.verify(message.id);
                if (error)
                    return "id." + error;
            }
            if (message.base != null && message.hasOwnProperty("base")) {
                let error = $root.osi3.BaseStationary.verify(message.base);
                if (error)
                    return "base." + error;
            }
            if (message.classification != null && message.hasOwnProperty("classification")) {
                let error = $root.osi3.TrafficLight.Classification.verify(message.classification);
                if (error)
                    return "classification." + error;
            }
            if (message.modelReference != null && message.hasOwnProperty("modelReference"))
                if (!$util.isString(message.modelReference))
                    return "modelReference: string expected";
            if (message.sourceReference != null && message.hasOwnProperty("sourceReference")) {
                if (!Array.isArray(message.sourceReference))
                    return "sourceReference: array expected";
                for (let i = 0; i < message.sourceReference.length; ++i) {
                    let error = $root.osi3.ExternalReference.verify(message.sourceReference[i]);
                    if (error)
                        return "sourceReference." + error;
                }
            }
            if (message.colorDescription != null && message.hasOwnProperty("colorDescription")) {
                let error = $root.osi3.ColorDescription.verify(message.colorDescription);
                if (error)
                    return "colorDescription." + error;
            }
            return null;
        };

        /**
         * Creates a TrafficLight message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof osi3.TrafficLight
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {osi3.TrafficLight} TrafficLight
         */
        TrafficLight.fromObject = function fromObject(object) {
            if (object instanceof $root.osi3.TrafficLight)
                return object;
            let message = new $root.osi3.TrafficLight();
            if (object.id != null) {
                if (typeof object.id !== "object")
                    throw TypeError(".osi3.TrafficLight.id: object expected");
                message.id = $root.osi3.Identifier.fromObject(object.id);
            }
            if (object.base != null) {
                if (typeof object.base !== "object")
                    throw TypeError(".osi3.TrafficLight.base: object expected");
                message.base = $root.osi3.BaseStationary.fromObject(object.base);
            }
            if (object.classification != null) {
                if (typeof object.classification !== "object")
                    throw TypeError(".osi3.TrafficLight.classification: object expected");
                message.classification = $root.osi3.TrafficLight.Classification.fromObject(object.classification);
            }
            if (object.modelReference != null)
                message.modelReference = String(object.modelReference);
            if (object.sourceReference) {
                if (!Array.isArray(object.sourceReference))
                    throw TypeError(".osi3.TrafficLight.sourceReference: array expected");
                message.sourceReference = [];
                for (let i = 0; i < object.sourceReference.length; ++i) {
                    if (typeof object.sourceReference[i] !== "object")
                        throw TypeError(".osi3.TrafficLight.sourceReference: object expected");
                    message.sourceReference[i] = $root.osi3.ExternalReference.fromObject(object.sourceReference[i]);
                }
            }
            if (object.colorDescription != null) {
                if (typeof object.colorDescription !== "object")
                    throw TypeError(".osi3.TrafficLight.colorDescription: object expected");
                message.colorDescription = $root.osi3.ColorDescription.fromObject(object.colorDescription);
            }
            return message;
        };

        /**
         * Creates a plain object from a TrafficLight message. Also converts values to other types if specified.
         * @function toObject
         * @memberof osi3.TrafficLight
         * @static
         * @param {osi3.TrafficLight} message TrafficLight
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TrafficLight.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.sourceReference = [];
            if (options.defaults) {
                object.id = null;
                object.base = null;
                object.classification = null;
                object.modelReference = "";
                object.colorDescription = null;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = $root.osi3.Identifier.toObject(message.id, options);
            if (message.base != null && message.hasOwnProperty("base"))
                object.base = $root.osi3.BaseStationary.toObject(message.base, options);
            if (message.classification != null && message.hasOwnProperty("classification"))
                object.classification = $root.osi3.TrafficLight.Classification.toObject(message.classification, options);
            if (message.modelReference != null && message.hasOwnProperty("modelReference"))
                object.modelReference = message.modelReference;
            if (message.sourceReference && message.sourceReference.length) {
                object.sourceReference = [];
                for (let j = 0; j < message.sourceReference.length; ++j)
                    object.sourceReference[j] = $root.osi3.ExternalReference.toObject(message.sourceReference[j], options);
            }
            if (message.colorDescription != null && message.hasOwnProperty("colorDescription"))
                object.colorDescription = $root.osi3.ColorDescription.toObject(message.colorDescription, options);
            return object;
        };

        /**
         * Converts this TrafficLight to JSON.
         * @function toJSON
         * @memberof osi3.TrafficLight
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TrafficLight.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for TrafficLight
         * @function getTypeUrl
         * @memberof osi3.TrafficLight
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TrafficLight.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/osi3.TrafficLight";
        };

        TrafficLight.Classification = (function() {

            /**
             * Properties of a Classification.
             * @memberof osi3.TrafficLight
             * @interface IClassification
             * @property {osi3.TrafficLight.Classification.Color|null} [color] Classification color
             * @property {osi3.TrafficLight.Classification.Icon|null} [icon] Classification icon
             * @property {osi3.TrafficLight.Classification.Mode|null} [mode] Classification mode
             * @property {number|null} [counter] Classification counter
             * @property {Array.<osi3.IIdentifier>|null} [assignedLaneId] Classification assignedLaneId
             * @property {boolean|null} [isOutOfService] Classification isOutOfService
             * @property {Array.<osi3.ILogicalLaneAssignment>|null} [logicalLaneAssignment] Classification logicalLaneAssignment
             */

            /**
             * Constructs a new Classification.
             * @memberof osi3.TrafficLight
             * @classdesc Represents a Classification.
             * @implements IClassification
             * @constructor
             * @param {osi3.TrafficLight.IClassification=} [properties] Properties to set
             */
            function Classification(properties) {
                this.assignedLaneId = [];
                this.logicalLaneAssignment = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Classification color.
             * @member {osi3.TrafficLight.Classification.Color} color
             * @memberof osi3.TrafficLight.Classification
             * @instance
             */
            Classification.prototype.color = 0;

            /**
             * Classification icon.
             * @member {osi3.TrafficLight.Classification.Icon} icon
             * @memberof osi3.TrafficLight.Classification
             * @instance
             */
            Classification.prototype.icon = 0;

            /**
             * Classification mode.
             * @member {osi3.TrafficLight.Classification.Mode} mode
             * @memberof osi3.TrafficLight.Classification
             * @instance
             */
            Classification.prototype.mode = 0;

            /**
             * Classification counter.
             * @member {number} counter
             * @memberof osi3.TrafficLight.Classification
             * @instance
             */
            Classification.prototype.counter = 0;

            /**
             * Classification assignedLaneId.
             * @member {Array.<osi3.IIdentifier>} assignedLaneId
             * @memberof osi3.TrafficLight.Classification
             * @instance
             */
            Classification.prototype.assignedLaneId = $util.emptyArray;

            /**
             * Classification isOutOfService.
             * @member {boolean} isOutOfService
             * @memberof osi3.TrafficLight.Classification
             * @instance
             */
            Classification.prototype.isOutOfService = false;

            /**
             * Classification logicalLaneAssignment.
             * @member {Array.<osi3.ILogicalLaneAssignment>} logicalLaneAssignment
             * @memberof osi3.TrafficLight.Classification
             * @instance
             */
            Classification.prototype.logicalLaneAssignment = $util.emptyArray;

            /**
             * Creates a new Classification instance using the specified properties.
             * @function create
             * @memberof osi3.TrafficLight.Classification
             * @static
             * @param {osi3.TrafficLight.IClassification=} [properties] Properties to set
             * @returns {osi3.TrafficLight.Classification} Classification instance
             */
            Classification.create = function create(properties) {
                return new Classification(properties);
            };

            /**
             * Encodes the specified Classification message. Does not implicitly {@link osi3.TrafficLight.Classification.verify|verify} messages.
             * @function encode
             * @memberof osi3.TrafficLight.Classification
             * @static
             * @param {osi3.TrafficLight.IClassification} message Classification message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Classification.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.color != null && Object.hasOwnProperty.call(message, "color"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.color);
                if (message.icon != null && Object.hasOwnProperty.call(message, "icon"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.icon);
                if (message.mode != null && Object.hasOwnProperty.call(message, "mode"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.mode);
                if (message.counter != null && Object.hasOwnProperty.call(message, "counter"))
                    writer.uint32(/* id 4, wireType 1 =*/33).double(message.counter);
                if (message.assignedLaneId != null && message.assignedLaneId.length)
                    for (let i = 0; i < message.assignedLaneId.length; ++i)
                        $root.osi3.Identifier.encode(message.assignedLaneId[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.isOutOfService != null && Object.hasOwnProperty.call(message, "isOutOfService"))
                    writer.uint32(/* id 6, wireType 0 =*/48).bool(message.isOutOfService);
                if (message.logicalLaneAssignment != null && message.logicalLaneAssignment.length)
                    for (let i = 0; i < message.logicalLaneAssignment.length; ++i)
                        $root.osi3.LogicalLaneAssignment.encode(message.logicalLaneAssignment[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Classification message, length delimited. Does not implicitly {@link osi3.TrafficLight.Classification.verify|verify} messages.
             * @function encodeDelimited
             * @memberof osi3.TrafficLight.Classification
             * @static
             * @param {osi3.TrafficLight.IClassification} message Classification message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Classification.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Classification message from the specified reader or buffer.
             * @function decode
             * @memberof osi3.TrafficLight.Classification
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {osi3.TrafficLight.Classification} Classification
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Classification.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.osi3.TrafficLight.Classification();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.color = reader.int32();
                            break;
                        }
                    case 2: {
                            message.icon = reader.int32();
                            break;
                        }
                    case 3: {
                            message.mode = reader.int32();
                            break;
                        }
                    case 4: {
                            message.counter = reader.double();
                            break;
                        }
                    case 5: {
                            if (!(message.assignedLaneId && message.assignedLaneId.length))
                                message.assignedLaneId = [];
                            message.assignedLaneId.push($root.osi3.Identifier.decode(reader, reader.uint32()));
                            break;
                        }
                    case 6: {
                            message.isOutOfService = reader.bool();
                            break;
                        }
                    case 7: {
                            if (!(message.logicalLaneAssignment && message.logicalLaneAssignment.length))
                                message.logicalLaneAssignment = [];
                            message.logicalLaneAssignment.push($root.osi3.LogicalLaneAssignment.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Classification message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof osi3.TrafficLight.Classification
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {osi3.TrafficLight.Classification} Classification
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Classification.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Classification message.
             * @function verify
             * @memberof osi3.TrafficLight.Classification
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Classification.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.color != null && message.hasOwnProperty("color"))
                    switch (message.color) {
                    default:
                        return "color: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                        break;
                    }
                if (message.icon != null && message.hasOwnProperty("icon"))
                    switch (message.icon) {
                    default:
                        return "icon: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                    case 9:
                    case 10:
                    case 11:
                    case 12:
                    case 13:
                    case 14:
                    case 15:
                    case 16:
                    case 17:
                    case 18:
                    case 19:
                    case 20:
                    case 21:
                    case 22:
                    case 23:
                    case 24:
                        break;
                    }
                if (message.mode != null && message.hasOwnProperty("mode"))
                    switch (message.mode) {
                    default:
                        return "mode: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                        break;
                    }
                if (message.counter != null && message.hasOwnProperty("counter"))
                    if (typeof message.counter !== "number")
                        return "counter: number expected";
                if (message.assignedLaneId != null && message.hasOwnProperty("assignedLaneId")) {
                    if (!Array.isArray(message.assignedLaneId))
                        return "assignedLaneId: array expected";
                    for (let i = 0; i < message.assignedLaneId.length; ++i) {
                        let error = $root.osi3.Identifier.verify(message.assignedLaneId[i]);
                        if (error)
                            return "assignedLaneId." + error;
                    }
                }
                if (message.isOutOfService != null && message.hasOwnProperty("isOutOfService"))
                    if (typeof message.isOutOfService !== "boolean")
                        return "isOutOfService: boolean expected";
                if (message.logicalLaneAssignment != null && message.hasOwnProperty("logicalLaneAssignment")) {
                    if (!Array.isArray(message.logicalLaneAssignment))
                        return "logicalLaneAssignment: array expected";
                    for (let i = 0; i < message.logicalLaneAssignment.length; ++i) {
                        let error = $root.osi3.LogicalLaneAssignment.verify(message.logicalLaneAssignment[i]);
                        if (error)
                            return "logicalLaneAssignment." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a Classification message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof osi3.TrafficLight.Classification
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {osi3.TrafficLight.Classification} Classification
             */
            Classification.fromObject = function fromObject(object) {
                if (object instanceof $root.osi3.TrafficLight.Classification)
                    return object;
                let message = new $root.osi3.TrafficLight.Classification();
                switch (object.color) {
                default:
                    if (typeof object.color === "number") {
                        message.color = object.color;
                        break;
                    }
                    break;
                case "COLOR_UNKNOWN":
                case 0:
                    message.color = 0;
                    break;
                case "COLOR_OTHER":
                case 1:
                    message.color = 1;
                    break;
                case "COLOR_RED":
                case 2:
                    message.color = 2;
                    break;
                case "COLOR_YELLOW":
                case 3:
                    message.color = 3;
                    break;
                case "COLOR_GREEN":
                case 4:
                    message.color = 4;
                    break;
                case "COLOR_BLUE":
                case 5:
                    message.color = 5;
                    break;
                case "COLOR_WHITE":
                case 6:
                    message.color = 6;
                    break;
                }
                switch (object.icon) {
                default:
                    if (typeof object.icon === "number") {
                        message.icon = object.icon;
                        break;
                    }
                    break;
                case "ICON_UNKNOWN":
                case 0:
                    message.icon = 0;
                    break;
                case "ICON_OTHER":
                case 1:
                    message.icon = 1;
                    break;
                case "ICON_NONE":
                case 2:
                    message.icon = 2;
                    break;
                case "ICON_ARROW_STRAIGHT_AHEAD":
                case 3:
                    message.icon = 3;
                    break;
                case "ICON_ARROW_LEFT":
                case 4:
                    message.icon = 4;
                    break;
                case "ICON_ARROW_DIAG_LEFT":
                case 5:
                    message.icon = 5;
                    break;
                case "ICON_ARROW_STRAIGHT_AHEAD_LEFT":
                case 6:
                    message.icon = 6;
                    break;
                case "ICON_ARROW_RIGHT":
                case 7:
                    message.icon = 7;
                    break;
                case "ICON_ARROW_DIAG_RIGHT":
                case 8:
                    message.icon = 8;
                    break;
                case "ICON_ARROW_STRAIGHT_AHEAD_RIGHT":
                case 9:
                    message.icon = 9;
                    break;
                case "ICON_ARROW_LEFT_RIGHT":
                case 10:
                    message.icon = 10;
                    break;
                case "ICON_ARROW_DOWN":
                case 11:
                    message.icon = 11;
                    break;
                case "ICON_ARROW_DOWN_LEFT":
                case 12:
                    message.icon = 12;
                    break;
                case "ICON_ARROW_DOWN_RIGHT":
                case 13:
                    message.icon = 13;
                    break;
                case "ICON_ARROW_CROSS":
                case 14:
                    message.icon = 14;
                    break;
                case "ICON_PEDESTRIAN":
                case 15:
                    message.icon = 15;
                    break;
                case "ICON_WALK":
                case 16:
                    message.icon = 16;
                    break;
                case "ICON_DONT_WALK":
                case 17:
                    message.icon = 17;
                    break;
                case "ICON_BICYCLE":
                case 18:
                    message.icon = 18;
                    break;
                case "ICON_PEDESTRIAN_AND_BICYCLE":
                case 19:
                    message.icon = 19;
                    break;
                case "ICON_COUNTDOWN_SECONDS":
                case 20:
                    message.icon = 20;
                    break;
                case "ICON_COUNTDOWN_PERCENT":
                case 21:
                    message.icon = 21;
                    break;
                case "ICON_TRAM":
                case 22:
                    message.icon = 22;
                    break;
                case "ICON_BUS":
                case 23:
                    message.icon = 23;
                    break;
                case "ICON_BUS_AND_TRAM":
                case 24:
                    message.icon = 24;
                    break;
                }
                switch (object.mode) {
                default:
                    if (typeof object.mode === "number") {
                        message.mode = object.mode;
                        break;
                    }
                    break;
                case "MODE_UNKNOWN":
                case 0:
                    message.mode = 0;
                    break;
                case "MODE_OTHER":
                case 1:
                    message.mode = 1;
                    break;
                case "MODE_OFF":
                case 2:
                    message.mode = 2;
                    break;
                case "MODE_CONSTANT":
                case 3:
                    message.mode = 3;
                    break;
                case "MODE_FLASHING":
                case 4:
                    message.mode = 4;
                    break;
                case "MODE_COUNTING":
                case 5:
                    message.mode = 5;
                    break;
                }
                if (object.counter != null)
                    message.counter = Number(object.counter);
                if (object.assignedLaneId) {
                    if (!Array.isArray(object.assignedLaneId))
                        throw TypeError(".osi3.TrafficLight.Classification.assignedLaneId: array expected");
                    message.assignedLaneId = [];
                    for (let i = 0; i < object.assignedLaneId.length; ++i) {
                        if (typeof object.assignedLaneId[i] !== "object")
                            throw TypeError(".osi3.TrafficLight.Classification.assignedLaneId: object expected");
                        message.assignedLaneId[i] = $root.osi3.Identifier.fromObject(object.assignedLaneId[i]);
                    }
                }
                if (object.isOutOfService != null)
                    message.isOutOfService = Boolean(object.isOutOfService);
                if (object.logicalLaneAssignment) {
                    if (!Array.isArray(object.logicalLaneAssignment))
                        throw TypeError(".osi3.TrafficLight.Classification.logicalLaneAssignment: array expected");
                    message.logicalLaneAssignment = [];
                    for (let i = 0; i < object.logicalLaneAssignment.length; ++i) {
                        if (typeof object.logicalLaneAssignment[i] !== "object")
                            throw TypeError(".osi3.TrafficLight.Classification.logicalLaneAssignment: object expected");
                        message.logicalLaneAssignment[i] = $root.osi3.LogicalLaneAssignment.fromObject(object.logicalLaneAssignment[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a Classification message. Also converts values to other types if specified.
             * @function toObject
             * @memberof osi3.TrafficLight.Classification
             * @static
             * @param {osi3.TrafficLight.Classification} message Classification
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Classification.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults) {
                    object.assignedLaneId = [];
                    object.logicalLaneAssignment = [];
                }
                if (options.defaults) {
                    object.color = options.enums === String ? "COLOR_UNKNOWN" : 0;
                    object.icon = options.enums === String ? "ICON_UNKNOWN" : 0;
                    object.mode = options.enums === String ? "MODE_UNKNOWN" : 0;
                    object.counter = 0;
                    object.isOutOfService = false;
                }
                if (message.color != null && message.hasOwnProperty("color"))
                    object.color = options.enums === String ? $root.osi3.TrafficLight.Classification.Color[message.color] === undefined ? message.color : $root.osi3.TrafficLight.Classification.Color[message.color] : message.color;
                if (message.icon != null && message.hasOwnProperty("icon"))
                    object.icon = options.enums === String ? $root.osi3.TrafficLight.Classification.Icon[message.icon] === undefined ? message.icon : $root.osi3.TrafficLight.Classification.Icon[message.icon] : message.icon;
                if (message.mode != null && message.hasOwnProperty("mode"))
                    object.mode = options.enums === String ? $root.osi3.TrafficLight.Classification.Mode[message.mode] === undefined ? message.mode : $root.osi3.TrafficLight.Classification.Mode[message.mode] : message.mode;
                if (message.counter != null && message.hasOwnProperty("counter"))
                    object.counter = options.json && !isFinite(message.counter) ? String(message.counter) : message.counter;
                if (message.assignedLaneId && message.assignedLaneId.length) {
                    object.assignedLaneId = [];
                    for (let j = 0; j < message.assignedLaneId.length; ++j)
                        object.assignedLaneId[j] = $root.osi3.Identifier.toObject(message.assignedLaneId[j], options);
                }
                if (message.isOutOfService != null && message.hasOwnProperty("isOutOfService"))
                    object.isOutOfService = message.isOutOfService;
                if (message.logicalLaneAssignment && message.logicalLaneAssignment.length) {
                    object.logicalLaneAssignment = [];
                    for (let j = 0; j < message.logicalLaneAssignment.length; ++j)
                        object.logicalLaneAssignment[j] = $root.osi3.LogicalLaneAssignment.toObject(message.logicalLaneAssignment[j], options);
                }
                return object;
            };

            /**
             * Converts this Classification to JSON.
             * @function toJSON
             * @memberof osi3.TrafficLight.Classification
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Classification.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Classification
             * @function getTypeUrl
             * @memberof osi3.TrafficLight.Classification
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Classification.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/osi3.TrafficLight.Classification";
            };

            /**
             * Color enum.
             * @name osi3.TrafficLight.Classification.Color
             * @enum {number}
             * @property {number} COLOR_UNKNOWN=0 COLOR_UNKNOWN value
             * @property {number} COLOR_OTHER=1 COLOR_OTHER value
             * @property {number} COLOR_RED=2 COLOR_RED value
             * @property {number} COLOR_YELLOW=3 COLOR_YELLOW value
             * @property {number} COLOR_GREEN=4 COLOR_GREEN value
             * @property {number} COLOR_BLUE=5 COLOR_BLUE value
             * @property {number} COLOR_WHITE=6 COLOR_WHITE value
             */
            Classification.Color = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "COLOR_UNKNOWN"] = 0;
                values[valuesById[1] = "COLOR_OTHER"] = 1;
                values[valuesById[2] = "COLOR_RED"] = 2;
                values[valuesById[3] = "COLOR_YELLOW"] = 3;
                values[valuesById[4] = "COLOR_GREEN"] = 4;
                values[valuesById[5] = "COLOR_BLUE"] = 5;
                values[valuesById[6] = "COLOR_WHITE"] = 6;
                return values;
            })();

            /**
             * Icon enum.
             * @name osi3.TrafficLight.Classification.Icon
             * @enum {number}
             * @property {number} ICON_UNKNOWN=0 ICON_UNKNOWN value
             * @property {number} ICON_OTHER=1 ICON_OTHER value
             * @property {number} ICON_NONE=2 ICON_NONE value
             * @property {number} ICON_ARROW_STRAIGHT_AHEAD=3 ICON_ARROW_STRAIGHT_AHEAD value
             * @property {number} ICON_ARROW_LEFT=4 ICON_ARROW_LEFT value
             * @property {number} ICON_ARROW_DIAG_LEFT=5 ICON_ARROW_DIAG_LEFT value
             * @property {number} ICON_ARROW_STRAIGHT_AHEAD_LEFT=6 ICON_ARROW_STRAIGHT_AHEAD_LEFT value
             * @property {number} ICON_ARROW_RIGHT=7 ICON_ARROW_RIGHT value
             * @property {number} ICON_ARROW_DIAG_RIGHT=8 ICON_ARROW_DIAG_RIGHT value
             * @property {number} ICON_ARROW_STRAIGHT_AHEAD_RIGHT=9 ICON_ARROW_STRAIGHT_AHEAD_RIGHT value
             * @property {number} ICON_ARROW_LEFT_RIGHT=10 ICON_ARROW_LEFT_RIGHT value
             * @property {number} ICON_ARROW_DOWN=11 ICON_ARROW_DOWN value
             * @property {number} ICON_ARROW_DOWN_LEFT=12 ICON_ARROW_DOWN_LEFT value
             * @property {number} ICON_ARROW_DOWN_RIGHT=13 ICON_ARROW_DOWN_RIGHT value
             * @property {number} ICON_ARROW_CROSS=14 ICON_ARROW_CROSS value
             * @property {number} ICON_PEDESTRIAN=15 ICON_PEDESTRIAN value
             * @property {number} ICON_WALK=16 ICON_WALK value
             * @property {number} ICON_DONT_WALK=17 ICON_DONT_WALK value
             * @property {number} ICON_BICYCLE=18 ICON_BICYCLE value
             * @property {number} ICON_PEDESTRIAN_AND_BICYCLE=19 ICON_PEDESTRIAN_AND_BICYCLE value
             * @property {number} ICON_COUNTDOWN_SECONDS=20 ICON_COUNTDOWN_SECONDS value
             * @property {number} ICON_COUNTDOWN_PERCENT=21 ICON_COUNTDOWN_PERCENT value
             * @property {number} ICON_TRAM=22 ICON_TRAM value
             * @property {number} ICON_BUS=23 ICON_BUS value
             * @property {number} ICON_BUS_AND_TRAM=24 ICON_BUS_AND_TRAM value
             */
            Classification.Icon = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "ICON_UNKNOWN"] = 0;
                values[valuesById[1] = "ICON_OTHER"] = 1;
                values[valuesById[2] = "ICON_NONE"] = 2;
                values[valuesById[3] = "ICON_ARROW_STRAIGHT_AHEAD"] = 3;
                values[valuesById[4] = "ICON_ARROW_LEFT"] = 4;
                values[valuesById[5] = "ICON_ARROW_DIAG_LEFT"] = 5;
                values[valuesById[6] = "ICON_ARROW_STRAIGHT_AHEAD_LEFT"] = 6;
                values[valuesById[7] = "ICON_ARROW_RIGHT"] = 7;
                values[valuesById[8] = "ICON_ARROW_DIAG_RIGHT"] = 8;
                values[valuesById[9] = "ICON_ARROW_STRAIGHT_AHEAD_RIGHT"] = 9;
                values[valuesById[10] = "ICON_ARROW_LEFT_RIGHT"] = 10;
                values[valuesById[11] = "ICON_ARROW_DOWN"] = 11;
                values[valuesById[12] = "ICON_ARROW_DOWN_LEFT"] = 12;
                values[valuesById[13] = "ICON_ARROW_DOWN_RIGHT"] = 13;
                values[valuesById[14] = "ICON_ARROW_CROSS"] = 14;
                values[valuesById[15] = "ICON_PEDESTRIAN"] = 15;
                values[valuesById[16] = "ICON_WALK"] = 16;
                values[valuesById[17] = "ICON_DONT_WALK"] = 17;
                values[valuesById[18] = "ICON_BICYCLE"] = 18;
                values[valuesById[19] = "ICON_PEDESTRIAN_AND_BICYCLE"] = 19;
                values[valuesById[20] = "ICON_COUNTDOWN_SECONDS"] = 20;
                values[valuesById[21] = "ICON_COUNTDOWN_PERCENT"] = 21;
                values[valuesById[22] = "ICON_TRAM"] = 22;
                values[valuesById[23] = "ICON_BUS"] = 23;
                values[valuesById[24] = "ICON_BUS_AND_TRAM"] = 24;
                return values;
            })();

            /**
             * Mode enum.
             * @name osi3.TrafficLight.Classification.Mode
             * @enum {number}
             * @property {number} MODE_UNKNOWN=0 MODE_UNKNOWN value
             * @property {number} MODE_OTHER=1 MODE_OTHER value
             * @property {number} MODE_OFF=2 MODE_OFF value
             * @property {number} MODE_CONSTANT=3 MODE_CONSTANT value
             * @property {number} MODE_FLASHING=4 MODE_FLASHING value
             * @property {number} MODE_COUNTING=5 MODE_COUNTING value
             */
            Classification.Mode = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "MODE_UNKNOWN"] = 0;
                values[valuesById[1] = "MODE_OTHER"] = 1;
                values[valuesById[2] = "MODE_OFF"] = 2;
                values[valuesById[3] = "MODE_CONSTANT"] = 3;
                values[valuesById[4] = "MODE_FLASHING"] = 4;
                values[valuesById[5] = "MODE_COUNTING"] = 5;
                return values;
            })();

            return Classification;
        })();

        return TrafficLight;
    })();

    osi3.RoadMarking = (function() {

        /**
         * Properties of a RoadMarking.
         * @memberof osi3
         * @interface IRoadMarking
         * @property {osi3.IIdentifier|null} [id] RoadMarking id
         * @property {osi3.IBaseStationary|null} [base] RoadMarking base
         * @property {osi3.RoadMarking.IClassification|null} [classification] RoadMarking classification
         * @property {Array.<osi3.IExternalReference>|null} [sourceReference] RoadMarking sourceReference
         * @property {osi3.IColorDescription|null} [colorDescription] RoadMarking colorDescription
         */

        /**
         * Constructs a new RoadMarking.
         * @memberof osi3
         * @classdesc Represents a RoadMarking.
         * @implements IRoadMarking
         * @constructor
         * @param {osi3.IRoadMarking=} [properties] Properties to set
         */
        function RoadMarking(properties) {
            this.sourceReference = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RoadMarking id.
         * @member {osi3.IIdentifier|null|undefined} id
         * @memberof osi3.RoadMarking
         * @instance
         */
        RoadMarking.prototype.id = null;

        /**
         * RoadMarking base.
         * @member {osi3.IBaseStationary|null|undefined} base
         * @memberof osi3.RoadMarking
         * @instance
         */
        RoadMarking.prototype.base = null;

        /**
         * RoadMarking classification.
         * @member {osi3.RoadMarking.IClassification|null|undefined} classification
         * @memberof osi3.RoadMarking
         * @instance
         */
        RoadMarking.prototype.classification = null;

        /**
         * RoadMarking sourceReference.
         * @member {Array.<osi3.IExternalReference>} sourceReference
         * @memberof osi3.RoadMarking
         * @instance
         */
        RoadMarking.prototype.sourceReference = $util.emptyArray;

        /**
         * RoadMarking colorDescription.
         * @member {osi3.IColorDescription|null|undefined} colorDescription
         * @memberof osi3.RoadMarking
         * @instance
         */
        RoadMarking.prototype.colorDescription = null;

        /**
         * Creates a new RoadMarking instance using the specified properties.
         * @function create
         * @memberof osi3.RoadMarking
         * @static
         * @param {osi3.IRoadMarking=} [properties] Properties to set
         * @returns {osi3.RoadMarking} RoadMarking instance
         */
        RoadMarking.create = function create(properties) {
            return new RoadMarking(properties);
        };

        /**
         * Encodes the specified RoadMarking message. Does not implicitly {@link osi3.RoadMarking.verify|verify} messages.
         * @function encode
         * @memberof osi3.RoadMarking
         * @static
         * @param {osi3.IRoadMarking} message RoadMarking message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RoadMarking.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                $root.osi3.Identifier.encode(message.id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.base != null && Object.hasOwnProperty.call(message, "base"))
                $root.osi3.BaseStationary.encode(message.base, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.classification != null && Object.hasOwnProperty.call(message, "classification"))
                $root.osi3.RoadMarking.Classification.encode(message.classification, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.sourceReference != null && message.sourceReference.length)
                for (let i = 0; i < message.sourceReference.length; ++i)
                    $root.osi3.ExternalReference.encode(message.sourceReference[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.colorDescription != null && Object.hasOwnProperty.call(message, "colorDescription"))
                $root.osi3.ColorDescription.encode(message.colorDescription, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified RoadMarking message, length delimited. Does not implicitly {@link osi3.RoadMarking.verify|verify} messages.
         * @function encodeDelimited
         * @memberof osi3.RoadMarking
         * @static
         * @param {osi3.IRoadMarking} message RoadMarking message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RoadMarking.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RoadMarking message from the specified reader or buffer.
         * @function decode
         * @memberof osi3.RoadMarking
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {osi3.RoadMarking} RoadMarking
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RoadMarking.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.osi3.RoadMarking();
            while (reader.pos < end) {
                let tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.id = $root.osi3.Identifier.decode(reader, reader.uint32());
                        break;
                    }
                case 2: {
                        message.base = $root.osi3.BaseStationary.decode(reader, reader.uint32());
                        break;
                    }
                case 3: {
                        message.classification = $root.osi3.RoadMarking.Classification.decode(reader, reader.uint32());
                        break;
                    }
                case 4: {
                        if (!(message.sourceReference && message.sourceReference.length))
                            message.sourceReference = [];
                        message.sourceReference.push($root.osi3.ExternalReference.decode(reader, reader.uint32()));
                        break;
                    }
                case 5: {
                        message.colorDescription = $root.osi3.ColorDescription.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RoadMarking message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof osi3.RoadMarking
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {osi3.RoadMarking} RoadMarking
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RoadMarking.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RoadMarking message.
         * @function verify
         * @memberof osi3.RoadMarking
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RoadMarking.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id")) {
                let error = $root.osi3.Identifier.verify(message.id);
                if (error)
                    return "id." + error;
            }
            if (message.base != null && message.hasOwnProperty("base")) {
                let error = $root.osi3.BaseStationary.verify(message.base);
                if (error)
                    return "base." + error;
            }
            if (message.classification != null && message.hasOwnProperty("classification")) {
                let error = $root.osi3.RoadMarking.Classification.verify(message.classification);
                if (error)
                    return "classification." + error;
            }
            if (message.sourceReference != null && message.hasOwnProperty("sourceReference")) {
                if (!Array.isArray(message.sourceReference))
                    return "sourceReference: array expected";
                for (let i = 0; i < message.sourceReference.length; ++i) {
                    let error = $root.osi3.ExternalReference.verify(message.sourceReference[i]);
                    if (error)
                        return "sourceReference." + error;
                }
            }
            if (message.colorDescription != null && message.hasOwnProperty("colorDescription")) {
                let error = $root.osi3.ColorDescription.verify(message.colorDescription);
                if (error)
                    return "colorDescription." + error;
            }
            return null;
        };

        /**
         * Creates a RoadMarking message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof osi3.RoadMarking
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {osi3.RoadMarking} RoadMarking
         */
        RoadMarking.fromObject = function fromObject(object) {
            if (object instanceof $root.osi3.RoadMarking)
                return object;
            let message = new $root.osi3.RoadMarking();
            if (object.id != null) {
                if (typeof object.id !== "object")
                    throw TypeError(".osi3.RoadMarking.id: object expected");
                message.id = $root.osi3.Identifier.fromObject(object.id);
            }
            if (object.base != null) {
                if (typeof object.base !== "object")
                    throw TypeError(".osi3.RoadMarking.base: object expected");
                message.base = $root.osi3.BaseStationary.fromObject(object.base);
            }
            if (object.classification != null) {
                if (typeof object.classification !== "object")
                    throw TypeError(".osi3.RoadMarking.classification: object expected");
                message.classification = $root.osi3.RoadMarking.Classification.fromObject(object.classification);
            }
            if (object.sourceReference) {
                if (!Array.isArray(object.sourceReference))
                    throw TypeError(".osi3.RoadMarking.sourceReference: array expected");
                message.sourceReference = [];
                for (let i = 0; i < object.sourceReference.length; ++i) {
                    if (typeof object.sourceReference[i] !== "object")
                        throw TypeError(".osi3.RoadMarking.sourceReference: object expected");
                    message.sourceReference[i] = $root.osi3.ExternalReference.fromObject(object.sourceReference[i]);
                }
            }
            if (object.colorDescription != null) {
                if (typeof object.colorDescription !== "object")
                    throw TypeError(".osi3.RoadMarking.colorDescription: object expected");
                message.colorDescription = $root.osi3.ColorDescription.fromObject(object.colorDescription);
            }
            return message;
        };

        /**
         * Creates a plain object from a RoadMarking message. Also converts values to other types if specified.
         * @function toObject
         * @memberof osi3.RoadMarking
         * @static
         * @param {osi3.RoadMarking} message RoadMarking
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RoadMarking.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.sourceReference = [];
            if (options.defaults) {
                object.id = null;
                object.base = null;
                object.classification = null;
                object.colorDescription = null;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = $root.osi3.Identifier.toObject(message.id, options);
            if (message.base != null && message.hasOwnProperty("base"))
                object.base = $root.osi3.BaseStationary.toObject(message.base, options);
            if (message.classification != null && message.hasOwnProperty("classification"))
                object.classification = $root.osi3.RoadMarking.Classification.toObject(message.classification, options);
            if (message.sourceReference && message.sourceReference.length) {
                object.sourceReference = [];
                for (let j = 0; j < message.sourceReference.length; ++j)
                    object.sourceReference[j] = $root.osi3.ExternalReference.toObject(message.sourceReference[j], options);
            }
            if (message.colorDescription != null && message.hasOwnProperty("colorDescription"))
                object.colorDescription = $root.osi3.ColorDescription.toObject(message.colorDescription, options);
            return object;
        };

        /**
         * Converts this RoadMarking to JSON.
         * @function toJSON
         * @memberof osi3.RoadMarking
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RoadMarking.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for RoadMarking
         * @function getTypeUrl
         * @memberof osi3.RoadMarking
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        RoadMarking.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/osi3.RoadMarking";
        };

        RoadMarking.Classification = (function() {

            /**
             * Properties of a Classification.
             * @memberof osi3.RoadMarking
             * @interface IClassification
             * @property {osi3.RoadMarking.Classification.Type|null} [type] Classification type
             * @property {osi3.TrafficSign.MainSign.Classification.Type|null} [trafficMainSignType] Classification trafficMainSignType
             * @property {osi3.RoadMarking.Classification.Color|null} [monochromeColor] Classification monochromeColor
             * @property {osi3.ITrafficSignValue|null} [value] Classification value
             * @property {string|null} [valueText] Classification valueText
             * @property {Array.<osi3.IIdentifier>|null} [assignedLaneId] Classification assignedLaneId
             * @property {boolean|null} [isOutOfService] Classification isOutOfService
             * @property {string|null} [country] Classification country
             * @property {string|null} [countryRevision] Classification countryRevision
             * @property {string|null} [code] Classification code
             * @property {string|null} [subCode] Classification subCode
             * @property {Array.<osi3.ILogicalLaneAssignment>|null} [logicalLaneAssignment] Classification logicalLaneAssignment
             */

            /**
             * Constructs a new Classification.
             * @memberof osi3.RoadMarking
             * @classdesc Represents a Classification.
             * @implements IClassification
             * @constructor
             * @param {osi3.RoadMarking.IClassification=} [properties] Properties to set
             */
            function Classification(properties) {
                this.assignedLaneId = [];
                this.logicalLaneAssignment = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Classification type.
             * @member {osi3.RoadMarking.Classification.Type} type
             * @memberof osi3.RoadMarking.Classification
             * @instance
             */
            Classification.prototype.type = 0;

            /**
             * Classification trafficMainSignType.
             * @member {osi3.TrafficSign.MainSign.Classification.Type} trafficMainSignType
             * @memberof osi3.RoadMarking.Classification
             * @instance
             */
            Classification.prototype.trafficMainSignType = 0;

            /**
             * Classification monochromeColor.
             * @member {osi3.RoadMarking.Classification.Color} monochromeColor
             * @memberof osi3.RoadMarking.Classification
             * @instance
             */
            Classification.prototype.monochromeColor = 0;

            /**
             * Classification value.
             * @member {osi3.ITrafficSignValue|null|undefined} value
             * @memberof osi3.RoadMarking.Classification
             * @instance
             */
            Classification.prototype.value = null;

            /**
             * Classification valueText.
             * @member {string} valueText
             * @memberof osi3.RoadMarking.Classification
             * @instance
             */
            Classification.prototype.valueText = "";

            /**
             * Classification assignedLaneId.
             * @member {Array.<osi3.IIdentifier>} assignedLaneId
             * @memberof osi3.RoadMarking.Classification
             * @instance
             */
            Classification.prototype.assignedLaneId = $util.emptyArray;

            /**
             * Classification isOutOfService.
             * @member {boolean} isOutOfService
             * @memberof osi3.RoadMarking.Classification
             * @instance
             */
            Classification.prototype.isOutOfService = false;

            /**
             * Classification country.
             * @member {string} country
             * @memberof osi3.RoadMarking.Classification
             * @instance
             */
            Classification.prototype.country = "";

            /**
             * Classification countryRevision.
             * @member {string} countryRevision
             * @memberof osi3.RoadMarking.Classification
             * @instance
             */
            Classification.prototype.countryRevision = "";

            /**
             * Classification code.
             * @member {string} code
             * @memberof osi3.RoadMarking.Classification
             * @instance
             */
            Classification.prototype.code = "";

            /**
             * Classification subCode.
             * @member {string} subCode
             * @memberof osi3.RoadMarking.Classification
             * @instance
             */
            Classification.prototype.subCode = "";

            /**
             * Classification logicalLaneAssignment.
             * @member {Array.<osi3.ILogicalLaneAssignment>} logicalLaneAssignment
             * @memberof osi3.RoadMarking.Classification
             * @instance
             */
            Classification.prototype.logicalLaneAssignment = $util.emptyArray;

            /**
             * Creates a new Classification instance using the specified properties.
             * @function create
             * @memberof osi3.RoadMarking.Classification
             * @static
             * @param {osi3.RoadMarking.IClassification=} [properties] Properties to set
             * @returns {osi3.RoadMarking.Classification} Classification instance
             */
            Classification.create = function create(properties) {
                return new Classification(properties);
            };

            /**
             * Encodes the specified Classification message. Does not implicitly {@link osi3.RoadMarking.Classification.verify|verify} messages.
             * @function encode
             * @memberof osi3.RoadMarking.Classification
             * @static
             * @param {osi3.RoadMarking.IClassification} message Classification message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Classification.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                if (message.trafficMainSignType != null && Object.hasOwnProperty.call(message, "trafficMainSignType"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.trafficMainSignType);
                if (message.monochromeColor != null && Object.hasOwnProperty.call(message, "monochromeColor"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.monochromeColor);
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    $root.osi3.TrafficSignValue.encode(message.value, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.valueText != null && Object.hasOwnProperty.call(message, "valueText"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.valueText);
                if (message.assignedLaneId != null && message.assignedLaneId.length)
                    for (let i = 0; i < message.assignedLaneId.length; ++i)
                        $root.osi3.Identifier.encode(message.assignedLaneId[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.isOutOfService != null && Object.hasOwnProperty.call(message, "isOutOfService"))
                    writer.uint32(/* id 7, wireType 0 =*/56).bool(message.isOutOfService);
                if (message.country != null && Object.hasOwnProperty.call(message, "country"))
                    writer.uint32(/* id 8, wireType 2 =*/66).string(message.country);
                if (message.countryRevision != null && Object.hasOwnProperty.call(message, "countryRevision"))
                    writer.uint32(/* id 9, wireType 2 =*/74).string(message.countryRevision);
                if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                    writer.uint32(/* id 10, wireType 2 =*/82).string(message.code);
                if (message.subCode != null && Object.hasOwnProperty.call(message, "subCode"))
                    writer.uint32(/* id 11, wireType 2 =*/90).string(message.subCode);
                if (message.logicalLaneAssignment != null && message.logicalLaneAssignment.length)
                    for (let i = 0; i < message.logicalLaneAssignment.length; ++i)
                        $root.osi3.LogicalLaneAssignment.encode(message.logicalLaneAssignment[i], writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Classification message, length delimited. Does not implicitly {@link osi3.RoadMarking.Classification.verify|verify} messages.
             * @function encodeDelimited
             * @memberof osi3.RoadMarking.Classification
             * @static
             * @param {osi3.RoadMarking.IClassification} message Classification message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Classification.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Classification message from the specified reader or buffer.
             * @function decode
             * @memberof osi3.RoadMarking.Classification
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {osi3.RoadMarking.Classification} Classification
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Classification.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.osi3.RoadMarking.Classification();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.type = reader.int32();
                            break;
                        }
                    case 2: {
                            message.trafficMainSignType = reader.int32();
                            break;
                        }
                    case 3: {
                            message.monochromeColor = reader.int32();
                            break;
                        }
                    case 4: {
                            message.value = $root.osi3.TrafficSignValue.decode(reader, reader.uint32());
                            break;
                        }
                    case 5: {
                            message.valueText = reader.string();
                            break;
                        }
                    case 6: {
                            if (!(message.assignedLaneId && message.assignedLaneId.length))
                                message.assignedLaneId = [];
                            message.assignedLaneId.push($root.osi3.Identifier.decode(reader, reader.uint32()));
                            break;
                        }
                    case 7: {
                            message.isOutOfService = reader.bool();
                            break;
                        }
                    case 8: {
                            message.country = reader.string();
                            break;
                        }
                    case 9: {
                            message.countryRevision = reader.string();
                            break;
                        }
                    case 10: {
                            message.code = reader.string();
                            break;
                        }
                    case 11: {
                            message.subCode = reader.string();
                            break;
                        }
                    case 12: {
                            if (!(message.logicalLaneAssignment && message.logicalLaneAssignment.length))
                                message.logicalLaneAssignment = [];
                            message.logicalLaneAssignment.push($root.osi3.LogicalLaneAssignment.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Classification message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof osi3.RoadMarking.Classification
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {osi3.RoadMarking.Classification} Classification
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Classification.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Classification message.
             * @function verify
             * @memberof osi3.RoadMarking.Classification
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Classification.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                        break;
                    }
                if (message.trafficMainSignType != null && message.hasOwnProperty("trafficMainSignType"))
                    switch (message.trafficMainSignType) {
                    default:
                        return "trafficMainSignType: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 87:
                    case 110:
                    case 200:
                    case 197:
                    case 188:
                    case 96:
                    case 94:
                    case 97:
                    case 102:
                    case 210:
                    case 101:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                    case 9:
                    case 93:
                    case 95:
                    case 98:
                    case 10:
                    case 12:
                    case 11:
                    case 13:
                    case 100:
                    case 14:
                    case 15:
                    case 103:
                    case 106:
                    case 107:
                    case 109:
                    case 144:
                    case 112:
                    case 135:
                    case 16:
                    case 17:
                    case 18:
                    case 19:
                    case 20:
                    case 21:
                    case 22:
                    case 24:
                    case 23:
                    case 26:
                    case 25:
                    case 27:
                    case 28:
                    case 29:
                    case 30:
                    case 31:
                    case 32:
                    case 33:
                    case 128:
                    case 129:
                    case 130:
                    case 137:
                    case 138:
                    case 145:
                    case 146:
                    case 147:
                    case 148:
                    case 149:
                    case 150:
                    case 151:
                    case 152:
                    case 153:
                    case 154:
                    case 34:
                    case 35:
                    case 36:
                    case 37:
                    case 38:
                    case 39:
                    case 40:
                    case 41:
                    case 155:
                    case 156:
                    case 157:
                    case 158:
                    case 159:
                    case 160:
                    case 161:
                    case 162:
                    case 163:
                    case 42:
                    case 43:
                    case 164:
                    case 165:
                    case 166:
                    case 167:
                    case 168:
                    case 169:
                    case 44:
                    case 170:
                    case 171:
                    case 45:
                    case 46:
                    case 47:
                    case 48:
                    case 49:
                    case 50:
                    case 51:
                    case 52:
                    case 53:
                    case 54:
                    case 55:
                    case 56:
                    case 57:
                    case 58:
                    case 59:
                    case 60:
                    case 61:
                    case 62:
                    case 63:
                    case 64:
                    case 65:
                    case 66:
                    case 67:
                    case 68:
                    case 69:
                    case 70:
                    case 71:
                    case 72:
                    case 73:
                    case 74:
                    case 75:
                    case 76:
                    case 172:
                    case 173:
                    case 174:
                    case 175:
                    case 176:
                    case 177:
                    case 178:
                    case 179:
                    case 77:
                    case 78:
                    case 79:
                    case 80:
                    case 81:
                    case 82:
                    case 83:
                    case 84:
                    case 85:
                    case 183:
                    case 184:
                    case 185:
                    case 86:
                    case 186:
                    case 187:
                    case 189:
                    case 190:
                    case 191:
                    case 194:
                    case 195:
                    case 196:
                    case 198:
                    case 201:
                    case 202:
                    case 203:
                    case 204:
                    case 205:
                    case 206:
                    case 207:
                    case 208:
                    case 209:
                    case 213:
                    case 214:
                    case 215:
                    case 216:
                    case 217:
                    case 218:
                    case 219:
                    case 220:
                    case 221:
                    case 222:
                    case 223:
                    case 224:
                    case 225:
                    case 226:
                    case 227:
                    case 228:
                    case 229:
                    case 230:
                    case 231:
                    case 232:
                    case 233:
                    case 234:
                    case 235:
                    case 236:
                    case 237:
                    case 238:
                    case 239:
                    case 240:
                    case 143:
                    case 108:
                    case 127:
                    case 136:
                    case 118:
                    case 119:
                    case 120:
                    case 121:
                    case 122:
                    case 123:
                    case 124:
                    case 125:
                    case 126:
                    case 88:
                    case 180:
                    case 181:
                    case 182:
                    case 131:
                    case 132:
                    case 133:
                    case 134:
                    case 111:
                    case 199:
                    case 211:
                    case 212:
                    case 192:
                    case 193:
                    case 90:
                    case 89:
                    case 115:
                    case 116:
                    case 117:
                    case 142:
                    case 141:
                    case 91:
                    case 140:
                    case 139:
                    case 114:
                    case 113:
                    case 104:
                    case 105:
                    case 99:
                    case 92:
                        break;
                    }
                if (message.monochromeColor != null && message.hasOwnProperty("monochromeColor"))
                    switch (message.monochromeColor) {
                    default:
                        return "monochromeColor: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                    case 9:
                        break;
                    }
                if (message.value != null && message.hasOwnProperty("value")) {
                    let error = $root.osi3.TrafficSignValue.verify(message.value);
                    if (error)
                        return "value." + error;
                }
                if (message.valueText != null && message.hasOwnProperty("valueText"))
                    if (!$util.isString(message.valueText))
                        return "valueText: string expected";
                if (message.assignedLaneId != null && message.hasOwnProperty("assignedLaneId")) {
                    if (!Array.isArray(message.assignedLaneId))
                        return "assignedLaneId: array expected";
                    for (let i = 0; i < message.assignedLaneId.length; ++i) {
                        let error = $root.osi3.Identifier.verify(message.assignedLaneId[i]);
                        if (error)
                            return "assignedLaneId." + error;
                    }
                }
                if (message.isOutOfService != null && message.hasOwnProperty("isOutOfService"))
                    if (typeof message.isOutOfService !== "boolean")
                        return "isOutOfService: boolean expected";
                if (message.country != null && message.hasOwnProperty("country"))
                    if (!$util.isString(message.country))
                        return "country: string expected";
                if (message.countryRevision != null && message.hasOwnProperty("countryRevision"))
                    if (!$util.isString(message.countryRevision))
                        return "countryRevision: string expected";
                if (message.code != null && message.hasOwnProperty("code"))
                    if (!$util.isString(message.code))
                        return "code: string expected";
                if (message.subCode != null && message.hasOwnProperty("subCode"))
                    if (!$util.isString(message.subCode))
                        return "subCode: string expected";
                if (message.logicalLaneAssignment != null && message.hasOwnProperty("logicalLaneAssignment")) {
                    if (!Array.isArray(message.logicalLaneAssignment))
                        return "logicalLaneAssignment: array expected";
                    for (let i = 0; i < message.logicalLaneAssignment.length; ++i) {
                        let error = $root.osi3.LogicalLaneAssignment.verify(message.logicalLaneAssignment[i]);
                        if (error)
                            return "logicalLaneAssignment." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a Classification message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof osi3.RoadMarking.Classification
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {osi3.RoadMarking.Classification} Classification
             */
            Classification.fromObject = function fromObject(object) {
                if (object instanceof $root.osi3.RoadMarking.Classification)
                    return object;
                let message = new $root.osi3.RoadMarking.Classification();
                switch (object.type) {
                default:
                    if (typeof object.type === "number") {
                        message.type = object.type;
                        break;
                    }
                    break;
                case "TYPE_UNKNOWN":
                case 0:
                    message.type = 0;
                    break;
                case "TYPE_OTHER":
                case 1:
                    message.type = 1;
                    break;
                case "TYPE_PAINTED_TRAFFIC_SIGN":
                case 2:
                    message.type = 2;
                    break;
                case "TYPE_SYMBOLIC_TRAFFIC_SIGN":
                case 3:
                    message.type = 3;
                    break;
                case "TYPE_TEXTUAL_TRAFFIC_SIGN":
                case 4:
                    message.type = 4;
                    break;
                case "TYPE_GENERIC_SYMBOL":
                case 5:
                    message.type = 5;
                    break;
                case "TYPE_GENERIC_LINE":
                case 6:
                    message.type = 6;
                    break;
                case "TYPE_GENERIC_TEXT":
                case 7:
                    message.type = 7;
                    break;
                }
                switch (object.trafficMainSignType) {
                default:
                    if (typeof object.trafficMainSignType === "number") {
                        message.trafficMainSignType = object.trafficMainSignType;
                        break;
                    }
                    break;
                case "TYPE_UNKNOWN":
                case 0:
                    message.trafficMainSignType = 0;
                    break;
                case "TYPE_OTHER":
                case 1:
                    message.trafficMainSignType = 1;
                    break;
                case "TYPE_DANGER_SPOT":
                case 2:
                    message.trafficMainSignType = 2;
                    break;
                case "TYPE_ZEBRA_CROSSING":
                case 87:
                    message.trafficMainSignType = 87;
                    break;
                case "TYPE_FLIGHT":
                case 110:
                    message.trafficMainSignType = 110;
                    break;
                case "TYPE_CATTLE":
                case 200:
                    message.trafficMainSignType = 200;
                    break;
                case "TYPE_HORSE_RIDERS":
                case 197:
                    message.trafficMainSignType = 197;
                    break;
                case "TYPE_AMPHIBIANS":
                case 188:
                    message.trafficMainSignType = 188;
                    break;
                case "TYPE_FALLING_ROCKS":
                case 96:
                    message.trafficMainSignType = 96;
                    break;
                case "TYPE_SNOW_OR_ICE":
                case 94:
                    message.trafficMainSignType = 94;
                    break;
                case "TYPE_LOOSE_GRAVEL":
                case 97:
                    message.trafficMainSignType = 97;
                    break;
                case "TYPE_WATERSIDE":
                case 102:
                    message.trafficMainSignType = 102;
                    break;
                case "TYPE_CLEARANCE":
                case 210:
                    message.trafficMainSignType = 210;
                    break;
                case "TYPE_MOVABLE_BRIDGE":
                case 101:
                    message.trafficMainSignType = 101;
                    break;
                case "TYPE_RIGHT_BEFORE_LEFT_NEXT_INTERSECTION":
                case 3:
                    message.trafficMainSignType = 3;
                    break;
                case "TYPE_TURN_LEFT":
                case 4:
                    message.trafficMainSignType = 4;
                    break;
                case "TYPE_TURN_RIGHT":
                case 5:
                    message.trafficMainSignType = 5;
                    break;
                case "TYPE_DOUBLE_TURN_LEFT":
                case 6:
                    message.trafficMainSignType = 6;
                    break;
                case "TYPE_DOUBLE_TURN_RIGHT":
                case 7:
                    message.trafficMainSignType = 7;
                    break;
                case "TYPE_HILL_DOWNWARDS":
                case 8:
                    message.trafficMainSignType = 8;
                    break;
                case "TYPE_HILL_UPWARDS":
                case 9:
                    message.trafficMainSignType = 9;
                    break;
                case "TYPE_UNEVEN_ROAD":
                case 93:
                    message.trafficMainSignType = 93;
                    break;
                case "TYPE_ROAD_SLIPPERY_WET_OR_DIRTY":
                case 95:
                    message.trafficMainSignType = 95;
                    break;
                case "TYPE_SIDE_WINDS":
                case 98:
                    message.trafficMainSignType = 98;
                    break;
                case "TYPE_ROAD_NARROWING":
                case 10:
                    message.trafficMainSignType = 10;
                    break;
                case "TYPE_ROAD_NARROWING_RIGHT":
                case 12:
                    message.trafficMainSignType = 12;
                    break;
                case "TYPE_ROAD_NARROWING_LEFT":
                case 11:
                    message.trafficMainSignType = 11;
                    break;
                case "TYPE_ROAD_WORKS":
                case 13:
                    message.trafficMainSignType = 13;
                    break;
                case "TYPE_TRAFFIC_QUEUES":
                case 100:
                    message.trafficMainSignType = 100;
                    break;
                case "TYPE_TWO_WAY_TRAFFIC":
                case 14:
                    message.trafficMainSignType = 14;
                    break;
                case "TYPE_ATTENTION_TRAFFIC_LIGHT":
                case 15:
                    message.trafficMainSignType = 15;
                    break;
                case "TYPE_PEDESTRIANS":
                case 103:
                    message.trafficMainSignType = 103;
                    break;
                case "TYPE_CHILDREN_CROSSING":
                case 106:
                    message.trafficMainSignType = 106;
                    break;
                case "TYPE_CYCLE_ROUTE":
                case 107:
                    message.trafficMainSignType = 107;
                    break;
                case "TYPE_DEER_CROSSING":
                case 109:
                    message.trafficMainSignType = 109;
                    break;
                case "TYPE_UNGATED_LEVEL_CROSSING":
                case 144:
                    message.trafficMainSignType = 144;
                    break;
                case "TYPE_LEVEL_CROSSING_MARKER":
                case 112:
                    message.trafficMainSignType = 112;
                    break;
                case "TYPE_RAILWAY_TRAFFIC_PRIORITY":
                case 135:
                    message.trafficMainSignType = 135;
                    break;
                case "TYPE_GIVE_WAY":
                case 16:
                    message.trafficMainSignType = 16;
                    break;
                case "TYPE_STOP":
                case 17:
                    message.trafficMainSignType = 17;
                    break;
                case "TYPE_PRIORITY_TO_OPPOSITE_DIRECTION":
                case 18:
                    message.trafficMainSignType = 18;
                    break;
                case "TYPE_PRIORITY_TO_OPPOSITE_DIRECTION_UPSIDE_DOWN":
                case 19:
                    message.trafficMainSignType = 19;
                    break;
                case "TYPE_PRESCRIBED_LEFT_TURN":
                case 20:
                    message.trafficMainSignType = 20;
                    break;
                case "TYPE_PRESCRIBED_RIGHT_TURN":
                case 21:
                    message.trafficMainSignType = 21;
                    break;
                case "TYPE_PRESCRIBED_STRAIGHT":
                case 22:
                    message.trafficMainSignType = 22;
                    break;
                case "TYPE_PRESCRIBED_RIGHT_WAY":
                case 24:
                    message.trafficMainSignType = 24;
                    break;
                case "TYPE_PRESCRIBED_LEFT_WAY":
                case 23:
                    message.trafficMainSignType = 23;
                    break;
                case "TYPE_PRESCRIBED_RIGHT_TURN_AND_STRAIGHT":
                case 26:
                    message.trafficMainSignType = 26;
                    break;
                case "TYPE_PRESCRIBED_LEFT_TURN_AND_STRAIGHT":
                case 25:
                    message.trafficMainSignType = 25;
                    break;
                case "TYPE_PRESCRIBED_LEFT_TURN_AND_RIGHT_TURN":
                case 27:
                    message.trafficMainSignType = 27;
                    break;
                case "TYPE_PRESCRIBED_LEFT_TURN_RIGHT_TURN_AND_STRAIGHT":
                case 28:
                    message.trafficMainSignType = 28;
                    break;
                case "TYPE_ROUNDABOUT":
                case 29:
                    message.trafficMainSignType = 29;
                    break;
                case "TYPE_ONEWAY_LEFT":
                case 30:
                    message.trafficMainSignType = 30;
                    break;
                case "TYPE_ONEWAY_RIGHT":
                case 31:
                    message.trafficMainSignType = 31;
                    break;
                case "TYPE_PASS_LEFT":
                case 32:
                    message.trafficMainSignType = 32;
                    break;
                case "TYPE_PASS_RIGHT":
                case 33:
                    message.trafficMainSignType = 33;
                    break;
                case "TYPE_SIDE_LANE_OPEN_FOR_TRAFFIC":
                case 128:
                    message.trafficMainSignType = 128;
                    break;
                case "TYPE_SIDE_LANE_CLOSED_FOR_TRAFFIC":
                case 129:
                    message.trafficMainSignType = 129;
                    break;
                case "TYPE_SIDE_LANE_CLOSING_FOR_TRAFFIC":
                case 130:
                    message.trafficMainSignType = 130;
                    break;
                case "TYPE_BUS_STOP":
                case 137:
                    message.trafficMainSignType = 137;
                    break;
                case "TYPE_TAXI_STAND":
                case 138:
                    message.trafficMainSignType = 138;
                    break;
                case "TYPE_BICYCLES_ONLY":
                case 145:
                    message.trafficMainSignType = 145;
                    break;
                case "TYPE_HORSE_RIDERS_ONLY":
                case 146:
                    message.trafficMainSignType = 146;
                    break;
                case "TYPE_PEDESTRIANS_ONLY":
                case 147:
                    message.trafficMainSignType = 147;
                    break;
                case "TYPE_BICYCLES_PEDESTRIANS_SHARED_ONLY":
                case 148:
                    message.trafficMainSignType = 148;
                    break;
                case "TYPE_BICYCLES_PEDESTRIANS_SEPARATED_LEFT_ONLY":
                case 149:
                    message.trafficMainSignType = 149;
                    break;
                case "TYPE_BICYCLES_PEDESTRIANS_SEPARATED_RIGHT_ONLY":
                case 150:
                    message.trafficMainSignType = 150;
                    break;
                case "TYPE_PEDESTRIAN_ZONE_BEGIN":
                case 151:
                    message.trafficMainSignType = 151;
                    break;
                case "TYPE_PEDESTRIAN_ZONE_END":
                case 152:
                    message.trafficMainSignType = 152;
                    break;
                case "TYPE_BICYCLE_ROAD_BEGIN":
                case 153:
                    message.trafficMainSignType = 153;
                    break;
                case "TYPE_BICYCLE_ROAD_END":
                case 154:
                    message.trafficMainSignType = 154;
                    break;
                case "TYPE_BUS_LANE":
                case 34:
                    message.trafficMainSignType = 34;
                    break;
                case "TYPE_BUS_LANE_BEGIN":
                case 35:
                    message.trafficMainSignType = 35;
                    break;
                case "TYPE_BUS_LANE_END":
                case 36:
                    message.trafficMainSignType = 36;
                    break;
                case "TYPE_ALL_PROHIBITED":
                case 37:
                    message.trafficMainSignType = 37;
                    break;
                case "TYPE_MOTORIZED_MULTITRACK_PROHIBITED":
                case 38:
                    message.trafficMainSignType = 38;
                    break;
                case "TYPE_TRUCKS_PROHIBITED":
                case 39:
                    message.trafficMainSignType = 39;
                    break;
                case "TYPE_BICYCLES_PROHIBITED":
                case 40:
                    message.trafficMainSignType = 40;
                    break;
                case "TYPE_MOTORCYCLES_PROHIBITED":
                case 41:
                    message.trafficMainSignType = 41;
                    break;
                case "TYPE_MOPEDS_PROHIBITED":
                case 155:
                    message.trafficMainSignType = 155;
                    break;
                case "TYPE_HORSE_RIDERS_PROHIBITED":
                case 156:
                    message.trafficMainSignType = 156;
                    break;
                case "TYPE_HORSE_CARRIAGES_PROHIBITED":
                case 157:
                    message.trafficMainSignType = 157;
                    break;
                case "TYPE_CATTLE_PROHIBITED":
                case 158:
                    message.trafficMainSignType = 158;
                    break;
                case "TYPE_BUSES_PROHIBITED":
                case 159:
                    message.trafficMainSignType = 159;
                    break;
                case "TYPE_CARS_PROHIBITED":
                case 160:
                    message.trafficMainSignType = 160;
                    break;
                case "TYPE_CARS_TRAILERS_PROHIBITED":
                case 161:
                    message.trafficMainSignType = 161;
                    break;
                case "TYPE_TRUCKS_TRAILERS_PROHIBITED":
                case 162:
                    message.trafficMainSignType = 162;
                    break;
                case "TYPE_TRACTORS_PROHIBITED":
                case 163:
                    message.trafficMainSignType = 163;
                    break;
                case "TYPE_PEDESTRIANS_PROHIBITED":
                case 42:
                    message.trafficMainSignType = 42;
                    break;
                case "TYPE_MOTOR_VEHICLES_PROHIBITED":
                case 43:
                    message.trafficMainSignType = 43;
                    break;
                case "TYPE_HAZARDOUS_GOODS_VEHICLES_PROHIBITED":
                case 164:
                    message.trafficMainSignType = 164;
                    break;
                case "TYPE_OVER_WEIGHT_VEHICLES_PROHIBITED":
                case 165:
                    message.trafficMainSignType = 165;
                    break;
                case "TYPE_VEHICLES_AXLE_OVER_WEIGHT_PROHIBITED":
                case 166:
                    message.trafficMainSignType = 166;
                    break;
                case "TYPE_VEHICLES_EXCESS_WIDTH_PROHIBITED":
                case 167:
                    message.trafficMainSignType = 167;
                    break;
                case "TYPE_VEHICLES_EXCESS_HEIGHT_PROHIBITED":
                case 168:
                    message.trafficMainSignType = 168;
                    break;
                case "TYPE_VEHICLES_EXCESS_LENGTH_PROHIBITED":
                case 169:
                    message.trafficMainSignType = 169;
                    break;
                case "TYPE_DO_NOT_ENTER":
                case 44:
                    message.trafficMainSignType = 44;
                    break;
                case "TYPE_SNOW_CHAINS_REQUIRED":
                case 170:
                    message.trafficMainSignType = 170;
                    break;
                case "TYPE_WATER_POLLUTANT_VEHICLES_PROHIBITED":
                case 171:
                    message.trafficMainSignType = 171;
                    break;
                case "TYPE_ENVIRONMENTAL_ZONE_BEGIN":
                case 45:
                    message.trafficMainSignType = 45;
                    break;
                case "TYPE_ENVIRONMENTAL_ZONE_END":
                case 46:
                    message.trafficMainSignType = 46;
                    break;
                case "TYPE_NO_U_TURN_LEFT":
                case 47:
                    message.trafficMainSignType = 47;
                    break;
                case "TYPE_NO_U_TURN_RIGHT":
                case 48:
                    message.trafficMainSignType = 48;
                    break;
                case "TYPE_PRESCRIBED_U_TURN_LEFT":
                case 49:
                    message.trafficMainSignType = 49;
                    break;
                case "TYPE_PRESCRIBED_U_TURN_RIGHT":
                case 50:
                    message.trafficMainSignType = 50;
                    break;
                case "TYPE_MINIMUM_DISTANCE_FOR_TRUCKS":
                case 51:
                    message.trafficMainSignType = 51;
                    break;
                case "TYPE_SPEED_LIMIT_BEGIN":
                case 52:
                    message.trafficMainSignType = 52;
                    break;
                case "TYPE_SPEED_LIMIT_ZONE_BEGIN":
                case 53:
                    message.trafficMainSignType = 53;
                    break;
                case "TYPE_SPEED_LIMIT_ZONE_END":
                case 54:
                    message.trafficMainSignType = 54;
                    break;
                case "TYPE_MINIMUM_SPEED_BEGIN":
                case 55:
                    message.trafficMainSignType = 55;
                    break;
                case "TYPE_OVERTAKING_BAN_BEGIN":
                case 56:
                    message.trafficMainSignType = 56;
                    break;
                case "TYPE_OVERTAKING_BAN_FOR_TRUCKS_BEGIN":
                case 57:
                    message.trafficMainSignType = 57;
                    break;
                case "TYPE_SPEED_LIMIT_END":
                case 58:
                    message.trafficMainSignType = 58;
                    break;
                case "TYPE_MINIMUM_SPEED_END":
                case 59:
                    message.trafficMainSignType = 59;
                    break;
                case "TYPE_OVERTAKING_BAN_END":
                case 60:
                    message.trafficMainSignType = 60;
                    break;
                case "TYPE_OVERTAKING_BAN_FOR_TRUCKS_END":
                case 61:
                    message.trafficMainSignType = 61;
                    break;
                case "TYPE_ALL_RESTRICTIONS_END":
                case 62:
                    message.trafficMainSignType = 62;
                    break;
                case "TYPE_NO_STOPPING":
                case 63:
                    message.trafficMainSignType = 63;
                    break;
                case "TYPE_NO_PARKING":
                case 64:
                    message.trafficMainSignType = 64;
                    break;
                case "TYPE_NO_PARKING_ZONE_BEGIN":
                case 65:
                    message.trafficMainSignType = 65;
                    break;
                case "TYPE_NO_PARKING_ZONE_END":
                case 66:
                    message.trafficMainSignType = 66;
                    break;
                case "TYPE_RIGHT_OF_WAY_NEXT_INTERSECTION":
                case 67:
                    message.trafficMainSignType = 67;
                    break;
                case "TYPE_RIGHT_OF_WAY_BEGIN":
                case 68:
                    message.trafficMainSignType = 68;
                    break;
                case "TYPE_RIGHT_OF_WAY_END":
                case 69:
                    message.trafficMainSignType = 69;
                    break;
                case "TYPE_PRIORITY_OVER_OPPOSITE_DIRECTION":
                case 70:
                    message.trafficMainSignType = 70;
                    break;
                case "TYPE_PRIORITY_OVER_OPPOSITE_DIRECTION_UPSIDE_DOWN":
                case 71:
                    message.trafficMainSignType = 71;
                    break;
                case "TYPE_TOWN_BEGIN":
                case 72:
                    message.trafficMainSignType = 72;
                    break;
                case "TYPE_TOWN_END":
                case 73:
                    message.trafficMainSignType = 73;
                    break;
                case "TYPE_CAR_PARKING":
                case 74:
                    message.trafficMainSignType = 74;
                    break;
                case "TYPE_CAR_PARKING_ZONE_BEGIN":
                case 75:
                    message.trafficMainSignType = 75;
                    break;
                case "TYPE_CAR_PARKING_ZONE_END":
                case 76:
                    message.trafficMainSignType = 76;
                    break;
                case "TYPE_SIDEWALK_HALF_PARKING_LEFT":
                case 172:
                    message.trafficMainSignType = 172;
                    break;
                case "TYPE_SIDEWALK_HALF_PARKING_RIGHT":
                case 173:
                    message.trafficMainSignType = 173;
                    break;
                case "TYPE_SIDEWALK_PARKING_LEFT":
                case 174:
                    message.trafficMainSignType = 174;
                    break;
                case "TYPE_SIDEWALK_PARKING_RIGHT":
                case 175:
                    message.trafficMainSignType = 175;
                    break;
                case "TYPE_SIDEWALK_PERPENDICULAR_HALF_PARKING_LEFT":
                case 176:
                    message.trafficMainSignType = 176;
                    break;
                case "TYPE_SIDEWALK_PERPENDICULAR_HALF_PARKING_RIGHT":
                case 177:
                    message.trafficMainSignType = 177;
                    break;
                case "TYPE_SIDEWALK_PERPENDICULAR_PARKING_LEFT":
                case 178:
                    message.trafficMainSignType = 178;
                    break;
                case "TYPE_SIDEWALK_PERPENDICULAR_PARKING_RIGHT":
                case 179:
                    message.trafficMainSignType = 179;
                    break;
                case "TYPE_LIVING_STREET_BEGIN":
                case 77:
                    message.trafficMainSignType = 77;
                    break;
                case "TYPE_LIVING_STREET_END":
                case 78:
                    message.trafficMainSignType = 78;
                    break;
                case "TYPE_TUNNEL":
                case 79:
                    message.trafficMainSignType = 79;
                    break;
                case "TYPE_EMERGENCY_STOPPING_LEFT":
                case 80:
                    message.trafficMainSignType = 80;
                    break;
                case "TYPE_EMERGENCY_STOPPING_RIGHT":
                case 81:
                    message.trafficMainSignType = 81;
                    break;
                case "TYPE_HIGHWAY_BEGIN":
                case 82:
                    message.trafficMainSignType = 82;
                    break;
                case "TYPE_HIGHWAY_END":
                case 83:
                    message.trafficMainSignType = 83;
                    break;
                case "TYPE_EXPRESSWAY_BEGIN":
                case 84:
                    message.trafficMainSignType = 84;
                    break;
                case "TYPE_EXPRESSWAY_END":
                case 85:
                    message.trafficMainSignType = 85;
                    break;
                case "TYPE_NAMED_HIGHWAY_EXIT":
                case 183:
                    message.trafficMainSignType = 183;
                    break;
                case "TYPE_NAMED_EXPRESSWAY_EXIT":
                case 184:
                    message.trafficMainSignType = 184;
                    break;
                case "TYPE_NAMED_ROAD_EXIT":
                case 185:
                    message.trafficMainSignType = 185;
                    break;
                case "TYPE_HIGHWAY_EXIT":
                case 86:
                    message.trafficMainSignType = 86;
                    break;
                case "TYPE_EXPRESSWAY_EXIT":
                case 186:
                    message.trafficMainSignType = 186;
                    break;
                case "TYPE_ONEWAY_STREET":
                case 187:
                    message.trafficMainSignType = 187;
                    break;
                case "TYPE_CROSSING_GUARDS":
                case 189:
                    message.trafficMainSignType = 189;
                    break;
                case "TYPE_DEADEND":
                case 190:
                    message.trafficMainSignType = 190;
                    break;
                case "TYPE_DEADEND_EXCLUDING_DESIGNATED_ACTORS":
                case 191:
                    message.trafficMainSignType = 191;
                    break;
                case "TYPE_FIRST_AID_STATION":
                case 194:
                    message.trafficMainSignType = 194;
                    break;
                case "TYPE_POLICE_STATION":
                case 195:
                    message.trafficMainSignType = 195;
                    break;
                case "TYPE_TELEPHONE":
                case 196:
                    message.trafficMainSignType = 196;
                    break;
                case "TYPE_FILLING_STATION":
                case 198:
                    message.trafficMainSignType = 198;
                    break;
                case "TYPE_HOTEL":
                case 201:
                    message.trafficMainSignType = 201;
                    break;
                case "TYPE_INN":
                case 202:
                    message.trafficMainSignType = 202;
                    break;
                case "TYPE_KIOSK":
                case 203:
                    message.trafficMainSignType = 203;
                    break;
                case "TYPE_TOILET":
                case 204:
                    message.trafficMainSignType = 204;
                    break;
                case "TYPE_CHAPEL":
                case 205:
                    message.trafficMainSignType = 205;
                    break;
                case "TYPE_TOURIST_INFO":
                case 206:
                    message.trafficMainSignType = 206;
                    break;
                case "TYPE_REPAIR_SERVICE":
                case 207:
                    message.trafficMainSignType = 207;
                    break;
                case "TYPE_PEDESTRIAN_UNDERPASS":
                case 208:
                    message.trafficMainSignType = 208;
                    break;
                case "TYPE_PEDESTRIAN_BRIDGE":
                case 209:
                    message.trafficMainSignType = 209;
                    break;
                case "TYPE_CAMPER_PLACE":
                case 213:
                    message.trafficMainSignType = 213;
                    break;
                case "TYPE_ADVISORY_SPEED_LIMIT_BEGIN":
                case 214:
                    message.trafficMainSignType = 214;
                    break;
                case "TYPE_ADVISORY_SPEED_LIMIT_END":
                case 215:
                    message.trafficMainSignType = 215;
                    break;
                case "TYPE_PLACE_NAME":
                case 216:
                    message.trafficMainSignType = 216;
                    break;
                case "TYPE_TOURIST_ATTRACTION":
                case 217:
                    message.trafficMainSignType = 217;
                    break;
                case "TYPE_TOURIST_ROUTE":
                case 218:
                    message.trafficMainSignType = 218;
                    break;
                case "TYPE_TOURIST_AREA":
                case 219:
                    message.trafficMainSignType = 219;
                    break;
                case "TYPE_SHOULDER_NOT_PASSABLE_MOTOR_VEHICLES":
                case 220:
                    message.trafficMainSignType = 220;
                    break;
                case "TYPE_SHOULDER_UNSAFE_TRUCKS_TRACTORS":
                case 221:
                    message.trafficMainSignType = 221;
                    break;
                case "TYPE_TOLL_BEGIN":
                case 222:
                    message.trafficMainSignType = 222;
                    break;
                case "TYPE_TOLL_END":
                case 223:
                    message.trafficMainSignType = 223;
                    break;
                case "TYPE_TOLL_ROAD":
                case 224:
                    message.trafficMainSignType = 224;
                    break;
                case "TYPE_CUSTOMS":
                case 225:
                    message.trafficMainSignType = 225;
                    break;
                case "TYPE_INTERNATIONAL_BORDER_INFO":
                case 226:
                    message.trafficMainSignType = 226;
                    break;
                case "TYPE_STREETLIGHT_RED_BAND":
                case 227:
                    message.trafficMainSignType = 227;
                    break;
                case "TYPE_FEDERAL_HIGHWAY_ROUTE_NUMBER":
                case 228:
                    message.trafficMainSignType = 228;
                    break;
                case "TYPE_HIGHWAY_ROUTE_NUMBER":
                case 229:
                    message.trafficMainSignType = 229;
                    break;
                case "TYPE_HIGHWAY_INTERCHANGE_NUMBER":
                case 230:
                    message.trafficMainSignType = 230;
                    break;
                case "TYPE_EUROPEAN_ROUTE_NUMBER":
                case 231:
                    message.trafficMainSignType = 231;
                    break;
                case "TYPE_FEDERAL_HIGHWAY_DIRECTION_LEFT":
                case 232:
                    message.trafficMainSignType = 232;
                    break;
                case "TYPE_FEDERAL_HIGHWAY_DIRECTION_RIGHT":
                case 233:
                    message.trafficMainSignType = 233;
                    break;
                case "TYPE_PRIMARY_ROAD_DIRECTION_LEFT":
                case 234:
                    message.trafficMainSignType = 234;
                    break;
                case "TYPE_PRIMARY_ROAD_DIRECTION_RIGHT":
                case 235:
                    message.trafficMainSignType = 235;
                    break;
                case "TYPE_SECONDARY_ROAD_DIRECTION_LEFT":
                case 236:
                    message.trafficMainSignType = 236;
                    break;
                case "TYPE_SECONDARY_ROAD_DIRECTION_RIGHT":
                case 237:
                    message.trafficMainSignType = 237;
                    break;
                case "TYPE_DIRECTION_DESIGNATED_ACTORS_LEFT":
                case 238:
                    message.trafficMainSignType = 238;
                    break;
                case "TYPE_DIRECTION_DESIGNATED_ACTORS_RIGHT":
                case 239:
                    message.trafficMainSignType = 239;
                    break;
                case "TYPE_ROUTING_DESIGNATED_ACTORS":
                case 240:
                    message.trafficMainSignType = 240;
                    break;
                case "TYPE_DIRECTION_TO_HIGHWAY_LEFT":
                case 143:
                    message.trafficMainSignType = 143;
                    break;
                case "TYPE_DIRECTION_TO_HIGHWAY_RIGHT":
                case 108:
                    message.trafficMainSignType = 108;
                    break;
                case "TYPE_DIRECTION_TO_LOCAL_DESTINATION_LEFT":
                case 127:
                    message.trafficMainSignType = 127;
                    break;
                case "TYPE_DIRECTION_TO_LOCAL_DESTINATION_RIGHT":
                case 136:
                    message.trafficMainSignType = 136;
                    break;
                case "TYPE_CONSOLIDATED_DIRECTIONS":
                case 118:
                    message.trafficMainSignType = 118;
                    break;
                case "TYPE_STREET_NAME":
                case 119:
                    message.trafficMainSignType = 119;
                    break;
                case "TYPE_DIRECTION_PREANNOUNCEMENT":
                case 120:
                    message.trafficMainSignType = 120;
                    break;
                case "TYPE_DIRECTION_PREANNOUNCEMENT_LANE_CONFIG":
                case 121:
                    message.trafficMainSignType = 121;
                    break;
                case "TYPE_DIRECTION_PREANNOUNCEMENT_HIGHWAY_ENTRIES":
                case 122:
                    message.trafficMainSignType = 122;
                    break;
                case "TYPE_HIGHWAY_ANNOUNCEMENT":
                case 123:
                    message.trafficMainSignType = 123;
                    break;
                case "TYPE_OTHER_ROAD_ANNOUNCEMENT":
                case 124:
                    message.trafficMainSignType = 124;
                    break;
                case "TYPE_HIGHWAY_ANNOUNCEMENT_TRUCK_STOP":
                case 125:
                    message.trafficMainSignType = 125;
                    break;
                case "TYPE_HIGHWAY_PREANNOUNCEMENT_DIRECTIONS":
                case 126:
                    message.trafficMainSignType = 126;
                    break;
                case "TYPE_POLE_EXIT":
                case 88:
                    message.trafficMainSignType = 88;
                    break;
                case "TYPE_HIGHWAY_DISTANCE_BOARD":
                case 180:
                    message.trafficMainSignType = 180;
                    break;
                case "TYPE_DETOUR_LEFT":
                case 181:
                    message.trafficMainSignType = 181;
                    break;
                case "TYPE_DETOUR_RIGHT":
                case 182:
                    message.trafficMainSignType = 182;
                    break;
                case "TYPE_NUMBERED_DETOUR":
                case 131:
                    message.trafficMainSignType = 131;
                    break;
                case "TYPE_DETOUR_BEGIN":
                case 132:
                    message.trafficMainSignType = 132;
                    break;
                case "TYPE_DETOUR_END":
                case 133:
                    message.trafficMainSignType = 133;
                    break;
                case "TYPE_DETOUR_ROUTING_BOARD":
                case 134:
                    message.trafficMainSignType = 134;
                    break;
                case "TYPE_OPTIONAL_DETOUR":
                case 111:
                    message.trafficMainSignType = 111;
                    break;
                case "TYPE_OPTIONAL_DETOUR_ROUTING":
                case 199:
                    message.trafficMainSignType = 199;
                    break;
                case "TYPE_ROUTE_RECOMMENDATION":
                case 211:
                    message.trafficMainSignType = 211;
                    break;
                case "TYPE_ROUTE_RECOMMENDATION_END":
                case 212:
                    message.trafficMainSignType = 212;
                    break;
                case "TYPE_ANNOUNCE_LANE_TRANSITION_LEFT":
                case 192:
                    message.trafficMainSignType = 192;
                    break;
                case "TYPE_ANNOUNCE_LANE_TRANSITION_RIGHT":
                case 193:
                    message.trafficMainSignType = 193;
                    break;
                case "TYPE_ANNOUNCE_RIGHT_LANE_END":
                case 90:
                    message.trafficMainSignType = 90;
                    break;
                case "TYPE_ANNOUNCE_LEFT_LANE_END":
                case 89:
                    message.trafficMainSignType = 89;
                    break;
                case "TYPE_ANNOUNCE_RIGHT_LANE_BEGIN":
                case 115:
                    message.trafficMainSignType = 115;
                    break;
                case "TYPE_ANNOUNCE_LEFT_LANE_BEGIN":
                case 116:
                    message.trafficMainSignType = 116;
                    break;
                case "TYPE_ANNOUNCE_LANE_CONSOLIDATION":
                case 117:
                    message.trafficMainSignType = 117;
                    break;
                case "TYPE_DETOUR_CITY_BLOCK":
                case 142:
                    message.trafficMainSignType = 142;
                    break;
                case "TYPE_GATE":
                case 141:
                    message.trafficMainSignType = 141;
                    break;
                case "TYPE_POLE_WARNING":
                case 91:
                    message.trafficMainSignType = 91;
                    break;
                case "TYPE_TRAFFIC_CONE":
                case 140:
                    message.trafficMainSignType = 140;
                    break;
                case "TYPE_MOBILE_LANE_CLOSURE":
                case 139:
                    message.trafficMainSignType = 139;
                    break;
                case "TYPE_REFLECTOR_POST":
                case 114:
                    message.trafficMainSignType = 114;
                    break;
                case "TYPE_DIRECTIONAL_BOARD_WARNING":
                case 113:
                    message.trafficMainSignType = 113;
                    break;
                case "TYPE_GUIDING_PLATE":
                case 104:
                    message.trafficMainSignType = 104;
                    break;
                case "TYPE_GUIDING_PLATE_WEDGES":
                case 105:
                    message.trafficMainSignType = 105;
                    break;
                case "TYPE_PARKING_HAZARD":
                case 99:
                    message.trafficMainSignType = 99;
                    break;
                case "TYPE_TRAFFIC_LIGHT_GREEN_ARROW":
                case 92:
                    message.trafficMainSignType = 92;
                    break;
                }
                switch (object.monochromeColor) {
                default:
                    if (typeof object.monochromeColor === "number") {
                        message.monochromeColor = object.monochromeColor;
                        break;
                    }
                    break;
                case "COLOR_UNKNOWN":
                case 0:
                    message.monochromeColor = 0;
                    break;
                case "COLOR_OTHER":
                case 1:
                    message.monochromeColor = 1;
                    break;
                case "COLOR_WHITE":
                case 2:
                    message.monochromeColor = 2;
                    break;
                case "COLOR_YELLOW":
                case 3:
                    message.monochromeColor = 3;
                    break;
                case "COLOR_BLUE":
                case 5:
                    message.monochromeColor = 5;
                    break;
                case "COLOR_RED":
                case 6:
                    message.monochromeColor = 6;
                    break;
                case "COLOR_GREEN":
                case 7:
                    message.monochromeColor = 7;
                    break;
                case "COLOR_VIOLET":
                case 8:
                    message.monochromeColor = 8;
                    break;
                case "COLOR_ORANGE":
                case 9:
                    message.monochromeColor = 9;
                    break;
                }
                if (object.value != null) {
                    if (typeof object.value !== "object")
                        throw TypeError(".osi3.RoadMarking.Classification.value: object expected");
                    message.value = $root.osi3.TrafficSignValue.fromObject(object.value);
                }
                if (object.valueText != null)
                    message.valueText = String(object.valueText);
                if (object.assignedLaneId) {
                    if (!Array.isArray(object.assignedLaneId))
                        throw TypeError(".osi3.RoadMarking.Classification.assignedLaneId: array expected");
                    message.assignedLaneId = [];
                    for (let i = 0; i < object.assignedLaneId.length; ++i) {
                        if (typeof object.assignedLaneId[i] !== "object")
                            throw TypeError(".osi3.RoadMarking.Classification.assignedLaneId: object expected");
                        message.assignedLaneId[i] = $root.osi3.Identifier.fromObject(object.assignedLaneId[i]);
                    }
                }
                if (object.isOutOfService != null)
                    message.isOutOfService = Boolean(object.isOutOfService);
                if (object.country != null)
                    message.country = String(object.country);
                if (object.countryRevision != null)
                    message.countryRevision = String(object.countryRevision);
                if (object.code != null)
                    message.code = String(object.code);
                if (object.subCode != null)
                    message.subCode = String(object.subCode);
                if (object.logicalLaneAssignment) {
                    if (!Array.isArray(object.logicalLaneAssignment))
                        throw TypeError(".osi3.RoadMarking.Classification.logicalLaneAssignment: array expected");
                    message.logicalLaneAssignment = [];
                    for (let i = 0; i < object.logicalLaneAssignment.length; ++i) {
                        if (typeof object.logicalLaneAssignment[i] !== "object")
                            throw TypeError(".osi3.RoadMarking.Classification.logicalLaneAssignment: object expected");
                        message.logicalLaneAssignment[i] = $root.osi3.LogicalLaneAssignment.fromObject(object.logicalLaneAssignment[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a Classification message. Also converts values to other types if specified.
             * @function toObject
             * @memberof osi3.RoadMarking.Classification
             * @static
             * @param {osi3.RoadMarking.Classification} message Classification
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Classification.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults) {
                    object.assignedLaneId = [];
                    object.logicalLaneAssignment = [];
                }
                if (options.defaults) {
                    object.type = options.enums === String ? "TYPE_UNKNOWN" : 0;
                    object.trafficMainSignType = options.enums === String ? "TYPE_UNKNOWN" : 0;
                    object.monochromeColor = options.enums === String ? "COLOR_UNKNOWN" : 0;
                    object.value = null;
                    object.valueText = "";
                    object.isOutOfService = false;
                    object.country = "";
                    object.countryRevision = "";
                    object.code = "";
                    object.subCode = "";
                }
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.osi3.RoadMarking.Classification.Type[message.type] === undefined ? message.type : $root.osi3.RoadMarking.Classification.Type[message.type] : message.type;
                if (message.trafficMainSignType != null && message.hasOwnProperty("trafficMainSignType"))
                    object.trafficMainSignType = options.enums === String ? $root.osi3.TrafficSign.MainSign.Classification.Type[message.trafficMainSignType] === undefined ? message.trafficMainSignType : $root.osi3.TrafficSign.MainSign.Classification.Type[message.trafficMainSignType] : message.trafficMainSignType;
                if (message.monochromeColor != null && message.hasOwnProperty("monochromeColor"))
                    object.monochromeColor = options.enums === String ? $root.osi3.RoadMarking.Classification.Color[message.monochromeColor] === undefined ? message.monochromeColor : $root.osi3.RoadMarking.Classification.Color[message.monochromeColor] : message.monochromeColor;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = $root.osi3.TrafficSignValue.toObject(message.value, options);
                if (message.valueText != null && message.hasOwnProperty("valueText"))
                    object.valueText = message.valueText;
                if (message.assignedLaneId && message.assignedLaneId.length) {
                    object.assignedLaneId = [];
                    for (let j = 0; j < message.assignedLaneId.length; ++j)
                        object.assignedLaneId[j] = $root.osi3.Identifier.toObject(message.assignedLaneId[j], options);
                }
                if (message.isOutOfService != null && message.hasOwnProperty("isOutOfService"))
                    object.isOutOfService = message.isOutOfService;
                if (message.country != null && message.hasOwnProperty("country"))
                    object.country = message.country;
                if (message.countryRevision != null && message.hasOwnProperty("countryRevision"))
                    object.countryRevision = message.countryRevision;
                if (message.code != null && message.hasOwnProperty("code"))
                    object.code = message.code;
                if (message.subCode != null && message.hasOwnProperty("subCode"))
                    object.subCode = message.subCode;
                if (message.logicalLaneAssignment && message.logicalLaneAssignment.length) {
                    object.logicalLaneAssignment = [];
                    for (let j = 0; j < message.logicalLaneAssignment.length; ++j)
                        object.logicalLaneAssignment[j] = $root.osi3.LogicalLaneAssignment.toObject(message.logicalLaneAssignment[j], options);
                }
                return object;
            };

            /**
             * Converts this Classification to JSON.
             * @function toJSON
             * @memberof osi3.RoadMarking.Classification
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Classification.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Classification
             * @function getTypeUrl
             * @memberof osi3.RoadMarking.Classification
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Classification.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/osi3.RoadMarking.Classification";
            };

            /**
             * Type enum.
             * @name osi3.RoadMarking.Classification.Type
             * @enum {number}
             * @property {number} TYPE_UNKNOWN=0 TYPE_UNKNOWN value
             * @property {number} TYPE_OTHER=1 TYPE_OTHER value
             * @property {number} TYPE_PAINTED_TRAFFIC_SIGN=2 TYPE_PAINTED_TRAFFIC_SIGN value
             * @property {number} TYPE_SYMBOLIC_TRAFFIC_SIGN=3 TYPE_SYMBOLIC_TRAFFIC_SIGN value
             * @property {number} TYPE_TEXTUAL_TRAFFIC_SIGN=4 TYPE_TEXTUAL_TRAFFIC_SIGN value
             * @property {number} TYPE_GENERIC_SYMBOL=5 TYPE_GENERIC_SYMBOL value
             * @property {number} TYPE_GENERIC_LINE=6 TYPE_GENERIC_LINE value
             * @property {number} TYPE_GENERIC_TEXT=7 TYPE_GENERIC_TEXT value
             */
            Classification.Type = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "TYPE_UNKNOWN"] = 0;
                values[valuesById[1] = "TYPE_OTHER"] = 1;
                values[valuesById[2] = "TYPE_PAINTED_TRAFFIC_SIGN"] = 2;
                values[valuesById[3] = "TYPE_SYMBOLIC_TRAFFIC_SIGN"] = 3;
                values[valuesById[4] = "TYPE_TEXTUAL_TRAFFIC_SIGN"] = 4;
                values[valuesById[5] = "TYPE_GENERIC_SYMBOL"] = 5;
                values[valuesById[6] = "TYPE_GENERIC_LINE"] = 6;
                values[valuesById[7] = "TYPE_GENERIC_TEXT"] = 7;
                return values;
            })();

            /**
             * Color enum.
             * @name osi3.RoadMarking.Classification.Color
             * @enum {number}
             * @property {number} COLOR_UNKNOWN=0 COLOR_UNKNOWN value
             * @property {number} COLOR_OTHER=1 COLOR_OTHER value
             * @property {number} COLOR_WHITE=2 COLOR_WHITE value
             * @property {number} COLOR_YELLOW=3 COLOR_YELLOW value
             * @property {number} COLOR_BLUE=5 COLOR_BLUE value
             * @property {number} COLOR_RED=6 COLOR_RED value
             * @property {number} COLOR_GREEN=7 COLOR_GREEN value
             * @property {number} COLOR_VIOLET=8 COLOR_VIOLET value
             * @property {number} COLOR_ORANGE=9 COLOR_ORANGE value
             */
            Classification.Color = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "COLOR_UNKNOWN"] = 0;
                values[valuesById[1] = "COLOR_OTHER"] = 1;
                values[valuesById[2] = "COLOR_WHITE"] = 2;
                values[valuesById[3] = "COLOR_YELLOW"] = 3;
                values[valuesById[5] = "COLOR_BLUE"] = 5;
                values[valuesById[6] = "COLOR_RED"] = 6;
                values[valuesById[7] = "COLOR_GREEN"] = 7;
                values[valuesById[8] = "COLOR_VIOLET"] = 8;
                values[valuesById[9] = "COLOR_ORANGE"] = 9;
                return values;
            })();

            return Classification;
        })();

        return RoadMarking;
    })();

    osi3.Lane = (function() {

        /**
         * Properties of a Lane.
         * @memberof osi3
         * @interface ILane
         * @property {osi3.IIdentifier|null} [id] Lane id
         * @property {osi3.Lane.IClassification|null} [classification] Lane classification
         * @property {Array.<osi3.IExternalReference>|null} [sourceReference] Lane sourceReference
         */

        /**
         * Constructs a new Lane.
         * @memberof osi3
         * @classdesc Represents a Lane.
         * @implements ILane
         * @constructor
         * @param {osi3.ILane=} [properties] Properties to set
         */
        function Lane(properties) {
            this.sourceReference = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Lane id.
         * @member {osi3.IIdentifier|null|undefined} id
         * @memberof osi3.Lane
         * @instance
         */
        Lane.prototype.id = null;

        /**
         * Lane classification.
         * @member {osi3.Lane.IClassification|null|undefined} classification
         * @memberof osi3.Lane
         * @instance
         */
        Lane.prototype.classification = null;

        /**
         * Lane sourceReference.
         * @member {Array.<osi3.IExternalReference>} sourceReference
         * @memberof osi3.Lane
         * @instance
         */
        Lane.prototype.sourceReference = $util.emptyArray;

        /**
         * Creates a new Lane instance using the specified properties.
         * @function create
         * @memberof osi3.Lane
         * @static
         * @param {osi3.ILane=} [properties] Properties to set
         * @returns {osi3.Lane} Lane instance
         */
        Lane.create = function create(properties) {
            return new Lane(properties);
        };

        /**
         * Encodes the specified Lane message. Does not implicitly {@link osi3.Lane.verify|verify} messages.
         * @function encode
         * @memberof osi3.Lane
         * @static
         * @param {osi3.ILane} message Lane message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Lane.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                $root.osi3.Identifier.encode(message.id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.classification != null && Object.hasOwnProperty.call(message, "classification"))
                $root.osi3.Lane.Classification.encode(message.classification, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.sourceReference != null && message.sourceReference.length)
                for (let i = 0; i < message.sourceReference.length; ++i)
                    $root.osi3.ExternalReference.encode(message.sourceReference[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Lane message, length delimited. Does not implicitly {@link osi3.Lane.verify|verify} messages.
         * @function encodeDelimited
         * @memberof osi3.Lane
         * @static
         * @param {osi3.ILane} message Lane message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Lane.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Lane message from the specified reader or buffer.
         * @function decode
         * @memberof osi3.Lane
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {osi3.Lane} Lane
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Lane.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.osi3.Lane();
            while (reader.pos < end) {
                let tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.id = $root.osi3.Identifier.decode(reader, reader.uint32());
                        break;
                    }
                case 2: {
                        message.classification = $root.osi3.Lane.Classification.decode(reader, reader.uint32());
                        break;
                    }
                case 3: {
                        if (!(message.sourceReference && message.sourceReference.length))
                            message.sourceReference = [];
                        message.sourceReference.push($root.osi3.ExternalReference.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Lane message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof osi3.Lane
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {osi3.Lane} Lane
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Lane.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Lane message.
         * @function verify
         * @memberof osi3.Lane
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Lane.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id")) {
                let error = $root.osi3.Identifier.verify(message.id);
                if (error)
                    return "id." + error;
            }
            if (message.classification != null && message.hasOwnProperty("classification")) {
                let error = $root.osi3.Lane.Classification.verify(message.classification);
                if (error)
                    return "classification." + error;
            }
            if (message.sourceReference != null && message.hasOwnProperty("sourceReference")) {
                if (!Array.isArray(message.sourceReference))
                    return "sourceReference: array expected";
                for (let i = 0; i < message.sourceReference.length; ++i) {
                    let error = $root.osi3.ExternalReference.verify(message.sourceReference[i]);
                    if (error)
                        return "sourceReference." + error;
                }
            }
            return null;
        };

        /**
         * Creates a Lane message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof osi3.Lane
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {osi3.Lane} Lane
         */
        Lane.fromObject = function fromObject(object) {
            if (object instanceof $root.osi3.Lane)
                return object;
            let message = new $root.osi3.Lane();
            if (object.id != null) {
                if (typeof object.id !== "object")
                    throw TypeError(".osi3.Lane.id: object expected");
                message.id = $root.osi3.Identifier.fromObject(object.id);
            }
            if (object.classification != null) {
                if (typeof object.classification !== "object")
                    throw TypeError(".osi3.Lane.classification: object expected");
                message.classification = $root.osi3.Lane.Classification.fromObject(object.classification);
            }
            if (object.sourceReference) {
                if (!Array.isArray(object.sourceReference))
                    throw TypeError(".osi3.Lane.sourceReference: array expected");
                message.sourceReference = [];
                for (let i = 0; i < object.sourceReference.length; ++i) {
                    if (typeof object.sourceReference[i] !== "object")
                        throw TypeError(".osi3.Lane.sourceReference: object expected");
                    message.sourceReference[i] = $root.osi3.ExternalReference.fromObject(object.sourceReference[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a Lane message. Also converts values to other types if specified.
         * @function toObject
         * @memberof osi3.Lane
         * @static
         * @param {osi3.Lane} message Lane
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Lane.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.sourceReference = [];
            if (options.defaults) {
                object.id = null;
                object.classification = null;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = $root.osi3.Identifier.toObject(message.id, options);
            if (message.classification != null && message.hasOwnProperty("classification"))
                object.classification = $root.osi3.Lane.Classification.toObject(message.classification, options);
            if (message.sourceReference && message.sourceReference.length) {
                object.sourceReference = [];
                for (let j = 0; j < message.sourceReference.length; ++j)
                    object.sourceReference[j] = $root.osi3.ExternalReference.toObject(message.sourceReference[j], options);
            }
            return object;
        };

        /**
         * Converts this Lane to JSON.
         * @function toJSON
         * @memberof osi3.Lane
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Lane.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Lane
         * @function getTypeUrl
         * @memberof osi3.Lane
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Lane.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/osi3.Lane";
        };

        Lane.Classification = (function() {

            /**
             * Properties of a Classification.
             * @memberof osi3.Lane
             * @interface IClassification
             * @property {osi3.Lane.Classification.Type|null} [type] Classification type
             * @property {boolean|null} [isHostVehicleLane] Classification isHostVehicleLane
             * @property {Array.<osi3.IVector3d>|null} [centerline] Classification centerline
             * @property {boolean|null} [centerlineIsDrivingDirection] Classification centerlineIsDrivingDirection
             * @property {Array.<osi3.IIdentifier>|null} [leftAdjacentLaneId] Classification leftAdjacentLaneId
             * @property {Array.<osi3.IIdentifier>|null} [rightAdjacentLaneId] Classification rightAdjacentLaneId
             * @property {Array.<osi3.Lane.Classification.ILanePairing>|null} [lanePairing] Classification lanePairing
             * @property {Array.<osi3.IIdentifier>|null} [rightLaneBoundaryId] Classification rightLaneBoundaryId
             * @property {Array.<osi3.IIdentifier>|null} [leftLaneBoundaryId] Classification leftLaneBoundaryId
             * @property {Array.<osi3.IIdentifier>|null} [freeLaneBoundaryId] Classification freeLaneBoundaryId
             * @property {osi3.Lane.Classification.IRoadCondition|null} [roadCondition] Classification roadCondition
             * @property {osi3.Lane.Classification.Subtype|null} [subtype] Classification subtype
             */

            /**
             * Constructs a new Classification.
             * @memberof osi3.Lane
             * @classdesc Represents a Classification.
             * @implements IClassification
             * @constructor
             * @param {osi3.Lane.IClassification=} [properties] Properties to set
             */
            function Classification(properties) {
                this.centerline = [];
                this.leftAdjacentLaneId = [];
                this.rightAdjacentLaneId = [];
                this.lanePairing = [];
                this.rightLaneBoundaryId = [];
                this.leftLaneBoundaryId = [];
                this.freeLaneBoundaryId = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Classification type.
             * @member {osi3.Lane.Classification.Type} type
             * @memberof osi3.Lane.Classification
             * @instance
             */
            Classification.prototype.type = 0;

            /**
             * Classification isHostVehicleLane.
             * @member {boolean} isHostVehicleLane
             * @memberof osi3.Lane.Classification
             * @instance
             */
            Classification.prototype.isHostVehicleLane = false;

            /**
             * Classification centerline.
             * @member {Array.<osi3.IVector3d>} centerline
             * @memberof osi3.Lane.Classification
             * @instance
             */
            Classification.prototype.centerline = $util.emptyArray;

            /**
             * Classification centerlineIsDrivingDirection.
             * @member {boolean} centerlineIsDrivingDirection
             * @memberof osi3.Lane.Classification
             * @instance
             */
            Classification.prototype.centerlineIsDrivingDirection = false;

            /**
             * Classification leftAdjacentLaneId.
             * @member {Array.<osi3.IIdentifier>} leftAdjacentLaneId
             * @memberof osi3.Lane.Classification
             * @instance
             */
            Classification.prototype.leftAdjacentLaneId = $util.emptyArray;

            /**
             * Classification rightAdjacentLaneId.
             * @member {Array.<osi3.IIdentifier>} rightAdjacentLaneId
             * @memberof osi3.Lane.Classification
             * @instance
             */
            Classification.prototype.rightAdjacentLaneId = $util.emptyArray;

            /**
             * Classification lanePairing.
             * @member {Array.<osi3.Lane.Classification.ILanePairing>} lanePairing
             * @memberof osi3.Lane.Classification
             * @instance
             */
            Classification.prototype.lanePairing = $util.emptyArray;

            /**
             * Classification rightLaneBoundaryId.
             * @member {Array.<osi3.IIdentifier>} rightLaneBoundaryId
             * @memberof osi3.Lane.Classification
             * @instance
             */
            Classification.prototype.rightLaneBoundaryId = $util.emptyArray;

            /**
             * Classification leftLaneBoundaryId.
             * @member {Array.<osi3.IIdentifier>} leftLaneBoundaryId
             * @memberof osi3.Lane.Classification
             * @instance
             */
            Classification.prototype.leftLaneBoundaryId = $util.emptyArray;

            /**
             * Classification freeLaneBoundaryId.
             * @member {Array.<osi3.IIdentifier>} freeLaneBoundaryId
             * @memberof osi3.Lane.Classification
             * @instance
             */
            Classification.prototype.freeLaneBoundaryId = $util.emptyArray;

            /**
             * Classification roadCondition.
             * @member {osi3.Lane.Classification.IRoadCondition|null|undefined} roadCondition
             * @memberof osi3.Lane.Classification
             * @instance
             */
            Classification.prototype.roadCondition = null;

            /**
             * Classification subtype.
             * @member {osi3.Lane.Classification.Subtype} subtype
             * @memberof osi3.Lane.Classification
             * @instance
             */
            Classification.prototype.subtype = 0;

            /**
             * Creates a new Classification instance using the specified properties.
             * @function create
             * @memberof osi3.Lane.Classification
             * @static
             * @param {osi3.Lane.IClassification=} [properties] Properties to set
             * @returns {osi3.Lane.Classification} Classification instance
             */
            Classification.create = function create(properties) {
                return new Classification(properties);
            };

            /**
             * Encodes the specified Classification message. Does not implicitly {@link osi3.Lane.Classification.verify|verify} messages.
             * @function encode
             * @memberof osi3.Lane.Classification
             * @static
             * @param {osi3.Lane.IClassification} message Classification message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Classification.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                if (message.isHostVehicleLane != null && Object.hasOwnProperty.call(message, "isHostVehicleLane"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.isHostVehicleLane);
                if (message.centerline != null && message.centerline.length)
                    for (let i = 0; i < message.centerline.length; ++i)
                        $root.osi3.Vector3d.encode(message.centerline[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.centerlineIsDrivingDirection != null && Object.hasOwnProperty.call(message, "centerlineIsDrivingDirection"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.centerlineIsDrivingDirection);
                if (message.leftAdjacentLaneId != null && message.leftAdjacentLaneId.length)
                    for (let i = 0; i < message.leftAdjacentLaneId.length; ++i)
                        $root.osi3.Identifier.encode(message.leftAdjacentLaneId[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.rightAdjacentLaneId != null && message.rightAdjacentLaneId.length)
                    for (let i = 0; i < message.rightAdjacentLaneId.length; ++i)
                        $root.osi3.Identifier.encode(message.rightAdjacentLaneId[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.lanePairing != null && message.lanePairing.length)
                    for (let i = 0; i < message.lanePairing.length; ++i)
                        $root.osi3.Lane.Classification.LanePairing.encode(message.lanePairing[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.rightLaneBoundaryId != null && message.rightLaneBoundaryId.length)
                    for (let i = 0; i < message.rightLaneBoundaryId.length; ++i)
                        $root.osi3.Identifier.encode(message.rightLaneBoundaryId[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.leftLaneBoundaryId != null && message.leftLaneBoundaryId.length)
                    for (let i = 0; i < message.leftLaneBoundaryId.length; ++i)
                        $root.osi3.Identifier.encode(message.leftLaneBoundaryId[i], writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                if (message.freeLaneBoundaryId != null && message.freeLaneBoundaryId.length)
                    for (let i = 0; i < message.freeLaneBoundaryId.length; ++i)
                        $root.osi3.Identifier.encode(message.freeLaneBoundaryId[i], writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                if (message.roadCondition != null && Object.hasOwnProperty.call(message, "roadCondition"))
                    $root.osi3.Lane.Classification.RoadCondition.encode(message.roadCondition, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                if (message.subtype != null && Object.hasOwnProperty.call(message, "subtype"))
                    writer.uint32(/* id 12, wireType 0 =*/96).int32(message.subtype);
                return writer;
            };

            /**
             * Encodes the specified Classification message, length delimited. Does not implicitly {@link osi3.Lane.Classification.verify|verify} messages.
             * @function encodeDelimited
             * @memberof osi3.Lane.Classification
             * @static
             * @param {osi3.Lane.IClassification} message Classification message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Classification.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Classification message from the specified reader or buffer.
             * @function decode
             * @memberof osi3.Lane.Classification
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {osi3.Lane.Classification} Classification
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Classification.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.osi3.Lane.Classification();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.type = reader.int32();
                            break;
                        }
                    case 2: {
                            message.isHostVehicleLane = reader.bool();
                            break;
                        }
                    case 3: {
                            if (!(message.centerline && message.centerline.length))
                                message.centerline = [];
                            message.centerline.push($root.osi3.Vector3d.decode(reader, reader.uint32()));
                            break;
                        }
                    case 4: {
                            message.centerlineIsDrivingDirection = reader.bool();
                            break;
                        }
                    case 5: {
                            if (!(message.leftAdjacentLaneId && message.leftAdjacentLaneId.length))
                                message.leftAdjacentLaneId = [];
                            message.leftAdjacentLaneId.push($root.osi3.Identifier.decode(reader, reader.uint32()));
                            break;
                        }
                    case 6: {
                            if (!(message.rightAdjacentLaneId && message.rightAdjacentLaneId.length))
                                message.rightAdjacentLaneId = [];
                            message.rightAdjacentLaneId.push($root.osi3.Identifier.decode(reader, reader.uint32()));
                            break;
                        }
                    case 7: {
                            if (!(message.lanePairing && message.lanePairing.length))
                                message.lanePairing = [];
                            message.lanePairing.push($root.osi3.Lane.Classification.LanePairing.decode(reader, reader.uint32()));
                            break;
                        }
                    case 8: {
                            if (!(message.rightLaneBoundaryId && message.rightLaneBoundaryId.length))
                                message.rightLaneBoundaryId = [];
                            message.rightLaneBoundaryId.push($root.osi3.Identifier.decode(reader, reader.uint32()));
                            break;
                        }
                    case 9: {
                            if (!(message.leftLaneBoundaryId && message.leftLaneBoundaryId.length))
                                message.leftLaneBoundaryId = [];
                            message.leftLaneBoundaryId.push($root.osi3.Identifier.decode(reader, reader.uint32()));
                            break;
                        }
                    case 10: {
                            if (!(message.freeLaneBoundaryId && message.freeLaneBoundaryId.length))
                                message.freeLaneBoundaryId = [];
                            message.freeLaneBoundaryId.push($root.osi3.Identifier.decode(reader, reader.uint32()));
                            break;
                        }
                    case 11: {
                            message.roadCondition = $root.osi3.Lane.Classification.RoadCondition.decode(reader, reader.uint32());
                            break;
                        }
                    case 12: {
                            message.subtype = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Classification message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof osi3.Lane.Classification
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {osi3.Lane.Classification} Classification
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Classification.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Classification message.
             * @function verify
             * @memberof osi3.Lane.Classification
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Classification.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                        break;
                    }
                if (message.isHostVehicleLane != null && message.hasOwnProperty("isHostVehicleLane"))
                    if (typeof message.isHostVehicleLane !== "boolean")
                        return "isHostVehicleLane: boolean expected";
                if (message.centerline != null && message.hasOwnProperty("centerline")) {
                    if (!Array.isArray(message.centerline))
                        return "centerline: array expected";
                    for (let i = 0; i < message.centerline.length; ++i) {
                        let error = $root.osi3.Vector3d.verify(message.centerline[i]);
                        if (error)
                            return "centerline." + error;
                    }
                }
                if (message.centerlineIsDrivingDirection != null && message.hasOwnProperty("centerlineIsDrivingDirection"))
                    if (typeof message.centerlineIsDrivingDirection !== "boolean")
                        return "centerlineIsDrivingDirection: boolean expected";
                if (message.leftAdjacentLaneId != null && message.hasOwnProperty("leftAdjacentLaneId")) {
                    if (!Array.isArray(message.leftAdjacentLaneId))
                        return "leftAdjacentLaneId: array expected";
                    for (let i = 0; i < message.leftAdjacentLaneId.length; ++i) {
                        let error = $root.osi3.Identifier.verify(message.leftAdjacentLaneId[i]);
                        if (error)
                            return "leftAdjacentLaneId." + error;
                    }
                }
                if (message.rightAdjacentLaneId != null && message.hasOwnProperty("rightAdjacentLaneId")) {
                    if (!Array.isArray(message.rightAdjacentLaneId))
                        return "rightAdjacentLaneId: array expected";
                    for (let i = 0; i < message.rightAdjacentLaneId.length; ++i) {
                        let error = $root.osi3.Identifier.verify(message.rightAdjacentLaneId[i]);
                        if (error)
                            return "rightAdjacentLaneId." + error;
                    }
                }
                if (message.lanePairing != null && message.hasOwnProperty("lanePairing")) {
                    if (!Array.isArray(message.lanePairing))
                        return "lanePairing: array expected";
                    for (let i = 0; i < message.lanePairing.length; ++i) {
                        let error = $root.osi3.Lane.Classification.LanePairing.verify(message.lanePairing[i]);
                        if (error)
                            return "lanePairing." + error;
                    }
                }
                if (message.rightLaneBoundaryId != null && message.hasOwnProperty("rightLaneBoundaryId")) {
                    if (!Array.isArray(message.rightLaneBoundaryId))
                        return "rightLaneBoundaryId: array expected";
                    for (let i = 0; i < message.rightLaneBoundaryId.length; ++i) {
                        let error = $root.osi3.Identifier.verify(message.rightLaneBoundaryId[i]);
                        if (error)
                            return "rightLaneBoundaryId." + error;
                    }
                }
                if (message.leftLaneBoundaryId != null && message.hasOwnProperty("leftLaneBoundaryId")) {
                    if (!Array.isArray(message.leftLaneBoundaryId))
                        return "leftLaneBoundaryId: array expected";
                    for (let i = 0; i < message.leftLaneBoundaryId.length; ++i) {
                        let error = $root.osi3.Identifier.verify(message.leftLaneBoundaryId[i]);
                        if (error)
                            return "leftLaneBoundaryId." + error;
                    }
                }
                if (message.freeLaneBoundaryId != null && message.hasOwnProperty("freeLaneBoundaryId")) {
                    if (!Array.isArray(message.freeLaneBoundaryId))
                        return "freeLaneBoundaryId: array expected";
                    for (let i = 0; i < message.freeLaneBoundaryId.length; ++i) {
                        let error = $root.osi3.Identifier.verify(message.freeLaneBoundaryId[i]);
                        if (error)
                            return "freeLaneBoundaryId." + error;
                    }
                }
                if (message.roadCondition != null && message.hasOwnProperty("roadCondition")) {
                    let error = $root.osi3.Lane.Classification.RoadCondition.verify(message.roadCondition);
                    if (error)
                        return "roadCondition." + error;
                }
                if (message.subtype != null && message.hasOwnProperty("subtype"))
                    switch (message.subtype) {
                    default:
                        return "subtype: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                    case 9:
                    case 10:
                    case 11:
                    case 12:
                    case 13:
                    case 14:
                        break;
                    }
                return null;
            };

            /**
             * Creates a Classification message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof osi3.Lane.Classification
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {osi3.Lane.Classification} Classification
             */
            Classification.fromObject = function fromObject(object) {
                if (object instanceof $root.osi3.Lane.Classification)
                    return object;
                let message = new $root.osi3.Lane.Classification();
                switch (object.type) {
                default:
                    if (typeof object.type === "number") {
                        message.type = object.type;
                        break;
                    }
                    break;
                case "TYPE_UNKNOWN":
                case 0:
                    message.type = 0;
                    break;
                case "TYPE_OTHER":
                case 1:
                    message.type = 1;
                    break;
                case "TYPE_DRIVING":
                case 2:
                    message.type = 2;
                    break;
                case "TYPE_NONDRIVING":
                case 3:
                    message.type = 3;
                    break;
                case "TYPE_INTERSECTION":
                case 4:
                    message.type = 4;
                    break;
                }
                if (object.isHostVehicleLane != null)
                    message.isHostVehicleLane = Boolean(object.isHostVehicleLane);
                if (object.centerline) {
                    if (!Array.isArray(object.centerline))
                        throw TypeError(".osi3.Lane.Classification.centerline: array expected");
                    message.centerline = [];
                    for (let i = 0; i < object.centerline.length; ++i) {
                        if (typeof object.centerline[i] !== "object")
                            throw TypeError(".osi3.Lane.Classification.centerline: object expected");
                        message.centerline[i] = $root.osi3.Vector3d.fromObject(object.centerline[i]);
                    }
                }
                if (object.centerlineIsDrivingDirection != null)
                    message.centerlineIsDrivingDirection = Boolean(object.centerlineIsDrivingDirection);
                if (object.leftAdjacentLaneId) {
                    if (!Array.isArray(object.leftAdjacentLaneId))
                        throw TypeError(".osi3.Lane.Classification.leftAdjacentLaneId: array expected");
                    message.leftAdjacentLaneId = [];
                    for (let i = 0; i < object.leftAdjacentLaneId.length; ++i) {
                        if (typeof object.leftAdjacentLaneId[i] !== "object")
                            throw TypeError(".osi3.Lane.Classification.leftAdjacentLaneId: object expected");
                        message.leftAdjacentLaneId[i] = $root.osi3.Identifier.fromObject(object.leftAdjacentLaneId[i]);
                    }
                }
                if (object.rightAdjacentLaneId) {
                    if (!Array.isArray(object.rightAdjacentLaneId))
                        throw TypeError(".osi3.Lane.Classification.rightAdjacentLaneId: array expected");
                    message.rightAdjacentLaneId = [];
                    for (let i = 0; i < object.rightAdjacentLaneId.length; ++i) {
                        if (typeof object.rightAdjacentLaneId[i] !== "object")
                            throw TypeError(".osi3.Lane.Classification.rightAdjacentLaneId: object expected");
                        message.rightAdjacentLaneId[i] = $root.osi3.Identifier.fromObject(object.rightAdjacentLaneId[i]);
                    }
                }
                if (object.lanePairing) {
                    if (!Array.isArray(object.lanePairing))
                        throw TypeError(".osi3.Lane.Classification.lanePairing: array expected");
                    message.lanePairing = [];
                    for (let i = 0; i < object.lanePairing.length; ++i) {
                        if (typeof object.lanePairing[i] !== "object")
                            throw TypeError(".osi3.Lane.Classification.lanePairing: object expected");
                        message.lanePairing[i] = $root.osi3.Lane.Classification.LanePairing.fromObject(object.lanePairing[i]);
                    }
                }
                if (object.rightLaneBoundaryId) {
                    if (!Array.isArray(object.rightLaneBoundaryId))
                        throw TypeError(".osi3.Lane.Classification.rightLaneBoundaryId: array expected");
                    message.rightLaneBoundaryId = [];
                    for (let i = 0; i < object.rightLaneBoundaryId.length; ++i) {
                        if (typeof object.rightLaneBoundaryId[i] !== "object")
                            throw TypeError(".osi3.Lane.Classification.rightLaneBoundaryId: object expected");
                        message.rightLaneBoundaryId[i] = $root.osi3.Identifier.fromObject(object.rightLaneBoundaryId[i]);
                    }
                }
                if (object.leftLaneBoundaryId) {
                    if (!Array.isArray(object.leftLaneBoundaryId))
                        throw TypeError(".osi3.Lane.Classification.leftLaneBoundaryId: array expected");
                    message.leftLaneBoundaryId = [];
                    for (let i = 0; i < object.leftLaneBoundaryId.length; ++i) {
                        if (typeof object.leftLaneBoundaryId[i] !== "object")
                            throw TypeError(".osi3.Lane.Classification.leftLaneBoundaryId: object expected");
                        message.leftLaneBoundaryId[i] = $root.osi3.Identifier.fromObject(object.leftLaneBoundaryId[i]);
                    }
                }
                if (object.freeLaneBoundaryId) {
                    if (!Array.isArray(object.freeLaneBoundaryId))
                        throw TypeError(".osi3.Lane.Classification.freeLaneBoundaryId: array expected");
                    message.freeLaneBoundaryId = [];
                    for (let i = 0; i < object.freeLaneBoundaryId.length; ++i) {
                        if (typeof object.freeLaneBoundaryId[i] !== "object")
                            throw TypeError(".osi3.Lane.Classification.freeLaneBoundaryId: object expected");
                        message.freeLaneBoundaryId[i] = $root.osi3.Identifier.fromObject(object.freeLaneBoundaryId[i]);
                    }
                }
                if (object.roadCondition != null) {
                    if (typeof object.roadCondition !== "object")
                        throw TypeError(".osi3.Lane.Classification.roadCondition: object expected");
                    message.roadCondition = $root.osi3.Lane.Classification.RoadCondition.fromObject(object.roadCondition);
                }
                switch (object.subtype) {
                default:
                    if (typeof object.subtype === "number") {
                        message.subtype = object.subtype;
                        break;
                    }
                    break;
                case "SUBTYPE_UNKNOWN":
                case 0:
                    message.subtype = 0;
                    break;
                case "SUBTYPE_OTHER":
                case 1:
                    message.subtype = 1;
                    break;
                case "SUBTYPE_NORMAL":
                case 2:
                    message.subtype = 2;
                    break;
                case "SUBTYPE_BIKING":
                case 3:
                    message.subtype = 3;
                    break;
                case "SUBTYPE_SIDEWALK":
                case 4:
                    message.subtype = 4;
                    break;
                case "SUBTYPE_PARKING":
                case 5:
                    message.subtype = 5;
                    break;
                case "SUBTYPE_STOP":
                case 6:
                    message.subtype = 6;
                    break;
                case "SUBTYPE_RESTRICTED":
                case 7:
                    message.subtype = 7;
                    break;
                case "SUBTYPE_BORDER":
                case 8:
                    message.subtype = 8;
                    break;
                case "SUBTYPE_SHOULDER":
                case 9:
                    message.subtype = 9;
                    break;
                case "SUBTYPE_EXIT":
                case 10:
                    message.subtype = 10;
                    break;
                case "SUBTYPE_ENTRY":
                case 11:
                    message.subtype = 11;
                    break;
                case "SUBTYPE_ONRAMP":
                case 12:
                    message.subtype = 12;
                    break;
                case "SUBTYPE_OFFRAMP":
                case 13:
                    message.subtype = 13;
                    break;
                case "SUBTYPE_CONNECTINGRAMP":
                case 14:
                    message.subtype = 14;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from a Classification message. Also converts values to other types if specified.
             * @function toObject
             * @memberof osi3.Lane.Classification
             * @static
             * @param {osi3.Lane.Classification} message Classification
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Classification.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults) {
                    object.centerline = [];
                    object.leftAdjacentLaneId = [];
                    object.rightAdjacentLaneId = [];
                    object.lanePairing = [];
                    object.rightLaneBoundaryId = [];
                    object.leftLaneBoundaryId = [];
                    object.freeLaneBoundaryId = [];
                }
                if (options.defaults) {
                    object.type = options.enums === String ? "TYPE_UNKNOWN" : 0;
                    object.isHostVehicleLane = false;
                    object.centerlineIsDrivingDirection = false;
                    object.roadCondition = null;
                    object.subtype = options.enums === String ? "SUBTYPE_UNKNOWN" : 0;
                }
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.osi3.Lane.Classification.Type[message.type] === undefined ? message.type : $root.osi3.Lane.Classification.Type[message.type] : message.type;
                if (message.isHostVehicleLane != null && message.hasOwnProperty("isHostVehicleLane"))
                    object.isHostVehicleLane = message.isHostVehicleLane;
                if (message.centerline && message.centerline.length) {
                    object.centerline = [];
                    for (let j = 0; j < message.centerline.length; ++j)
                        object.centerline[j] = $root.osi3.Vector3d.toObject(message.centerline[j], options);
                }
                if (message.centerlineIsDrivingDirection != null && message.hasOwnProperty("centerlineIsDrivingDirection"))
                    object.centerlineIsDrivingDirection = message.centerlineIsDrivingDirection;
                if (message.leftAdjacentLaneId && message.leftAdjacentLaneId.length) {
                    object.leftAdjacentLaneId = [];
                    for (let j = 0; j < message.leftAdjacentLaneId.length; ++j)
                        object.leftAdjacentLaneId[j] = $root.osi3.Identifier.toObject(message.leftAdjacentLaneId[j], options);
                }
                if (message.rightAdjacentLaneId && message.rightAdjacentLaneId.length) {
                    object.rightAdjacentLaneId = [];
                    for (let j = 0; j < message.rightAdjacentLaneId.length; ++j)
                        object.rightAdjacentLaneId[j] = $root.osi3.Identifier.toObject(message.rightAdjacentLaneId[j], options);
                }
                if (message.lanePairing && message.lanePairing.length) {
                    object.lanePairing = [];
                    for (let j = 0; j < message.lanePairing.length; ++j)
                        object.lanePairing[j] = $root.osi3.Lane.Classification.LanePairing.toObject(message.lanePairing[j], options);
                }
                if (message.rightLaneBoundaryId && message.rightLaneBoundaryId.length) {
                    object.rightLaneBoundaryId = [];
                    for (let j = 0; j < message.rightLaneBoundaryId.length; ++j)
                        object.rightLaneBoundaryId[j] = $root.osi3.Identifier.toObject(message.rightLaneBoundaryId[j], options);
                }
                if (message.leftLaneBoundaryId && message.leftLaneBoundaryId.length) {
                    object.leftLaneBoundaryId = [];
                    for (let j = 0; j < message.leftLaneBoundaryId.length; ++j)
                        object.leftLaneBoundaryId[j] = $root.osi3.Identifier.toObject(message.leftLaneBoundaryId[j], options);
                }
                if (message.freeLaneBoundaryId && message.freeLaneBoundaryId.length) {
                    object.freeLaneBoundaryId = [];
                    for (let j = 0; j < message.freeLaneBoundaryId.length; ++j)
                        object.freeLaneBoundaryId[j] = $root.osi3.Identifier.toObject(message.freeLaneBoundaryId[j], options);
                }
                if (message.roadCondition != null && message.hasOwnProperty("roadCondition"))
                    object.roadCondition = $root.osi3.Lane.Classification.RoadCondition.toObject(message.roadCondition, options);
                if (message.subtype != null && message.hasOwnProperty("subtype"))
                    object.subtype = options.enums === String ? $root.osi3.Lane.Classification.Subtype[message.subtype] === undefined ? message.subtype : $root.osi3.Lane.Classification.Subtype[message.subtype] : message.subtype;
                return object;
            };

            /**
             * Converts this Classification to JSON.
             * @function toJSON
             * @memberof osi3.Lane.Classification
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Classification.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Classification
             * @function getTypeUrl
             * @memberof osi3.Lane.Classification
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Classification.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/osi3.Lane.Classification";
            };

            /**
             * Type enum.
             * @name osi3.Lane.Classification.Type
             * @enum {number}
             * @property {number} TYPE_UNKNOWN=0 TYPE_UNKNOWN value
             * @property {number} TYPE_OTHER=1 TYPE_OTHER value
             * @property {number} TYPE_DRIVING=2 TYPE_DRIVING value
             * @property {number} TYPE_NONDRIVING=3 TYPE_NONDRIVING value
             * @property {number} TYPE_INTERSECTION=4 TYPE_INTERSECTION value
             */
            Classification.Type = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "TYPE_UNKNOWN"] = 0;
                values[valuesById[1] = "TYPE_OTHER"] = 1;
                values[valuesById[2] = "TYPE_DRIVING"] = 2;
                values[valuesById[3] = "TYPE_NONDRIVING"] = 3;
                values[valuesById[4] = "TYPE_INTERSECTION"] = 4;
                return values;
            })();

            /**
             * Subtype enum.
             * @name osi3.Lane.Classification.Subtype
             * @enum {number}
             * @property {number} SUBTYPE_UNKNOWN=0 SUBTYPE_UNKNOWN value
             * @property {number} SUBTYPE_OTHER=1 SUBTYPE_OTHER value
             * @property {number} SUBTYPE_NORMAL=2 SUBTYPE_NORMAL value
             * @property {number} SUBTYPE_BIKING=3 SUBTYPE_BIKING value
             * @property {number} SUBTYPE_SIDEWALK=4 SUBTYPE_SIDEWALK value
             * @property {number} SUBTYPE_PARKING=5 SUBTYPE_PARKING value
             * @property {number} SUBTYPE_STOP=6 SUBTYPE_STOP value
             * @property {number} SUBTYPE_RESTRICTED=7 SUBTYPE_RESTRICTED value
             * @property {number} SUBTYPE_BORDER=8 SUBTYPE_BORDER value
             * @property {number} SUBTYPE_SHOULDER=9 SUBTYPE_SHOULDER value
             * @property {number} SUBTYPE_EXIT=10 SUBTYPE_EXIT value
             * @property {number} SUBTYPE_ENTRY=11 SUBTYPE_ENTRY value
             * @property {number} SUBTYPE_ONRAMP=12 SUBTYPE_ONRAMP value
             * @property {number} SUBTYPE_OFFRAMP=13 SUBTYPE_OFFRAMP value
             * @property {number} SUBTYPE_CONNECTINGRAMP=14 SUBTYPE_CONNECTINGRAMP value
             */
            Classification.Subtype = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "SUBTYPE_UNKNOWN"] = 0;
                values[valuesById[1] = "SUBTYPE_OTHER"] = 1;
                values[valuesById[2] = "SUBTYPE_NORMAL"] = 2;
                values[valuesById[3] = "SUBTYPE_BIKING"] = 3;
                values[valuesById[4] = "SUBTYPE_SIDEWALK"] = 4;
                values[valuesById[5] = "SUBTYPE_PARKING"] = 5;
                values[valuesById[6] = "SUBTYPE_STOP"] = 6;
                values[valuesById[7] = "SUBTYPE_RESTRICTED"] = 7;
                values[valuesById[8] = "SUBTYPE_BORDER"] = 8;
                values[valuesById[9] = "SUBTYPE_SHOULDER"] = 9;
                values[valuesById[10] = "SUBTYPE_EXIT"] = 10;
                values[valuesById[11] = "SUBTYPE_ENTRY"] = 11;
                values[valuesById[12] = "SUBTYPE_ONRAMP"] = 12;
                values[valuesById[13] = "SUBTYPE_OFFRAMP"] = 13;
                values[valuesById[14] = "SUBTYPE_CONNECTINGRAMP"] = 14;
                return values;
            })();

            Classification.RoadCondition = (function() {

                /**
                 * Properties of a RoadCondition.
                 * @memberof osi3.Lane.Classification
                 * @interface IRoadCondition
                 * @property {number|null} [surfaceTemperature] RoadCondition surfaceTemperature
                 * @property {number|null} [surfaceWaterFilm] RoadCondition surfaceWaterFilm
                 * @property {number|null} [surfaceFreezingPoint] RoadCondition surfaceFreezingPoint
                 * @property {number|null} [surfaceIce] RoadCondition surfaceIce
                 * @property {number|null} [surfaceRoughness] RoadCondition surfaceRoughness
                 * @property {number|null} [surfaceTexture] RoadCondition surfaceTexture
                 */

                /**
                 * Constructs a new RoadCondition.
                 * @memberof osi3.Lane.Classification
                 * @classdesc Represents a RoadCondition.
                 * @implements IRoadCondition
                 * @constructor
                 * @param {osi3.Lane.Classification.IRoadCondition=} [properties] Properties to set
                 */
                function RoadCondition(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * RoadCondition surfaceTemperature.
                 * @member {number} surfaceTemperature
                 * @memberof osi3.Lane.Classification.RoadCondition
                 * @instance
                 */
                RoadCondition.prototype.surfaceTemperature = 0;

                /**
                 * RoadCondition surfaceWaterFilm.
                 * @member {number} surfaceWaterFilm
                 * @memberof osi3.Lane.Classification.RoadCondition
                 * @instance
                 */
                RoadCondition.prototype.surfaceWaterFilm = 0;

                /**
                 * RoadCondition surfaceFreezingPoint.
                 * @member {number} surfaceFreezingPoint
                 * @memberof osi3.Lane.Classification.RoadCondition
                 * @instance
                 */
                RoadCondition.prototype.surfaceFreezingPoint = 0;

                /**
                 * RoadCondition surfaceIce.
                 * @member {number} surfaceIce
                 * @memberof osi3.Lane.Classification.RoadCondition
                 * @instance
                 */
                RoadCondition.prototype.surfaceIce = 0;

                /**
                 * RoadCondition surfaceRoughness.
                 * @member {number} surfaceRoughness
                 * @memberof osi3.Lane.Classification.RoadCondition
                 * @instance
                 */
                RoadCondition.prototype.surfaceRoughness = 0;

                /**
                 * RoadCondition surfaceTexture.
                 * @member {number} surfaceTexture
                 * @memberof osi3.Lane.Classification.RoadCondition
                 * @instance
                 */
                RoadCondition.prototype.surfaceTexture = 0;

                /**
                 * Creates a new RoadCondition instance using the specified properties.
                 * @function create
                 * @memberof osi3.Lane.Classification.RoadCondition
                 * @static
                 * @param {osi3.Lane.Classification.IRoadCondition=} [properties] Properties to set
                 * @returns {osi3.Lane.Classification.RoadCondition} RoadCondition instance
                 */
                RoadCondition.create = function create(properties) {
                    return new RoadCondition(properties);
                };

                /**
                 * Encodes the specified RoadCondition message. Does not implicitly {@link osi3.Lane.Classification.RoadCondition.verify|verify} messages.
                 * @function encode
                 * @memberof osi3.Lane.Classification.RoadCondition
                 * @static
                 * @param {osi3.Lane.Classification.IRoadCondition} message RoadCondition message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                RoadCondition.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.surfaceTemperature != null && Object.hasOwnProperty.call(message, "surfaceTemperature"))
                        writer.uint32(/* id 1, wireType 1 =*/9).double(message.surfaceTemperature);
                    if (message.surfaceWaterFilm != null && Object.hasOwnProperty.call(message, "surfaceWaterFilm"))
                        writer.uint32(/* id 2, wireType 1 =*/17).double(message.surfaceWaterFilm);
                    if (message.surfaceFreezingPoint != null && Object.hasOwnProperty.call(message, "surfaceFreezingPoint"))
                        writer.uint32(/* id 3, wireType 1 =*/25).double(message.surfaceFreezingPoint);
                    if (message.surfaceIce != null && Object.hasOwnProperty.call(message, "surfaceIce"))
                        writer.uint32(/* id 4, wireType 1 =*/33).double(message.surfaceIce);
                    if (message.surfaceRoughness != null && Object.hasOwnProperty.call(message, "surfaceRoughness"))
                        writer.uint32(/* id 5, wireType 1 =*/41).double(message.surfaceRoughness);
                    if (message.surfaceTexture != null && Object.hasOwnProperty.call(message, "surfaceTexture"))
                        writer.uint32(/* id 6, wireType 1 =*/49).double(message.surfaceTexture);
                    return writer;
                };

                /**
                 * Encodes the specified RoadCondition message, length delimited. Does not implicitly {@link osi3.Lane.Classification.RoadCondition.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof osi3.Lane.Classification.RoadCondition
                 * @static
                 * @param {osi3.Lane.Classification.IRoadCondition} message RoadCondition message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                RoadCondition.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a RoadCondition message from the specified reader or buffer.
                 * @function decode
                 * @memberof osi3.Lane.Classification.RoadCondition
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {osi3.Lane.Classification.RoadCondition} RoadCondition
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                RoadCondition.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.osi3.Lane.Classification.RoadCondition();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                message.surfaceTemperature = reader.double();
                                break;
                            }
                        case 2: {
                                message.surfaceWaterFilm = reader.double();
                                break;
                            }
                        case 3: {
                                message.surfaceFreezingPoint = reader.double();
                                break;
                            }
                        case 4: {
                                message.surfaceIce = reader.double();
                                break;
                            }
                        case 5: {
                                message.surfaceRoughness = reader.double();
                                break;
                            }
                        case 6: {
                                message.surfaceTexture = reader.double();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a RoadCondition message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof osi3.Lane.Classification.RoadCondition
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {osi3.Lane.Classification.RoadCondition} RoadCondition
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                RoadCondition.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a RoadCondition message.
                 * @function verify
                 * @memberof osi3.Lane.Classification.RoadCondition
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                RoadCondition.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.surfaceTemperature != null && message.hasOwnProperty("surfaceTemperature"))
                        if (typeof message.surfaceTemperature !== "number")
                            return "surfaceTemperature: number expected";
                    if (message.surfaceWaterFilm != null && message.hasOwnProperty("surfaceWaterFilm"))
                        if (typeof message.surfaceWaterFilm !== "number")
                            return "surfaceWaterFilm: number expected";
                    if (message.surfaceFreezingPoint != null && message.hasOwnProperty("surfaceFreezingPoint"))
                        if (typeof message.surfaceFreezingPoint !== "number")
                            return "surfaceFreezingPoint: number expected";
                    if (message.surfaceIce != null && message.hasOwnProperty("surfaceIce"))
                        if (typeof message.surfaceIce !== "number")
                            return "surfaceIce: number expected";
                    if (message.surfaceRoughness != null && message.hasOwnProperty("surfaceRoughness"))
                        if (typeof message.surfaceRoughness !== "number")
                            return "surfaceRoughness: number expected";
                    if (message.surfaceTexture != null && message.hasOwnProperty("surfaceTexture"))
                        if (typeof message.surfaceTexture !== "number")
                            return "surfaceTexture: number expected";
                    return null;
                };

                /**
                 * Creates a RoadCondition message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof osi3.Lane.Classification.RoadCondition
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {osi3.Lane.Classification.RoadCondition} RoadCondition
                 */
                RoadCondition.fromObject = function fromObject(object) {
                    if (object instanceof $root.osi3.Lane.Classification.RoadCondition)
                        return object;
                    let message = new $root.osi3.Lane.Classification.RoadCondition();
                    if (object.surfaceTemperature != null)
                        message.surfaceTemperature = Number(object.surfaceTemperature);
                    if (object.surfaceWaterFilm != null)
                        message.surfaceWaterFilm = Number(object.surfaceWaterFilm);
                    if (object.surfaceFreezingPoint != null)
                        message.surfaceFreezingPoint = Number(object.surfaceFreezingPoint);
                    if (object.surfaceIce != null)
                        message.surfaceIce = Number(object.surfaceIce);
                    if (object.surfaceRoughness != null)
                        message.surfaceRoughness = Number(object.surfaceRoughness);
                    if (object.surfaceTexture != null)
                        message.surfaceTexture = Number(object.surfaceTexture);
                    return message;
                };

                /**
                 * Creates a plain object from a RoadCondition message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof osi3.Lane.Classification.RoadCondition
                 * @static
                 * @param {osi3.Lane.Classification.RoadCondition} message RoadCondition
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                RoadCondition.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.surfaceTemperature = 0;
                        object.surfaceWaterFilm = 0;
                        object.surfaceFreezingPoint = 0;
                        object.surfaceIce = 0;
                        object.surfaceRoughness = 0;
                        object.surfaceTexture = 0;
                    }
                    if (message.surfaceTemperature != null && message.hasOwnProperty("surfaceTemperature"))
                        object.surfaceTemperature = options.json && !isFinite(message.surfaceTemperature) ? String(message.surfaceTemperature) : message.surfaceTemperature;
                    if (message.surfaceWaterFilm != null && message.hasOwnProperty("surfaceWaterFilm"))
                        object.surfaceWaterFilm = options.json && !isFinite(message.surfaceWaterFilm) ? String(message.surfaceWaterFilm) : message.surfaceWaterFilm;
                    if (message.surfaceFreezingPoint != null && message.hasOwnProperty("surfaceFreezingPoint"))
                        object.surfaceFreezingPoint = options.json && !isFinite(message.surfaceFreezingPoint) ? String(message.surfaceFreezingPoint) : message.surfaceFreezingPoint;
                    if (message.surfaceIce != null && message.hasOwnProperty("surfaceIce"))
                        object.surfaceIce = options.json && !isFinite(message.surfaceIce) ? String(message.surfaceIce) : message.surfaceIce;
                    if (message.surfaceRoughness != null && message.hasOwnProperty("surfaceRoughness"))
                        object.surfaceRoughness = options.json && !isFinite(message.surfaceRoughness) ? String(message.surfaceRoughness) : message.surfaceRoughness;
                    if (message.surfaceTexture != null && message.hasOwnProperty("surfaceTexture"))
                        object.surfaceTexture = options.json && !isFinite(message.surfaceTexture) ? String(message.surfaceTexture) : message.surfaceTexture;
                    return object;
                };

                /**
                 * Converts this RoadCondition to JSON.
                 * @function toJSON
                 * @memberof osi3.Lane.Classification.RoadCondition
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                RoadCondition.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for RoadCondition
                 * @function getTypeUrl
                 * @memberof osi3.Lane.Classification.RoadCondition
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                RoadCondition.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/osi3.Lane.Classification.RoadCondition";
                };

                return RoadCondition;
            })();

            Classification.LanePairing = (function() {

                /**
                 * Properties of a LanePairing.
                 * @memberof osi3.Lane.Classification
                 * @interface ILanePairing
                 * @property {osi3.IIdentifier|null} [antecessorLaneId] LanePairing antecessorLaneId
                 * @property {osi3.IIdentifier|null} [successorLaneId] LanePairing successorLaneId
                 */

                /**
                 * Constructs a new LanePairing.
                 * @memberof osi3.Lane.Classification
                 * @classdesc Represents a LanePairing.
                 * @implements ILanePairing
                 * @constructor
                 * @param {osi3.Lane.Classification.ILanePairing=} [properties] Properties to set
                 */
                function LanePairing(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * LanePairing antecessorLaneId.
                 * @member {osi3.IIdentifier|null|undefined} antecessorLaneId
                 * @memberof osi3.Lane.Classification.LanePairing
                 * @instance
                 */
                LanePairing.prototype.antecessorLaneId = null;

                /**
                 * LanePairing successorLaneId.
                 * @member {osi3.IIdentifier|null|undefined} successorLaneId
                 * @memberof osi3.Lane.Classification.LanePairing
                 * @instance
                 */
                LanePairing.prototype.successorLaneId = null;

                /**
                 * Creates a new LanePairing instance using the specified properties.
                 * @function create
                 * @memberof osi3.Lane.Classification.LanePairing
                 * @static
                 * @param {osi3.Lane.Classification.ILanePairing=} [properties] Properties to set
                 * @returns {osi3.Lane.Classification.LanePairing} LanePairing instance
                 */
                LanePairing.create = function create(properties) {
                    return new LanePairing(properties);
                };

                /**
                 * Encodes the specified LanePairing message. Does not implicitly {@link osi3.Lane.Classification.LanePairing.verify|verify} messages.
                 * @function encode
                 * @memberof osi3.Lane.Classification.LanePairing
                 * @static
                 * @param {osi3.Lane.Classification.ILanePairing} message LanePairing message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                LanePairing.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.antecessorLaneId != null && Object.hasOwnProperty.call(message, "antecessorLaneId"))
                        $root.osi3.Identifier.encode(message.antecessorLaneId, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.successorLaneId != null && Object.hasOwnProperty.call(message, "successorLaneId"))
                        $root.osi3.Identifier.encode(message.successorLaneId, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified LanePairing message, length delimited. Does not implicitly {@link osi3.Lane.Classification.LanePairing.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof osi3.Lane.Classification.LanePairing
                 * @static
                 * @param {osi3.Lane.Classification.ILanePairing} message LanePairing message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                LanePairing.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a LanePairing message from the specified reader or buffer.
                 * @function decode
                 * @memberof osi3.Lane.Classification.LanePairing
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {osi3.Lane.Classification.LanePairing} LanePairing
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                LanePairing.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.osi3.Lane.Classification.LanePairing();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                message.antecessorLaneId = $root.osi3.Identifier.decode(reader, reader.uint32());
                                break;
                            }
                        case 2: {
                                message.successorLaneId = $root.osi3.Identifier.decode(reader, reader.uint32());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a LanePairing message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof osi3.Lane.Classification.LanePairing
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {osi3.Lane.Classification.LanePairing} LanePairing
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                LanePairing.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a LanePairing message.
                 * @function verify
                 * @memberof osi3.Lane.Classification.LanePairing
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                LanePairing.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.antecessorLaneId != null && message.hasOwnProperty("antecessorLaneId")) {
                        let error = $root.osi3.Identifier.verify(message.antecessorLaneId);
                        if (error)
                            return "antecessorLaneId." + error;
                    }
                    if (message.successorLaneId != null && message.hasOwnProperty("successorLaneId")) {
                        let error = $root.osi3.Identifier.verify(message.successorLaneId);
                        if (error)
                            return "successorLaneId." + error;
                    }
                    return null;
                };

                /**
                 * Creates a LanePairing message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof osi3.Lane.Classification.LanePairing
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {osi3.Lane.Classification.LanePairing} LanePairing
                 */
                LanePairing.fromObject = function fromObject(object) {
                    if (object instanceof $root.osi3.Lane.Classification.LanePairing)
                        return object;
                    let message = new $root.osi3.Lane.Classification.LanePairing();
                    if (object.antecessorLaneId != null) {
                        if (typeof object.antecessorLaneId !== "object")
                            throw TypeError(".osi3.Lane.Classification.LanePairing.antecessorLaneId: object expected");
                        message.antecessorLaneId = $root.osi3.Identifier.fromObject(object.antecessorLaneId);
                    }
                    if (object.successorLaneId != null) {
                        if (typeof object.successorLaneId !== "object")
                            throw TypeError(".osi3.Lane.Classification.LanePairing.successorLaneId: object expected");
                        message.successorLaneId = $root.osi3.Identifier.fromObject(object.successorLaneId);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a LanePairing message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof osi3.Lane.Classification.LanePairing
                 * @static
                 * @param {osi3.Lane.Classification.LanePairing} message LanePairing
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                LanePairing.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.antecessorLaneId = null;
                        object.successorLaneId = null;
                    }
                    if (message.antecessorLaneId != null && message.hasOwnProperty("antecessorLaneId"))
                        object.antecessorLaneId = $root.osi3.Identifier.toObject(message.antecessorLaneId, options);
                    if (message.successorLaneId != null && message.hasOwnProperty("successorLaneId"))
                        object.successorLaneId = $root.osi3.Identifier.toObject(message.successorLaneId, options);
                    return object;
                };

                /**
                 * Converts this LanePairing to JSON.
                 * @function toJSON
                 * @memberof osi3.Lane.Classification.LanePairing
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                LanePairing.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for LanePairing
                 * @function getTypeUrl
                 * @memberof osi3.Lane.Classification.LanePairing
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                LanePairing.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/osi3.Lane.Classification.LanePairing";
                };

                return LanePairing;
            })();

            return Classification;
        })();

        return Lane;
    })();

    osi3.LaneBoundary = (function() {

        /**
         * Properties of a LaneBoundary.
         * @memberof osi3
         * @interface ILaneBoundary
         * @property {osi3.IIdentifier|null} [id] LaneBoundary id
         * @property {Array.<osi3.LaneBoundary.IBoundaryPoint>|null} [boundaryLine] LaneBoundary boundaryLine
         * @property {osi3.LaneBoundary.IClassification|null} [classification] LaneBoundary classification
         * @property {Array.<osi3.IExternalReference>|null} [sourceReference] LaneBoundary sourceReference
         * @property {osi3.IColorDescription|null} [colorDescription] LaneBoundary colorDescription
         */

        /**
         * Constructs a new LaneBoundary.
         * @memberof osi3
         * @classdesc Represents a LaneBoundary.
         * @implements ILaneBoundary
         * @constructor
         * @param {osi3.ILaneBoundary=} [properties] Properties to set
         */
        function LaneBoundary(properties) {
            this.boundaryLine = [];
            this.sourceReference = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LaneBoundary id.
         * @member {osi3.IIdentifier|null|undefined} id
         * @memberof osi3.LaneBoundary
         * @instance
         */
        LaneBoundary.prototype.id = null;

        /**
         * LaneBoundary boundaryLine.
         * @member {Array.<osi3.LaneBoundary.IBoundaryPoint>} boundaryLine
         * @memberof osi3.LaneBoundary
         * @instance
         */
        LaneBoundary.prototype.boundaryLine = $util.emptyArray;

        /**
         * LaneBoundary classification.
         * @member {osi3.LaneBoundary.IClassification|null|undefined} classification
         * @memberof osi3.LaneBoundary
         * @instance
         */
        LaneBoundary.prototype.classification = null;

        /**
         * LaneBoundary sourceReference.
         * @member {Array.<osi3.IExternalReference>} sourceReference
         * @memberof osi3.LaneBoundary
         * @instance
         */
        LaneBoundary.prototype.sourceReference = $util.emptyArray;

        /**
         * LaneBoundary colorDescription.
         * @member {osi3.IColorDescription|null|undefined} colorDescription
         * @memberof osi3.LaneBoundary
         * @instance
         */
        LaneBoundary.prototype.colorDescription = null;

        /**
         * Creates a new LaneBoundary instance using the specified properties.
         * @function create
         * @memberof osi3.LaneBoundary
         * @static
         * @param {osi3.ILaneBoundary=} [properties] Properties to set
         * @returns {osi3.LaneBoundary} LaneBoundary instance
         */
        LaneBoundary.create = function create(properties) {
            return new LaneBoundary(properties);
        };

        /**
         * Encodes the specified LaneBoundary message. Does not implicitly {@link osi3.LaneBoundary.verify|verify} messages.
         * @function encode
         * @memberof osi3.LaneBoundary
         * @static
         * @param {osi3.ILaneBoundary} message LaneBoundary message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LaneBoundary.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                $root.osi3.Identifier.encode(message.id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.boundaryLine != null && message.boundaryLine.length)
                for (let i = 0; i < message.boundaryLine.length; ++i)
                    $root.osi3.LaneBoundary.BoundaryPoint.encode(message.boundaryLine[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.classification != null && Object.hasOwnProperty.call(message, "classification"))
                $root.osi3.LaneBoundary.Classification.encode(message.classification, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.sourceReference != null && message.sourceReference.length)
                for (let i = 0; i < message.sourceReference.length; ++i)
                    $root.osi3.ExternalReference.encode(message.sourceReference[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.colorDescription != null && Object.hasOwnProperty.call(message, "colorDescription"))
                $root.osi3.ColorDescription.encode(message.colorDescription, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified LaneBoundary message, length delimited. Does not implicitly {@link osi3.LaneBoundary.verify|verify} messages.
         * @function encodeDelimited
         * @memberof osi3.LaneBoundary
         * @static
         * @param {osi3.ILaneBoundary} message LaneBoundary message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LaneBoundary.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LaneBoundary message from the specified reader or buffer.
         * @function decode
         * @memberof osi3.LaneBoundary
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {osi3.LaneBoundary} LaneBoundary
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LaneBoundary.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.osi3.LaneBoundary();
            while (reader.pos < end) {
                let tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.id = $root.osi3.Identifier.decode(reader, reader.uint32());
                        break;
                    }
                case 2: {
                        if (!(message.boundaryLine && message.boundaryLine.length))
                            message.boundaryLine = [];
                        message.boundaryLine.push($root.osi3.LaneBoundary.BoundaryPoint.decode(reader, reader.uint32()));
                        break;
                    }
                case 3: {
                        message.classification = $root.osi3.LaneBoundary.Classification.decode(reader, reader.uint32());
                        break;
                    }
                case 4: {
                        if (!(message.sourceReference && message.sourceReference.length))
                            message.sourceReference = [];
                        message.sourceReference.push($root.osi3.ExternalReference.decode(reader, reader.uint32()));
                        break;
                    }
                case 5: {
                        message.colorDescription = $root.osi3.ColorDescription.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LaneBoundary message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof osi3.LaneBoundary
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {osi3.LaneBoundary} LaneBoundary
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LaneBoundary.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LaneBoundary message.
         * @function verify
         * @memberof osi3.LaneBoundary
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LaneBoundary.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id")) {
                let error = $root.osi3.Identifier.verify(message.id);
                if (error)
                    return "id." + error;
            }
            if (message.boundaryLine != null && message.hasOwnProperty("boundaryLine")) {
                if (!Array.isArray(message.boundaryLine))
                    return "boundaryLine: array expected";
                for (let i = 0; i < message.boundaryLine.length; ++i) {
                    let error = $root.osi3.LaneBoundary.BoundaryPoint.verify(message.boundaryLine[i]);
                    if (error)
                        return "boundaryLine." + error;
                }
            }
            if (message.classification != null && message.hasOwnProperty("classification")) {
                let error = $root.osi3.LaneBoundary.Classification.verify(message.classification);
                if (error)
                    return "classification." + error;
            }
            if (message.sourceReference != null && message.hasOwnProperty("sourceReference")) {
                if (!Array.isArray(message.sourceReference))
                    return "sourceReference: array expected";
                for (let i = 0; i < message.sourceReference.length; ++i) {
                    let error = $root.osi3.ExternalReference.verify(message.sourceReference[i]);
                    if (error)
                        return "sourceReference." + error;
                }
            }
            if (message.colorDescription != null && message.hasOwnProperty("colorDescription")) {
                let error = $root.osi3.ColorDescription.verify(message.colorDescription);
                if (error)
                    return "colorDescription." + error;
            }
            return null;
        };

        /**
         * Creates a LaneBoundary message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof osi3.LaneBoundary
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {osi3.LaneBoundary} LaneBoundary
         */
        LaneBoundary.fromObject = function fromObject(object) {
            if (object instanceof $root.osi3.LaneBoundary)
                return object;
            let message = new $root.osi3.LaneBoundary();
            if (object.id != null) {
                if (typeof object.id !== "object")
                    throw TypeError(".osi3.LaneBoundary.id: object expected");
                message.id = $root.osi3.Identifier.fromObject(object.id);
            }
            if (object.boundaryLine) {
                if (!Array.isArray(object.boundaryLine))
                    throw TypeError(".osi3.LaneBoundary.boundaryLine: array expected");
                message.boundaryLine = [];
                for (let i = 0; i < object.boundaryLine.length; ++i) {
                    if (typeof object.boundaryLine[i] !== "object")
                        throw TypeError(".osi3.LaneBoundary.boundaryLine: object expected");
                    message.boundaryLine[i] = $root.osi3.LaneBoundary.BoundaryPoint.fromObject(object.boundaryLine[i]);
                }
            }
            if (object.classification != null) {
                if (typeof object.classification !== "object")
                    throw TypeError(".osi3.LaneBoundary.classification: object expected");
                message.classification = $root.osi3.LaneBoundary.Classification.fromObject(object.classification);
            }
            if (object.sourceReference) {
                if (!Array.isArray(object.sourceReference))
                    throw TypeError(".osi3.LaneBoundary.sourceReference: array expected");
                message.sourceReference = [];
                for (let i = 0; i < object.sourceReference.length; ++i) {
                    if (typeof object.sourceReference[i] !== "object")
                        throw TypeError(".osi3.LaneBoundary.sourceReference: object expected");
                    message.sourceReference[i] = $root.osi3.ExternalReference.fromObject(object.sourceReference[i]);
                }
            }
            if (object.colorDescription != null) {
                if (typeof object.colorDescription !== "object")
                    throw TypeError(".osi3.LaneBoundary.colorDescription: object expected");
                message.colorDescription = $root.osi3.ColorDescription.fromObject(object.colorDescription);
            }
            return message;
        };

        /**
         * Creates a plain object from a LaneBoundary message. Also converts values to other types if specified.
         * @function toObject
         * @memberof osi3.LaneBoundary
         * @static
         * @param {osi3.LaneBoundary} message LaneBoundary
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        LaneBoundary.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.boundaryLine = [];
                object.sourceReference = [];
            }
            if (options.defaults) {
                object.id = null;
                object.classification = null;
                object.colorDescription = null;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = $root.osi3.Identifier.toObject(message.id, options);
            if (message.boundaryLine && message.boundaryLine.length) {
                object.boundaryLine = [];
                for (let j = 0; j < message.boundaryLine.length; ++j)
                    object.boundaryLine[j] = $root.osi3.LaneBoundary.BoundaryPoint.toObject(message.boundaryLine[j], options);
            }
            if (message.classification != null && message.hasOwnProperty("classification"))
                object.classification = $root.osi3.LaneBoundary.Classification.toObject(message.classification, options);
            if (message.sourceReference && message.sourceReference.length) {
                object.sourceReference = [];
                for (let j = 0; j < message.sourceReference.length; ++j)
                    object.sourceReference[j] = $root.osi3.ExternalReference.toObject(message.sourceReference[j], options);
            }
            if (message.colorDescription != null && message.hasOwnProperty("colorDescription"))
                object.colorDescription = $root.osi3.ColorDescription.toObject(message.colorDescription, options);
            return object;
        };

        /**
         * Converts this LaneBoundary to JSON.
         * @function toJSON
         * @memberof osi3.LaneBoundary
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        LaneBoundary.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for LaneBoundary
         * @function getTypeUrl
         * @memberof osi3.LaneBoundary
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        LaneBoundary.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/osi3.LaneBoundary";
        };

        LaneBoundary.BoundaryPoint = (function() {

            /**
             * Properties of a BoundaryPoint.
             * @memberof osi3.LaneBoundary
             * @interface IBoundaryPoint
             * @property {osi3.IVector3d|null} [position] BoundaryPoint position
             * @property {number|null} [width] BoundaryPoint width
             * @property {number|null} [height] BoundaryPoint height
             * @property {osi3.LaneBoundary.BoundaryPoint.Dash|null} [dash] BoundaryPoint dash
             */

            /**
             * Constructs a new BoundaryPoint.
             * @memberof osi3.LaneBoundary
             * @classdesc Represents a BoundaryPoint.
             * @implements IBoundaryPoint
             * @constructor
             * @param {osi3.LaneBoundary.IBoundaryPoint=} [properties] Properties to set
             */
            function BoundaryPoint(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BoundaryPoint position.
             * @member {osi3.IVector3d|null|undefined} position
             * @memberof osi3.LaneBoundary.BoundaryPoint
             * @instance
             */
            BoundaryPoint.prototype.position = null;

            /**
             * BoundaryPoint width.
             * @member {number} width
             * @memberof osi3.LaneBoundary.BoundaryPoint
             * @instance
             */
            BoundaryPoint.prototype.width = 0;

            /**
             * BoundaryPoint height.
             * @member {number} height
             * @memberof osi3.LaneBoundary.BoundaryPoint
             * @instance
             */
            BoundaryPoint.prototype.height = 0;

            /**
             * BoundaryPoint dash.
             * @member {osi3.LaneBoundary.BoundaryPoint.Dash} dash
             * @memberof osi3.LaneBoundary.BoundaryPoint
             * @instance
             */
            BoundaryPoint.prototype.dash = 0;

            /**
             * Creates a new BoundaryPoint instance using the specified properties.
             * @function create
             * @memberof osi3.LaneBoundary.BoundaryPoint
             * @static
             * @param {osi3.LaneBoundary.IBoundaryPoint=} [properties] Properties to set
             * @returns {osi3.LaneBoundary.BoundaryPoint} BoundaryPoint instance
             */
            BoundaryPoint.create = function create(properties) {
                return new BoundaryPoint(properties);
            };

            /**
             * Encodes the specified BoundaryPoint message. Does not implicitly {@link osi3.LaneBoundary.BoundaryPoint.verify|verify} messages.
             * @function encode
             * @memberof osi3.LaneBoundary.BoundaryPoint
             * @static
             * @param {osi3.LaneBoundary.IBoundaryPoint} message BoundaryPoint message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BoundaryPoint.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.position != null && Object.hasOwnProperty.call(message, "position"))
                    $root.osi3.Vector3d.encode(message.position, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.width != null && Object.hasOwnProperty.call(message, "width"))
                    writer.uint32(/* id 2, wireType 1 =*/17).double(message.width);
                if (message.height != null && Object.hasOwnProperty.call(message, "height"))
                    writer.uint32(/* id 3, wireType 1 =*/25).double(message.height);
                if (message.dash != null && Object.hasOwnProperty.call(message, "dash"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.dash);
                return writer;
            };

            /**
             * Encodes the specified BoundaryPoint message, length delimited. Does not implicitly {@link osi3.LaneBoundary.BoundaryPoint.verify|verify} messages.
             * @function encodeDelimited
             * @memberof osi3.LaneBoundary.BoundaryPoint
             * @static
             * @param {osi3.LaneBoundary.IBoundaryPoint} message BoundaryPoint message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BoundaryPoint.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BoundaryPoint message from the specified reader or buffer.
             * @function decode
             * @memberof osi3.LaneBoundary.BoundaryPoint
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {osi3.LaneBoundary.BoundaryPoint} BoundaryPoint
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BoundaryPoint.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.osi3.LaneBoundary.BoundaryPoint();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.position = $root.osi3.Vector3d.decode(reader, reader.uint32());
                            break;
                        }
                    case 2: {
                            message.width = reader.double();
                            break;
                        }
                    case 3: {
                            message.height = reader.double();
                            break;
                        }
                    case 4: {
                            message.dash = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a BoundaryPoint message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof osi3.LaneBoundary.BoundaryPoint
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {osi3.LaneBoundary.BoundaryPoint} BoundaryPoint
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BoundaryPoint.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BoundaryPoint message.
             * @function verify
             * @memberof osi3.LaneBoundary.BoundaryPoint
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BoundaryPoint.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.position != null && message.hasOwnProperty("position")) {
                    let error = $root.osi3.Vector3d.verify(message.position);
                    if (error)
                        return "position." + error;
                }
                if (message.width != null && message.hasOwnProperty("width"))
                    if (typeof message.width !== "number")
                        return "width: number expected";
                if (message.height != null && message.hasOwnProperty("height"))
                    if (typeof message.height !== "number")
                        return "height: number expected";
                if (message.dash != null && message.hasOwnProperty("dash"))
                    switch (message.dash) {
                    default:
                        return "dash: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                        break;
                    }
                return null;
            };

            /**
             * Creates a BoundaryPoint message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof osi3.LaneBoundary.BoundaryPoint
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {osi3.LaneBoundary.BoundaryPoint} BoundaryPoint
             */
            BoundaryPoint.fromObject = function fromObject(object) {
                if (object instanceof $root.osi3.LaneBoundary.BoundaryPoint)
                    return object;
                let message = new $root.osi3.LaneBoundary.BoundaryPoint();
                if (object.position != null) {
                    if (typeof object.position !== "object")
                        throw TypeError(".osi3.LaneBoundary.BoundaryPoint.position: object expected");
                    message.position = $root.osi3.Vector3d.fromObject(object.position);
                }
                if (object.width != null)
                    message.width = Number(object.width);
                if (object.height != null)
                    message.height = Number(object.height);
                switch (object.dash) {
                default:
                    if (typeof object.dash === "number") {
                        message.dash = object.dash;
                        break;
                    }
                    break;
                case "DASH_UNKNOWN":
                case 0:
                    message.dash = 0;
                    break;
                case "DASH_OTHER":
                case 1:
                    message.dash = 1;
                    break;
                case "DASH_START":
                case 2:
                    message.dash = 2;
                    break;
                case "DASH_CONTINUE":
                case 3:
                    message.dash = 3;
                    break;
                case "DASH_END":
                case 4:
                    message.dash = 4;
                    break;
                case "DASH_GAP":
                case 5:
                    message.dash = 5;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from a BoundaryPoint message. Also converts values to other types if specified.
             * @function toObject
             * @memberof osi3.LaneBoundary.BoundaryPoint
             * @static
             * @param {osi3.LaneBoundary.BoundaryPoint} message BoundaryPoint
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BoundaryPoint.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.position = null;
                    object.width = 0;
                    object.height = 0;
                    object.dash = options.enums === String ? "DASH_UNKNOWN" : 0;
                }
                if (message.position != null && message.hasOwnProperty("position"))
                    object.position = $root.osi3.Vector3d.toObject(message.position, options);
                if (message.width != null && message.hasOwnProperty("width"))
                    object.width = options.json && !isFinite(message.width) ? String(message.width) : message.width;
                if (message.height != null && message.hasOwnProperty("height"))
                    object.height = options.json && !isFinite(message.height) ? String(message.height) : message.height;
                if (message.dash != null && message.hasOwnProperty("dash"))
                    object.dash = options.enums === String ? $root.osi3.LaneBoundary.BoundaryPoint.Dash[message.dash] === undefined ? message.dash : $root.osi3.LaneBoundary.BoundaryPoint.Dash[message.dash] : message.dash;
                return object;
            };

            /**
             * Converts this BoundaryPoint to JSON.
             * @function toJSON
             * @memberof osi3.LaneBoundary.BoundaryPoint
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BoundaryPoint.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for BoundaryPoint
             * @function getTypeUrl
             * @memberof osi3.LaneBoundary.BoundaryPoint
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            BoundaryPoint.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/osi3.LaneBoundary.BoundaryPoint";
            };

            /**
             * Dash enum.
             * @name osi3.LaneBoundary.BoundaryPoint.Dash
             * @enum {number}
             * @property {number} DASH_UNKNOWN=0 DASH_UNKNOWN value
             * @property {number} DASH_OTHER=1 DASH_OTHER value
             * @property {number} DASH_START=2 DASH_START value
             * @property {number} DASH_CONTINUE=3 DASH_CONTINUE value
             * @property {number} DASH_END=4 DASH_END value
             * @property {number} DASH_GAP=5 DASH_GAP value
             */
            BoundaryPoint.Dash = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "DASH_UNKNOWN"] = 0;
                values[valuesById[1] = "DASH_OTHER"] = 1;
                values[valuesById[2] = "DASH_START"] = 2;
                values[valuesById[3] = "DASH_CONTINUE"] = 3;
                values[valuesById[4] = "DASH_END"] = 4;
                values[valuesById[5] = "DASH_GAP"] = 5;
                return values;
            })();

            return BoundaryPoint;
        })();

        LaneBoundary.Classification = (function() {

            /**
             * Properties of a Classification.
             * @memberof osi3.LaneBoundary
             * @interface IClassification
             * @property {osi3.LaneBoundary.Classification.Type|null} [type] Classification type
             * @property {osi3.LaneBoundary.Classification.Color|null} [color] Classification color
             * @property {Array.<osi3.IIdentifier>|null} [limitingStructureId] Classification limitingStructureId
             */

            /**
             * Constructs a new Classification.
             * @memberof osi3.LaneBoundary
             * @classdesc Represents a Classification.
             * @implements IClassification
             * @constructor
             * @param {osi3.LaneBoundary.IClassification=} [properties] Properties to set
             */
            function Classification(properties) {
                this.limitingStructureId = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Classification type.
             * @member {osi3.LaneBoundary.Classification.Type} type
             * @memberof osi3.LaneBoundary.Classification
             * @instance
             */
            Classification.prototype.type = 0;

            /**
             * Classification color.
             * @member {osi3.LaneBoundary.Classification.Color} color
             * @memberof osi3.LaneBoundary.Classification
             * @instance
             */
            Classification.prototype.color = 0;

            /**
             * Classification limitingStructureId.
             * @member {Array.<osi3.IIdentifier>} limitingStructureId
             * @memberof osi3.LaneBoundary.Classification
             * @instance
             */
            Classification.prototype.limitingStructureId = $util.emptyArray;

            /**
             * Creates a new Classification instance using the specified properties.
             * @function create
             * @memberof osi3.LaneBoundary.Classification
             * @static
             * @param {osi3.LaneBoundary.IClassification=} [properties] Properties to set
             * @returns {osi3.LaneBoundary.Classification} Classification instance
             */
            Classification.create = function create(properties) {
                return new Classification(properties);
            };

            /**
             * Encodes the specified Classification message. Does not implicitly {@link osi3.LaneBoundary.Classification.verify|verify} messages.
             * @function encode
             * @memberof osi3.LaneBoundary.Classification
             * @static
             * @param {osi3.LaneBoundary.IClassification} message Classification message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Classification.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                if (message.color != null && Object.hasOwnProperty.call(message, "color"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.color);
                if (message.limitingStructureId != null && message.limitingStructureId.length)
                    for (let i = 0; i < message.limitingStructureId.length; ++i)
                        $root.osi3.Identifier.encode(message.limitingStructureId[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Classification message, length delimited. Does not implicitly {@link osi3.LaneBoundary.Classification.verify|verify} messages.
             * @function encodeDelimited
             * @memberof osi3.LaneBoundary.Classification
             * @static
             * @param {osi3.LaneBoundary.IClassification} message Classification message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Classification.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Classification message from the specified reader or buffer.
             * @function decode
             * @memberof osi3.LaneBoundary.Classification
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {osi3.LaneBoundary.Classification} Classification
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Classification.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.osi3.LaneBoundary.Classification();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.type = reader.int32();
                            break;
                        }
                    case 2: {
                            message.color = reader.int32();
                            break;
                        }
                    case 3: {
                            if (!(message.limitingStructureId && message.limitingStructureId.length))
                                message.limitingStructureId = [];
                            message.limitingStructureId.push($root.osi3.Identifier.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Classification message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof osi3.LaneBoundary.Classification
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {osi3.LaneBoundary.Classification} Classification
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Classification.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Classification message.
             * @function verify
             * @memberof osi3.LaneBoundary.Classification
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Classification.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                    case 9:
                    case 10:
                    case 11:
                    case 12:
                    case 13:
                    case 14:
                    case 15:
                        break;
                    }
                if (message.color != null && message.hasOwnProperty("color"))
                    switch (message.color) {
                    default:
                        return "color: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                    case 9:
                        break;
                    }
                if (message.limitingStructureId != null && message.hasOwnProperty("limitingStructureId")) {
                    if (!Array.isArray(message.limitingStructureId))
                        return "limitingStructureId: array expected";
                    for (let i = 0; i < message.limitingStructureId.length; ++i) {
                        let error = $root.osi3.Identifier.verify(message.limitingStructureId[i]);
                        if (error)
                            return "limitingStructureId." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a Classification message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof osi3.LaneBoundary.Classification
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {osi3.LaneBoundary.Classification} Classification
             */
            Classification.fromObject = function fromObject(object) {
                if (object instanceof $root.osi3.LaneBoundary.Classification)
                    return object;
                let message = new $root.osi3.LaneBoundary.Classification();
                switch (object.type) {
                default:
                    if (typeof object.type === "number") {
                        message.type = object.type;
                        break;
                    }
                    break;
                case "TYPE_UNKNOWN":
                case 0:
                    message.type = 0;
                    break;
                case "TYPE_OTHER":
                case 1:
                    message.type = 1;
                    break;
                case "TYPE_NO_LINE":
                case 2:
                    message.type = 2;
                    break;
                case "TYPE_SOLID_LINE":
                case 3:
                    message.type = 3;
                    break;
                case "TYPE_DASHED_LINE":
                case 4:
                    message.type = 4;
                    break;
                case "TYPE_BOTTS_DOTS":
                case 5:
                    message.type = 5;
                    break;
                case "TYPE_ROAD_EDGE":
                case 6:
                    message.type = 6;
                    break;
                case "TYPE_SNOW_EDGE":
                case 7:
                    message.type = 7;
                    break;
                case "TYPE_GRASS_EDGE":
                case 8:
                    message.type = 8;
                    break;
                case "TYPE_GRAVEL_EDGE":
                case 9:
                    message.type = 9;
                    break;
                case "TYPE_SOIL_EDGE":
                case 10:
                    message.type = 10;
                    break;
                case "TYPE_GUARD_RAIL":
                case 11:
                    message.type = 11;
                    break;
                case "TYPE_CURB":
                case 12:
                    message.type = 12;
                    break;
                case "TYPE_STRUCTURE":
                case 13:
                    message.type = 13;
                    break;
                case "TYPE_BARRIER":
                case 14:
                    message.type = 14;
                    break;
                case "TYPE_SOUND_BARRIER":
                case 15:
                    message.type = 15;
                    break;
                }
                switch (object.color) {
                default:
                    if (typeof object.color === "number") {
                        message.color = object.color;
                        break;
                    }
                    break;
                case "COLOR_UNKNOWN":
                case 0:
                    message.color = 0;
                    break;
                case "COLOR_OTHER":
                case 1:
                    message.color = 1;
                    break;
                case "COLOR_NONE":
                case 2:
                    message.color = 2;
                    break;
                case "COLOR_WHITE":
                case 3:
                    message.color = 3;
                    break;
                case "COLOR_YELLOW":
                case 4:
                    message.color = 4;
                    break;
                case "COLOR_RED":
                case 5:
                    message.color = 5;
                    break;
                case "COLOR_BLUE":
                case 6:
                    message.color = 6;
                    break;
                case "COLOR_GREEN":
                case 7:
                    message.color = 7;
                    break;
                case "COLOR_VIOLET":
                case 8:
                    message.color = 8;
                    break;
                case "COLOR_ORANGE":
                case 9:
                    message.color = 9;
                    break;
                }
                if (object.limitingStructureId) {
                    if (!Array.isArray(object.limitingStructureId))
                        throw TypeError(".osi3.LaneBoundary.Classification.limitingStructureId: array expected");
                    message.limitingStructureId = [];
                    for (let i = 0; i < object.limitingStructureId.length; ++i) {
                        if (typeof object.limitingStructureId[i] !== "object")
                            throw TypeError(".osi3.LaneBoundary.Classification.limitingStructureId: object expected");
                        message.limitingStructureId[i] = $root.osi3.Identifier.fromObject(object.limitingStructureId[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a Classification message. Also converts values to other types if specified.
             * @function toObject
             * @memberof osi3.LaneBoundary.Classification
             * @static
             * @param {osi3.LaneBoundary.Classification} message Classification
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Classification.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.limitingStructureId = [];
                if (options.defaults) {
                    object.type = options.enums === String ? "TYPE_UNKNOWN" : 0;
                    object.color = options.enums === String ? "COLOR_UNKNOWN" : 0;
                }
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.osi3.LaneBoundary.Classification.Type[message.type] === undefined ? message.type : $root.osi3.LaneBoundary.Classification.Type[message.type] : message.type;
                if (message.color != null && message.hasOwnProperty("color"))
                    object.color = options.enums === String ? $root.osi3.LaneBoundary.Classification.Color[message.color] === undefined ? message.color : $root.osi3.LaneBoundary.Classification.Color[message.color] : message.color;
                if (message.limitingStructureId && message.limitingStructureId.length) {
                    object.limitingStructureId = [];
                    for (let j = 0; j < message.limitingStructureId.length; ++j)
                        object.limitingStructureId[j] = $root.osi3.Identifier.toObject(message.limitingStructureId[j], options);
                }
                return object;
            };

            /**
             * Converts this Classification to JSON.
             * @function toJSON
             * @memberof osi3.LaneBoundary.Classification
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Classification.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Classification
             * @function getTypeUrl
             * @memberof osi3.LaneBoundary.Classification
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Classification.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/osi3.LaneBoundary.Classification";
            };

            /**
             * Type enum.
             * @name osi3.LaneBoundary.Classification.Type
             * @enum {number}
             * @property {number} TYPE_UNKNOWN=0 TYPE_UNKNOWN value
             * @property {number} TYPE_OTHER=1 TYPE_OTHER value
             * @property {number} TYPE_NO_LINE=2 TYPE_NO_LINE value
             * @property {number} TYPE_SOLID_LINE=3 TYPE_SOLID_LINE value
             * @property {number} TYPE_DASHED_LINE=4 TYPE_DASHED_LINE value
             * @property {number} TYPE_BOTTS_DOTS=5 TYPE_BOTTS_DOTS value
             * @property {number} TYPE_ROAD_EDGE=6 TYPE_ROAD_EDGE value
             * @property {number} TYPE_SNOW_EDGE=7 TYPE_SNOW_EDGE value
             * @property {number} TYPE_GRASS_EDGE=8 TYPE_GRASS_EDGE value
             * @property {number} TYPE_GRAVEL_EDGE=9 TYPE_GRAVEL_EDGE value
             * @property {number} TYPE_SOIL_EDGE=10 TYPE_SOIL_EDGE value
             * @property {number} TYPE_GUARD_RAIL=11 TYPE_GUARD_RAIL value
             * @property {number} TYPE_CURB=12 TYPE_CURB value
             * @property {number} TYPE_STRUCTURE=13 TYPE_STRUCTURE value
             * @property {number} TYPE_BARRIER=14 TYPE_BARRIER value
             * @property {number} TYPE_SOUND_BARRIER=15 TYPE_SOUND_BARRIER value
             */
            Classification.Type = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "TYPE_UNKNOWN"] = 0;
                values[valuesById[1] = "TYPE_OTHER"] = 1;
                values[valuesById[2] = "TYPE_NO_LINE"] = 2;
                values[valuesById[3] = "TYPE_SOLID_LINE"] = 3;
                values[valuesById[4] = "TYPE_DASHED_LINE"] = 4;
                values[valuesById[5] = "TYPE_BOTTS_DOTS"] = 5;
                values[valuesById[6] = "TYPE_ROAD_EDGE"] = 6;
                values[valuesById[7] = "TYPE_SNOW_EDGE"] = 7;
                values[valuesById[8] = "TYPE_GRASS_EDGE"] = 8;
                values[valuesById[9] = "TYPE_GRAVEL_EDGE"] = 9;
                values[valuesById[10] = "TYPE_SOIL_EDGE"] = 10;
                values[valuesById[11] = "TYPE_GUARD_RAIL"] = 11;
                values[valuesById[12] = "TYPE_CURB"] = 12;
                values[valuesById[13] = "TYPE_STRUCTURE"] = 13;
                values[valuesById[14] = "TYPE_BARRIER"] = 14;
                values[valuesById[15] = "TYPE_SOUND_BARRIER"] = 15;
                return values;
            })();

            /**
             * Color enum.
             * @name osi3.LaneBoundary.Classification.Color
             * @enum {number}
             * @property {number} COLOR_UNKNOWN=0 COLOR_UNKNOWN value
             * @property {number} COLOR_OTHER=1 COLOR_OTHER value
             * @property {number} COLOR_NONE=2 COLOR_NONE value
             * @property {number} COLOR_WHITE=3 COLOR_WHITE value
             * @property {number} COLOR_YELLOW=4 COLOR_YELLOW value
             * @property {number} COLOR_RED=5 COLOR_RED value
             * @property {number} COLOR_BLUE=6 COLOR_BLUE value
             * @property {number} COLOR_GREEN=7 COLOR_GREEN value
             * @property {number} COLOR_VIOLET=8 COLOR_VIOLET value
             * @property {number} COLOR_ORANGE=9 COLOR_ORANGE value
             */
            Classification.Color = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "COLOR_UNKNOWN"] = 0;
                values[valuesById[1] = "COLOR_OTHER"] = 1;
                values[valuesById[2] = "COLOR_NONE"] = 2;
                values[valuesById[3] = "COLOR_WHITE"] = 3;
                values[valuesById[4] = "COLOR_YELLOW"] = 4;
                values[valuesById[5] = "COLOR_RED"] = 5;
                values[valuesById[6] = "COLOR_BLUE"] = 6;
                values[valuesById[7] = "COLOR_GREEN"] = 7;
                values[valuesById[8] = "COLOR_VIOLET"] = 8;
                values[valuesById[9] = "COLOR_ORANGE"] = 9;
                return values;
            })();

            return Classification;
        })();

        return LaneBoundary;
    })();

    osi3.LogicalLaneBoundary = (function() {

        /**
         * Properties of a LogicalLaneBoundary.
         * @memberof osi3
         * @interface ILogicalLaneBoundary
         * @property {osi3.IIdentifier|null} [id] LogicalLaneBoundary id
         * @property {Array.<osi3.LogicalLaneBoundary.ILogicalBoundaryPoint>|null} [boundaryLine] LogicalLaneBoundary boundaryLine
         * @property {osi3.IIdentifier|null} [referenceLineId] LogicalLaneBoundary referenceLineId
         * @property {Array.<osi3.IIdentifier>|null} [physicalBoundaryId] LogicalLaneBoundary physicalBoundaryId
         * @property {osi3.LogicalLaneBoundary.PassingRule|null} [passingRule] LogicalLaneBoundary passingRule
         * @property {Array.<osi3.IExternalReference>|null} [sourceReference] LogicalLaneBoundary sourceReference
         */

        /**
         * Constructs a new LogicalLaneBoundary.
         * @memberof osi3
         * @classdesc Represents a LogicalLaneBoundary.
         * @implements ILogicalLaneBoundary
         * @constructor
         * @param {osi3.ILogicalLaneBoundary=} [properties] Properties to set
         */
        function LogicalLaneBoundary(properties) {
            this.boundaryLine = [];
            this.physicalBoundaryId = [];
            this.sourceReference = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LogicalLaneBoundary id.
         * @member {osi3.IIdentifier|null|undefined} id
         * @memberof osi3.LogicalLaneBoundary
         * @instance
         */
        LogicalLaneBoundary.prototype.id = null;

        /**
         * LogicalLaneBoundary boundaryLine.
         * @member {Array.<osi3.LogicalLaneBoundary.ILogicalBoundaryPoint>} boundaryLine
         * @memberof osi3.LogicalLaneBoundary
         * @instance
         */
        LogicalLaneBoundary.prototype.boundaryLine = $util.emptyArray;

        /**
         * LogicalLaneBoundary referenceLineId.
         * @member {osi3.IIdentifier|null|undefined} referenceLineId
         * @memberof osi3.LogicalLaneBoundary
         * @instance
         */
        LogicalLaneBoundary.prototype.referenceLineId = null;

        /**
         * LogicalLaneBoundary physicalBoundaryId.
         * @member {Array.<osi3.IIdentifier>} physicalBoundaryId
         * @memberof osi3.LogicalLaneBoundary
         * @instance
         */
        LogicalLaneBoundary.prototype.physicalBoundaryId = $util.emptyArray;

        /**
         * LogicalLaneBoundary passingRule.
         * @member {osi3.LogicalLaneBoundary.PassingRule} passingRule
         * @memberof osi3.LogicalLaneBoundary
         * @instance
         */
        LogicalLaneBoundary.prototype.passingRule = 0;

        /**
         * LogicalLaneBoundary sourceReference.
         * @member {Array.<osi3.IExternalReference>} sourceReference
         * @memberof osi3.LogicalLaneBoundary
         * @instance
         */
        LogicalLaneBoundary.prototype.sourceReference = $util.emptyArray;

        /**
         * Creates a new LogicalLaneBoundary instance using the specified properties.
         * @function create
         * @memberof osi3.LogicalLaneBoundary
         * @static
         * @param {osi3.ILogicalLaneBoundary=} [properties] Properties to set
         * @returns {osi3.LogicalLaneBoundary} LogicalLaneBoundary instance
         */
        LogicalLaneBoundary.create = function create(properties) {
            return new LogicalLaneBoundary(properties);
        };

        /**
         * Encodes the specified LogicalLaneBoundary message. Does not implicitly {@link osi3.LogicalLaneBoundary.verify|verify} messages.
         * @function encode
         * @memberof osi3.LogicalLaneBoundary
         * @static
         * @param {osi3.ILogicalLaneBoundary} message LogicalLaneBoundary message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LogicalLaneBoundary.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                $root.osi3.Identifier.encode(message.id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.boundaryLine != null && message.boundaryLine.length)
                for (let i = 0; i < message.boundaryLine.length; ++i)
                    $root.osi3.LogicalLaneBoundary.LogicalBoundaryPoint.encode(message.boundaryLine[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.referenceLineId != null && Object.hasOwnProperty.call(message, "referenceLineId"))
                $root.osi3.Identifier.encode(message.referenceLineId, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.physicalBoundaryId != null && message.physicalBoundaryId.length)
                for (let i = 0; i < message.physicalBoundaryId.length; ++i)
                    $root.osi3.Identifier.encode(message.physicalBoundaryId[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.passingRule != null && Object.hasOwnProperty.call(message, "passingRule"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.passingRule);
            if (message.sourceReference != null && message.sourceReference.length)
                for (let i = 0; i < message.sourceReference.length; ++i)
                    $root.osi3.ExternalReference.encode(message.sourceReference[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified LogicalLaneBoundary message, length delimited. Does not implicitly {@link osi3.LogicalLaneBoundary.verify|verify} messages.
         * @function encodeDelimited
         * @memberof osi3.LogicalLaneBoundary
         * @static
         * @param {osi3.ILogicalLaneBoundary} message LogicalLaneBoundary message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LogicalLaneBoundary.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LogicalLaneBoundary message from the specified reader or buffer.
         * @function decode
         * @memberof osi3.LogicalLaneBoundary
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {osi3.LogicalLaneBoundary} LogicalLaneBoundary
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LogicalLaneBoundary.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.osi3.LogicalLaneBoundary();
            while (reader.pos < end) {
                let tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.id = $root.osi3.Identifier.decode(reader, reader.uint32());
                        break;
                    }
                case 2: {
                        if (!(message.boundaryLine && message.boundaryLine.length))
                            message.boundaryLine = [];
                        message.boundaryLine.push($root.osi3.LogicalLaneBoundary.LogicalBoundaryPoint.decode(reader, reader.uint32()));
                        break;
                    }
                case 3: {
                        message.referenceLineId = $root.osi3.Identifier.decode(reader, reader.uint32());
                        break;
                    }
                case 4: {
                        if (!(message.physicalBoundaryId && message.physicalBoundaryId.length))
                            message.physicalBoundaryId = [];
                        message.physicalBoundaryId.push($root.osi3.Identifier.decode(reader, reader.uint32()));
                        break;
                    }
                case 5: {
                        message.passingRule = reader.int32();
                        break;
                    }
                case 6: {
                        if (!(message.sourceReference && message.sourceReference.length))
                            message.sourceReference = [];
                        message.sourceReference.push($root.osi3.ExternalReference.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LogicalLaneBoundary message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof osi3.LogicalLaneBoundary
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {osi3.LogicalLaneBoundary} LogicalLaneBoundary
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LogicalLaneBoundary.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LogicalLaneBoundary message.
         * @function verify
         * @memberof osi3.LogicalLaneBoundary
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LogicalLaneBoundary.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id")) {
                let error = $root.osi3.Identifier.verify(message.id);
                if (error)
                    return "id." + error;
            }
            if (message.boundaryLine != null && message.hasOwnProperty("boundaryLine")) {
                if (!Array.isArray(message.boundaryLine))
                    return "boundaryLine: array expected";
                for (let i = 0; i < message.boundaryLine.length; ++i) {
                    let error = $root.osi3.LogicalLaneBoundary.LogicalBoundaryPoint.verify(message.boundaryLine[i]);
                    if (error)
                        return "boundaryLine." + error;
                }
            }
            if (message.referenceLineId != null && message.hasOwnProperty("referenceLineId")) {
                let error = $root.osi3.Identifier.verify(message.referenceLineId);
                if (error)
                    return "referenceLineId." + error;
            }
            if (message.physicalBoundaryId != null && message.hasOwnProperty("physicalBoundaryId")) {
                if (!Array.isArray(message.physicalBoundaryId))
                    return "physicalBoundaryId: array expected";
                for (let i = 0; i < message.physicalBoundaryId.length; ++i) {
                    let error = $root.osi3.Identifier.verify(message.physicalBoundaryId[i]);
                    if (error)
                        return "physicalBoundaryId." + error;
                }
            }
            if (message.passingRule != null && message.hasOwnProperty("passingRule"))
                switch (message.passingRule) {
                default:
                    return "passingRule: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                    break;
                }
            if (message.sourceReference != null && message.hasOwnProperty("sourceReference")) {
                if (!Array.isArray(message.sourceReference))
                    return "sourceReference: array expected";
                for (let i = 0; i < message.sourceReference.length; ++i) {
                    let error = $root.osi3.ExternalReference.verify(message.sourceReference[i]);
                    if (error)
                        return "sourceReference." + error;
                }
            }
            return null;
        };

        /**
         * Creates a LogicalLaneBoundary message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof osi3.LogicalLaneBoundary
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {osi3.LogicalLaneBoundary} LogicalLaneBoundary
         */
        LogicalLaneBoundary.fromObject = function fromObject(object) {
            if (object instanceof $root.osi3.LogicalLaneBoundary)
                return object;
            let message = new $root.osi3.LogicalLaneBoundary();
            if (object.id != null) {
                if (typeof object.id !== "object")
                    throw TypeError(".osi3.LogicalLaneBoundary.id: object expected");
                message.id = $root.osi3.Identifier.fromObject(object.id);
            }
            if (object.boundaryLine) {
                if (!Array.isArray(object.boundaryLine))
                    throw TypeError(".osi3.LogicalLaneBoundary.boundaryLine: array expected");
                message.boundaryLine = [];
                for (let i = 0; i < object.boundaryLine.length; ++i) {
                    if (typeof object.boundaryLine[i] !== "object")
                        throw TypeError(".osi3.LogicalLaneBoundary.boundaryLine: object expected");
                    message.boundaryLine[i] = $root.osi3.LogicalLaneBoundary.LogicalBoundaryPoint.fromObject(object.boundaryLine[i]);
                }
            }
            if (object.referenceLineId != null) {
                if (typeof object.referenceLineId !== "object")
                    throw TypeError(".osi3.LogicalLaneBoundary.referenceLineId: object expected");
                message.referenceLineId = $root.osi3.Identifier.fromObject(object.referenceLineId);
            }
            if (object.physicalBoundaryId) {
                if (!Array.isArray(object.physicalBoundaryId))
                    throw TypeError(".osi3.LogicalLaneBoundary.physicalBoundaryId: array expected");
                message.physicalBoundaryId = [];
                for (let i = 0; i < object.physicalBoundaryId.length; ++i) {
                    if (typeof object.physicalBoundaryId[i] !== "object")
                        throw TypeError(".osi3.LogicalLaneBoundary.physicalBoundaryId: object expected");
                    message.physicalBoundaryId[i] = $root.osi3.Identifier.fromObject(object.physicalBoundaryId[i]);
                }
            }
            switch (object.passingRule) {
            default:
                if (typeof object.passingRule === "number") {
                    message.passingRule = object.passingRule;
                    break;
                }
                break;
            case "PASSING_RULE_UNKNOWN":
            case 0:
                message.passingRule = 0;
                break;
            case "PASSING_RULE_OTHER":
            case 1:
                message.passingRule = 1;
                break;
            case "PASSING_RULE_NONE_ALLOWED":
            case 2:
                message.passingRule = 2;
                break;
            case "PASSING_RULE_INCREASING_T":
            case 3:
                message.passingRule = 3;
                break;
            case "PASSING_RULE_DECREASING_T":
            case 4:
                message.passingRule = 4;
                break;
            case "PASSING_RULE_BOTH_ALLOWED":
            case 5:
                message.passingRule = 5;
                break;
            }
            if (object.sourceReference) {
                if (!Array.isArray(object.sourceReference))
                    throw TypeError(".osi3.LogicalLaneBoundary.sourceReference: array expected");
                message.sourceReference = [];
                for (let i = 0; i < object.sourceReference.length; ++i) {
                    if (typeof object.sourceReference[i] !== "object")
                        throw TypeError(".osi3.LogicalLaneBoundary.sourceReference: object expected");
                    message.sourceReference[i] = $root.osi3.ExternalReference.fromObject(object.sourceReference[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a LogicalLaneBoundary message. Also converts values to other types if specified.
         * @function toObject
         * @memberof osi3.LogicalLaneBoundary
         * @static
         * @param {osi3.LogicalLaneBoundary} message LogicalLaneBoundary
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        LogicalLaneBoundary.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.boundaryLine = [];
                object.physicalBoundaryId = [];
                object.sourceReference = [];
            }
            if (options.defaults) {
                object.id = null;
                object.referenceLineId = null;
                object.passingRule = options.enums === String ? "PASSING_RULE_UNKNOWN" : 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = $root.osi3.Identifier.toObject(message.id, options);
            if (message.boundaryLine && message.boundaryLine.length) {
                object.boundaryLine = [];
                for (let j = 0; j < message.boundaryLine.length; ++j)
                    object.boundaryLine[j] = $root.osi3.LogicalLaneBoundary.LogicalBoundaryPoint.toObject(message.boundaryLine[j], options);
            }
            if (message.referenceLineId != null && message.hasOwnProperty("referenceLineId"))
                object.referenceLineId = $root.osi3.Identifier.toObject(message.referenceLineId, options);
            if (message.physicalBoundaryId && message.physicalBoundaryId.length) {
                object.physicalBoundaryId = [];
                for (let j = 0; j < message.physicalBoundaryId.length; ++j)
                    object.physicalBoundaryId[j] = $root.osi3.Identifier.toObject(message.physicalBoundaryId[j], options);
            }
            if (message.passingRule != null && message.hasOwnProperty("passingRule"))
                object.passingRule = options.enums === String ? $root.osi3.LogicalLaneBoundary.PassingRule[message.passingRule] === undefined ? message.passingRule : $root.osi3.LogicalLaneBoundary.PassingRule[message.passingRule] : message.passingRule;
            if (message.sourceReference && message.sourceReference.length) {
                object.sourceReference = [];
                for (let j = 0; j < message.sourceReference.length; ++j)
                    object.sourceReference[j] = $root.osi3.ExternalReference.toObject(message.sourceReference[j], options);
            }
            return object;
        };

        /**
         * Converts this LogicalLaneBoundary to JSON.
         * @function toJSON
         * @memberof osi3.LogicalLaneBoundary
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        LogicalLaneBoundary.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for LogicalLaneBoundary
         * @function getTypeUrl
         * @memberof osi3.LogicalLaneBoundary
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        LogicalLaneBoundary.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/osi3.LogicalLaneBoundary";
        };

        LogicalLaneBoundary.LogicalBoundaryPoint = (function() {

            /**
             * Properties of a LogicalBoundaryPoint.
             * @memberof osi3.LogicalLaneBoundary
             * @interface ILogicalBoundaryPoint
             * @property {osi3.IVector3d|null} [position] LogicalBoundaryPoint position
             * @property {number|null} [sPosition] LogicalBoundaryPoint sPosition
             * @property {number|null} [tPosition] LogicalBoundaryPoint tPosition
             */

            /**
             * Constructs a new LogicalBoundaryPoint.
             * @memberof osi3.LogicalLaneBoundary
             * @classdesc Represents a LogicalBoundaryPoint.
             * @implements ILogicalBoundaryPoint
             * @constructor
             * @param {osi3.LogicalLaneBoundary.ILogicalBoundaryPoint=} [properties] Properties to set
             */
            function LogicalBoundaryPoint(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * LogicalBoundaryPoint position.
             * @member {osi3.IVector3d|null|undefined} position
             * @memberof osi3.LogicalLaneBoundary.LogicalBoundaryPoint
             * @instance
             */
            LogicalBoundaryPoint.prototype.position = null;

            /**
             * LogicalBoundaryPoint sPosition.
             * @member {number} sPosition
             * @memberof osi3.LogicalLaneBoundary.LogicalBoundaryPoint
             * @instance
             */
            LogicalBoundaryPoint.prototype.sPosition = 0;

            /**
             * LogicalBoundaryPoint tPosition.
             * @member {number} tPosition
             * @memberof osi3.LogicalLaneBoundary.LogicalBoundaryPoint
             * @instance
             */
            LogicalBoundaryPoint.prototype.tPosition = 0;

            /**
             * Creates a new LogicalBoundaryPoint instance using the specified properties.
             * @function create
             * @memberof osi3.LogicalLaneBoundary.LogicalBoundaryPoint
             * @static
             * @param {osi3.LogicalLaneBoundary.ILogicalBoundaryPoint=} [properties] Properties to set
             * @returns {osi3.LogicalLaneBoundary.LogicalBoundaryPoint} LogicalBoundaryPoint instance
             */
            LogicalBoundaryPoint.create = function create(properties) {
                return new LogicalBoundaryPoint(properties);
            };

            /**
             * Encodes the specified LogicalBoundaryPoint message. Does not implicitly {@link osi3.LogicalLaneBoundary.LogicalBoundaryPoint.verify|verify} messages.
             * @function encode
             * @memberof osi3.LogicalLaneBoundary.LogicalBoundaryPoint
             * @static
             * @param {osi3.LogicalLaneBoundary.ILogicalBoundaryPoint} message LogicalBoundaryPoint message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LogicalBoundaryPoint.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.position != null && Object.hasOwnProperty.call(message, "position"))
                    $root.osi3.Vector3d.encode(message.position, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.sPosition != null && Object.hasOwnProperty.call(message, "sPosition"))
                    writer.uint32(/* id 2, wireType 1 =*/17).double(message.sPosition);
                if (message.tPosition != null && Object.hasOwnProperty.call(message, "tPosition"))
                    writer.uint32(/* id 3, wireType 1 =*/25).double(message.tPosition);
                return writer;
            };

            /**
             * Encodes the specified LogicalBoundaryPoint message, length delimited. Does not implicitly {@link osi3.LogicalLaneBoundary.LogicalBoundaryPoint.verify|verify} messages.
             * @function encodeDelimited
             * @memberof osi3.LogicalLaneBoundary.LogicalBoundaryPoint
             * @static
             * @param {osi3.LogicalLaneBoundary.ILogicalBoundaryPoint} message LogicalBoundaryPoint message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LogicalBoundaryPoint.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a LogicalBoundaryPoint message from the specified reader or buffer.
             * @function decode
             * @memberof osi3.LogicalLaneBoundary.LogicalBoundaryPoint
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {osi3.LogicalLaneBoundary.LogicalBoundaryPoint} LogicalBoundaryPoint
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LogicalBoundaryPoint.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.osi3.LogicalLaneBoundary.LogicalBoundaryPoint();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.position = $root.osi3.Vector3d.decode(reader, reader.uint32());
                            break;
                        }
                    case 2: {
                            message.sPosition = reader.double();
                            break;
                        }
                    case 3: {
                            message.tPosition = reader.double();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a LogicalBoundaryPoint message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof osi3.LogicalLaneBoundary.LogicalBoundaryPoint
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {osi3.LogicalLaneBoundary.LogicalBoundaryPoint} LogicalBoundaryPoint
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LogicalBoundaryPoint.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a LogicalBoundaryPoint message.
             * @function verify
             * @memberof osi3.LogicalLaneBoundary.LogicalBoundaryPoint
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            LogicalBoundaryPoint.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.position != null && message.hasOwnProperty("position")) {
                    let error = $root.osi3.Vector3d.verify(message.position);
                    if (error)
                        return "position." + error;
                }
                if (message.sPosition != null && message.hasOwnProperty("sPosition"))
                    if (typeof message.sPosition !== "number")
                        return "sPosition: number expected";
                if (message.tPosition != null && message.hasOwnProperty("tPosition"))
                    if (typeof message.tPosition !== "number")
                        return "tPosition: number expected";
                return null;
            };

            /**
             * Creates a LogicalBoundaryPoint message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof osi3.LogicalLaneBoundary.LogicalBoundaryPoint
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {osi3.LogicalLaneBoundary.LogicalBoundaryPoint} LogicalBoundaryPoint
             */
            LogicalBoundaryPoint.fromObject = function fromObject(object) {
                if (object instanceof $root.osi3.LogicalLaneBoundary.LogicalBoundaryPoint)
                    return object;
                let message = new $root.osi3.LogicalLaneBoundary.LogicalBoundaryPoint();
                if (object.position != null) {
                    if (typeof object.position !== "object")
                        throw TypeError(".osi3.LogicalLaneBoundary.LogicalBoundaryPoint.position: object expected");
                    message.position = $root.osi3.Vector3d.fromObject(object.position);
                }
                if (object.sPosition != null)
                    message.sPosition = Number(object.sPosition);
                if (object.tPosition != null)
                    message.tPosition = Number(object.tPosition);
                return message;
            };

            /**
             * Creates a plain object from a LogicalBoundaryPoint message. Also converts values to other types if specified.
             * @function toObject
             * @memberof osi3.LogicalLaneBoundary.LogicalBoundaryPoint
             * @static
             * @param {osi3.LogicalLaneBoundary.LogicalBoundaryPoint} message LogicalBoundaryPoint
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            LogicalBoundaryPoint.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.position = null;
                    object.sPosition = 0;
                    object.tPosition = 0;
                }
                if (message.position != null && message.hasOwnProperty("position"))
                    object.position = $root.osi3.Vector3d.toObject(message.position, options);
                if (message.sPosition != null && message.hasOwnProperty("sPosition"))
                    object.sPosition = options.json && !isFinite(message.sPosition) ? String(message.sPosition) : message.sPosition;
                if (message.tPosition != null && message.hasOwnProperty("tPosition"))
                    object.tPosition = options.json && !isFinite(message.tPosition) ? String(message.tPosition) : message.tPosition;
                return object;
            };

            /**
             * Converts this LogicalBoundaryPoint to JSON.
             * @function toJSON
             * @memberof osi3.LogicalLaneBoundary.LogicalBoundaryPoint
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            LogicalBoundaryPoint.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for LogicalBoundaryPoint
             * @function getTypeUrl
             * @memberof osi3.LogicalLaneBoundary.LogicalBoundaryPoint
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            LogicalBoundaryPoint.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/osi3.LogicalLaneBoundary.LogicalBoundaryPoint";
            };

            return LogicalBoundaryPoint;
        })();

        /**
         * PassingRule enum.
         * @name osi3.LogicalLaneBoundary.PassingRule
         * @enum {number}
         * @property {number} PASSING_RULE_UNKNOWN=0 PASSING_RULE_UNKNOWN value
         * @property {number} PASSING_RULE_OTHER=1 PASSING_RULE_OTHER value
         * @property {number} PASSING_RULE_NONE_ALLOWED=2 PASSING_RULE_NONE_ALLOWED value
         * @property {number} PASSING_RULE_INCREASING_T=3 PASSING_RULE_INCREASING_T value
         * @property {number} PASSING_RULE_DECREASING_T=4 PASSING_RULE_DECREASING_T value
         * @property {number} PASSING_RULE_BOTH_ALLOWED=5 PASSING_RULE_BOTH_ALLOWED value
         */
        LogicalLaneBoundary.PassingRule = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "PASSING_RULE_UNKNOWN"] = 0;
            values[valuesById[1] = "PASSING_RULE_OTHER"] = 1;
            values[valuesById[2] = "PASSING_RULE_NONE_ALLOWED"] = 2;
            values[valuesById[3] = "PASSING_RULE_INCREASING_T"] = 3;
            values[valuesById[4] = "PASSING_RULE_DECREASING_T"] = 4;
            values[valuesById[5] = "PASSING_RULE_BOTH_ALLOWED"] = 5;
            return values;
        })();

        return LogicalLaneBoundary;
    })();

    osi3.LogicalLane = (function() {

        /**
         * Properties of a LogicalLane.
         * @memberof osi3
         * @interface ILogicalLane
         * @property {osi3.IIdentifier|null} [id] LogicalLane id
         * @property {osi3.LogicalLane.Type|null} [type] LogicalLane type
         * @property {Array.<osi3.IExternalReference>|null} [sourceReference] LogicalLane sourceReference
         * @property {Array.<osi3.LogicalLane.IPhysicalLaneReference>|null} [physicalLaneReference] LogicalLane physicalLaneReference
         * @property {osi3.IIdentifier|null} [referenceLineId] LogicalLane referenceLineId
         * @property {number|null} [startS] LogicalLane startS
         * @property {number|null} [endS] LogicalLane endS
         * @property {osi3.LogicalLane.MoveDirection|null} [moveDirection] LogicalLane moveDirection
         * @property {Array.<osi3.LogicalLane.ILaneRelation>|null} [rightAdjacentLane] LogicalLane rightAdjacentLane
         * @property {Array.<osi3.LogicalLane.ILaneRelation>|null} [leftAdjacentLane] LogicalLane leftAdjacentLane
         * @property {Array.<osi3.LogicalLane.ILaneRelation>|null} [overlappingLane] LogicalLane overlappingLane
         * @property {Array.<osi3.IIdentifier>|null} [rightBoundaryId] LogicalLane rightBoundaryId
         * @property {Array.<osi3.IIdentifier>|null} [leftBoundaryId] LogicalLane leftBoundaryId
         * @property {Array.<osi3.LogicalLane.ILaneConnection>|null} [predecessorLane] LogicalLane predecessorLane
         * @property {Array.<osi3.LogicalLane.ILaneConnection>|null} [successorLane] LogicalLane successorLane
         * @property {string|null} [streetName] LogicalLane streetName
         * @property {Array.<osi3.LogicalLane.ITrafficRule>|null} [trafficRule] LogicalLane trafficRule
         */

        /**
         * Constructs a new LogicalLane.
         * @memberof osi3
         * @classdesc Represents a LogicalLane.
         * @implements ILogicalLane
         * @constructor
         * @param {osi3.ILogicalLane=} [properties] Properties to set
         */
        function LogicalLane(properties) {
            this.sourceReference = [];
            this.physicalLaneReference = [];
            this.rightAdjacentLane = [];
            this.leftAdjacentLane = [];
            this.overlappingLane = [];
            this.rightBoundaryId = [];
            this.leftBoundaryId = [];
            this.predecessorLane = [];
            this.successorLane = [];
            this.trafficRule = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LogicalLane id.
         * @member {osi3.IIdentifier|null|undefined} id
         * @memberof osi3.LogicalLane
         * @instance
         */
        LogicalLane.prototype.id = null;

        /**
         * LogicalLane type.
         * @member {osi3.LogicalLane.Type} type
         * @memberof osi3.LogicalLane
         * @instance
         */
        LogicalLane.prototype.type = 0;

        /**
         * LogicalLane sourceReference.
         * @member {Array.<osi3.IExternalReference>} sourceReference
         * @memberof osi3.LogicalLane
         * @instance
         */
        LogicalLane.prototype.sourceReference = $util.emptyArray;

        /**
         * LogicalLane physicalLaneReference.
         * @member {Array.<osi3.LogicalLane.IPhysicalLaneReference>} physicalLaneReference
         * @memberof osi3.LogicalLane
         * @instance
         */
        LogicalLane.prototype.physicalLaneReference = $util.emptyArray;

        /**
         * LogicalLane referenceLineId.
         * @member {osi3.IIdentifier|null|undefined} referenceLineId
         * @memberof osi3.LogicalLane
         * @instance
         */
        LogicalLane.prototype.referenceLineId = null;

        /**
         * LogicalLane startS.
         * @member {number} startS
         * @memberof osi3.LogicalLane
         * @instance
         */
        LogicalLane.prototype.startS = 0;

        /**
         * LogicalLane endS.
         * @member {number} endS
         * @memberof osi3.LogicalLane
         * @instance
         */
        LogicalLane.prototype.endS = 0;

        /**
         * LogicalLane moveDirection.
         * @member {osi3.LogicalLane.MoveDirection} moveDirection
         * @memberof osi3.LogicalLane
         * @instance
         */
        LogicalLane.prototype.moveDirection = 0;

        /**
         * LogicalLane rightAdjacentLane.
         * @member {Array.<osi3.LogicalLane.ILaneRelation>} rightAdjacentLane
         * @memberof osi3.LogicalLane
         * @instance
         */
        LogicalLane.prototype.rightAdjacentLane = $util.emptyArray;

        /**
         * LogicalLane leftAdjacentLane.
         * @member {Array.<osi3.LogicalLane.ILaneRelation>} leftAdjacentLane
         * @memberof osi3.LogicalLane
         * @instance
         */
        LogicalLane.prototype.leftAdjacentLane = $util.emptyArray;

        /**
         * LogicalLane overlappingLane.
         * @member {Array.<osi3.LogicalLane.ILaneRelation>} overlappingLane
         * @memberof osi3.LogicalLane
         * @instance
         */
        LogicalLane.prototype.overlappingLane = $util.emptyArray;

        /**
         * LogicalLane rightBoundaryId.
         * @member {Array.<osi3.IIdentifier>} rightBoundaryId
         * @memberof osi3.LogicalLane
         * @instance
         */
        LogicalLane.prototype.rightBoundaryId = $util.emptyArray;

        /**
         * LogicalLane leftBoundaryId.
         * @member {Array.<osi3.IIdentifier>} leftBoundaryId
         * @memberof osi3.LogicalLane
         * @instance
         */
        LogicalLane.prototype.leftBoundaryId = $util.emptyArray;

        /**
         * LogicalLane predecessorLane.
         * @member {Array.<osi3.LogicalLane.ILaneConnection>} predecessorLane
         * @memberof osi3.LogicalLane
         * @instance
         */
        LogicalLane.prototype.predecessorLane = $util.emptyArray;

        /**
         * LogicalLane successorLane.
         * @member {Array.<osi3.LogicalLane.ILaneConnection>} successorLane
         * @memberof osi3.LogicalLane
         * @instance
         */
        LogicalLane.prototype.successorLane = $util.emptyArray;

        /**
         * LogicalLane streetName.
         * @member {string} streetName
         * @memberof osi3.LogicalLane
         * @instance
         */
        LogicalLane.prototype.streetName = "";

        /**
         * LogicalLane trafficRule.
         * @member {Array.<osi3.LogicalLane.ITrafficRule>} trafficRule
         * @memberof osi3.LogicalLane
         * @instance
         */
        LogicalLane.prototype.trafficRule = $util.emptyArray;

        /**
         * Creates a new LogicalLane instance using the specified properties.
         * @function create
         * @memberof osi3.LogicalLane
         * @static
         * @param {osi3.ILogicalLane=} [properties] Properties to set
         * @returns {osi3.LogicalLane} LogicalLane instance
         */
        LogicalLane.create = function create(properties) {
            return new LogicalLane(properties);
        };

        /**
         * Encodes the specified LogicalLane message. Does not implicitly {@link osi3.LogicalLane.verify|verify} messages.
         * @function encode
         * @memberof osi3.LogicalLane
         * @static
         * @param {osi3.ILogicalLane} message LogicalLane message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LogicalLane.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                $root.osi3.Identifier.encode(message.id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
            if (message.sourceReference != null && message.sourceReference.length)
                for (let i = 0; i < message.sourceReference.length; ++i)
                    $root.osi3.ExternalReference.encode(message.sourceReference[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.physicalLaneReference != null && message.physicalLaneReference.length)
                for (let i = 0; i < message.physicalLaneReference.length; ++i)
                    $root.osi3.LogicalLane.PhysicalLaneReference.encode(message.physicalLaneReference[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.referenceLineId != null && Object.hasOwnProperty.call(message, "referenceLineId"))
                $root.osi3.Identifier.encode(message.referenceLineId, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.startS != null && Object.hasOwnProperty.call(message, "startS"))
                writer.uint32(/* id 6, wireType 1 =*/49).double(message.startS);
            if (message.endS != null && Object.hasOwnProperty.call(message, "endS"))
                writer.uint32(/* id 7, wireType 1 =*/57).double(message.endS);
            if (message.moveDirection != null && Object.hasOwnProperty.call(message, "moveDirection"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.moveDirection);
            if (message.rightAdjacentLane != null && message.rightAdjacentLane.length)
                for (let i = 0; i < message.rightAdjacentLane.length; ++i)
                    $root.osi3.LogicalLane.LaneRelation.encode(message.rightAdjacentLane[i], writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            if (message.leftAdjacentLane != null && message.leftAdjacentLane.length)
                for (let i = 0; i < message.leftAdjacentLane.length; ++i)
                    $root.osi3.LogicalLane.LaneRelation.encode(message.leftAdjacentLane[i], writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            if (message.overlappingLane != null && message.overlappingLane.length)
                for (let i = 0; i < message.overlappingLane.length; ++i)
                    $root.osi3.LogicalLane.LaneRelation.encode(message.overlappingLane[i], writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
            if (message.rightBoundaryId != null && message.rightBoundaryId.length)
                for (let i = 0; i < message.rightBoundaryId.length; ++i)
                    $root.osi3.Identifier.encode(message.rightBoundaryId[i], writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
            if (message.leftBoundaryId != null && message.leftBoundaryId.length)
                for (let i = 0; i < message.leftBoundaryId.length; ++i)
                    $root.osi3.Identifier.encode(message.leftBoundaryId[i], writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
            if (message.predecessorLane != null && message.predecessorLane.length)
                for (let i = 0; i < message.predecessorLane.length; ++i)
                    $root.osi3.LogicalLane.LaneConnection.encode(message.predecessorLane[i], writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
            if (message.successorLane != null && message.successorLane.length)
                for (let i = 0; i < message.successorLane.length; ++i)
                    $root.osi3.LogicalLane.LaneConnection.encode(message.successorLane[i], writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
            if (message.streetName != null && Object.hasOwnProperty.call(message, "streetName"))
                writer.uint32(/* id 16, wireType 2 =*/130).string(message.streetName);
            if (message.trafficRule != null && message.trafficRule.length)
                for (let i = 0; i < message.trafficRule.length; ++i)
                    $root.osi3.LogicalLane.TrafficRule.encode(message.trafficRule[i], writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified LogicalLane message, length delimited. Does not implicitly {@link osi3.LogicalLane.verify|verify} messages.
         * @function encodeDelimited
         * @memberof osi3.LogicalLane
         * @static
         * @param {osi3.ILogicalLane} message LogicalLane message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LogicalLane.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LogicalLane message from the specified reader or buffer.
         * @function decode
         * @memberof osi3.LogicalLane
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {osi3.LogicalLane} LogicalLane
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LogicalLane.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.osi3.LogicalLane();
            while (reader.pos < end) {
                let tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.id = $root.osi3.Identifier.decode(reader, reader.uint32());
                        break;
                    }
                case 2: {
                        message.type = reader.int32();
                        break;
                    }
                case 3: {
                        if (!(message.sourceReference && message.sourceReference.length))
                            message.sourceReference = [];
                        message.sourceReference.push($root.osi3.ExternalReference.decode(reader, reader.uint32()));
                        break;
                    }
                case 4: {
                        if (!(message.physicalLaneReference && message.physicalLaneReference.length))
                            message.physicalLaneReference = [];
                        message.physicalLaneReference.push($root.osi3.LogicalLane.PhysicalLaneReference.decode(reader, reader.uint32()));
                        break;
                    }
                case 5: {
                        message.referenceLineId = $root.osi3.Identifier.decode(reader, reader.uint32());
                        break;
                    }
                case 6: {
                        message.startS = reader.double();
                        break;
                    }
                case 7: {
                        message.endS = reader.double();
                        break;
                    }
                case 8: {
                        message.moveDirection = reader.int32();
                        break;
                    }
                case 9: {
                        if (!(message.rightAdjacentLane && message.rightAdjacentLane.length))
                            message.rightAdjacentLane = [];
                        message.rightAdjacentLane.push($root.osi3.LogicalLane.LaneRelation.decode(reader, reader.uint32()));
                        break;
                    }
                case 10: {
                        if (!(message.leftAdjacentLane && message.leftAdjacentLane.length))
                            message.leftAdjacentLane = [];
                        message.leftAdjacentLane.push($root.osi3.LogicalLane.LaneRelation.decode(reader, reader.uint32()));
                        break;
                    }
                case 11: {
                        if (!(message.overlappingLane && message.overlappingLane.length))
                            message.overlappingLane = [];
                        message.overlappingLane.push($root.osi3.LogicalLane.LaneRelation.decode(reader, reader.uint32()));
                        break;
                    }
                case 12: {
                        if (!(message.rightBoundaryId && message.rightBoundaryId.length))
                            message.rightBoundaryId = [];
                        message.rightBoundaryId.push($root.osi3.Identifier.decode(reader, reader.uint32()));
                        break;
                    }
                case 13: {
                        if (!(message.leftBoundaryId && message.leftBoundaryId.length))
                            message.leftBoundaryId = [];
                        message.leftBoundaryId.push($root.osi3.Identifier.decode(reader, reader.uint32()));
                        break;
                    }
                case 14: {
                        if (!(message.predecessorLane && message.predecessorLane.length))
                            message.predecessorLane = [];
                        message.predecessorLane.push($root.osi3.LogicalLane.LaneConnection.decode(reader, reader.uint32()));
                        break;
                    }
                case 15: {
                        if (!(message.successorLane && message.successorLane.length))
                            message.successorLane = [];
                        message.successorLane.push($root.osi3.LogicalLane.LaneConnection.decode(reader, reader.uint32()));
                        break;
                    }
                case 16: {
                        message.streetName = reader.string();
                        break;
                    }
                case 17: {
                        if (!(message.trafficRule && message.trafficRule.length))
                            message.trafficRule = [];
                        message.trafficRule.push($root.osi3.LogicalLane.TrafficRule.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LogicalLane message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof osi3.LogicalLane
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {osi3.LogicalLane} LogicalLane
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LogicalLane.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LogicalLane message.
         * @function verify
         * @memberof osi3.LogicalLane
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LogicalLane.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id")) {
                let error = $root.osi3.Identifier.verify(message.id);
                if (error)
                    return "id." + error;
            }
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                case 15:
                case 16:
                case 17:
                case 18:
                    break;
                }
            if (message.sourceReference != null && message.hasOwnProperty("sourceReference")) {
                if (!Array.isArray(message.sourceReference))
                    return "sourceReference: array expected";
                for (let i = 0; i < message.sourceReference.length; ++i) {
                    let error = $root.osi3.ExternalReference.verify(message.sourceReference[i]);
                    if (error)
                        return "sourceReference." + error;
                }
            }
            if (message.physicalLaneReference != null && message.hasOwnProperty("physicalLaneReference")) {
                if (!Array.isArray(message.physicalLaneReference))
                    return "physicalLaneReference: array expected";
                for (let i = 0; i < message.physicalLaneReference.length; ++i) {
                    let error = $root.osi3.LogicalLane.PhysicalLaneReference.verify(message.physicalLaneReference[i]);
                    if (error)
                        return "physicalLaneReference." + error;
                }
            }
            if (message.referenceLineId != null && message.hasOwnProperty("referenceLineId")) {
                let error = $root.osi3.Identifier.verify(message.referenceLineId);
                if (error)
                    return "referenceLineId." + error;
            }
            if (message.startS != null && message.hasOwnProperty("startS"))
                if (typeof message.startS !== "number")
                    return "startS: number expected";
            if (message.endS != null && message.hasOwnProperty("endS"))
                if (typeof message.endS !== "number")
                    return "endS: number expected";
            if (message.moveDirection != null && message.hasOwnProperty("moveDirection"))
                switch (message.moveDirection) {
                default:
                    return "moveDirection: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                    break;
                }
            if (message.rightAdjacentLane != null && message.hasOwnProperty("rightAdjacentLane")) {
                if (!Array.isArray(message.rightAdjacentLane))
                    return "rightAdjacentLane: array expected";
                for (let i = 0; i < message.rightAdjacentLane.length; ++i) {
                    let error = $root.osi3.LogicalLane.LaneRelation.verify(message.rightAdjacentLane[i]);
                    if (error)
                        return "rightAdjacentLane." + error;
                }
            }
            if (message.leftAdjacentLane != null && message.hasOwnProperty("leftAdjacentLane")) {
                if (!Array.isArray(message.leftAdjacentLane))
                    return "leftAdjacentLane: array expected";
                for (let i = 0; i < message.leftAdjacentLane.length; ++i) {
                    let error = $root.osi3.LogicalLane.LaneRelation.verify(message.leftAdjacentLane[i]);
                    if (error)
                        return "leftAdjacentLane." + error;
                }
            }
            if (message.overlappingLane != null && message.hasOwnProperty("overlappingLane")) {
                if (!Array.isArray(message.overlappingLane))
                    return "overlappingLane: array expected";
                for (let i = 0; i < message.overlappingLane.length; ++i) {
                    let error = $root.osi3.LogicalLane.LaneRelation.verify(message.overlappingLane[i]);
                    if (error)
                        return "overlappingLane." + error;
                }
            }
            if (message.rightBoundaryId != null && message.hasOwnProperty("rightBoundaryId")) {
                if (!Array.isArray(message.rightBoundaryId))
                    return "rightBoundaryId: array expected";
                for (let i = 0; i < message.rightBoundaryId.length; ++i) {
                    let error = $root.osi3.Identifier.verify(message.rightBoundaryId[i]);
                    if (error)
                        return "rightBoundaryId." + error;
                }
            }
            if (message.leftBoundaryId != null && message.hasOwnProperty("leftBoundaryId")) {
                if (!Array.isArray(message.leftBoundaryId))
                    return "leftBoundaryId: array expected";
                for (let i = 0; i < message.leftBoundaryId.length; ++i) {
                    let error = $root.osi3.Identifier.verify(message.leftBoundaryId[i]);
                    if (error)
                        return "leftBoundaryId." + error;
                }
            }
            if (message.predecessorLane != null && message.hasOwnProperty("predecessorLane")) {
                if (!Array.isArray(message.predecessorLane))
                    return "predecessorLane: array expected";
                for (let i = 0; i < message.predecessorLane.length; ++i) {
                    let error = $root.osi3.LogicalLane.LaneConnection.verify(message.predecessorLane[i]);
                    if (error)
                        return "predecessorLane." + error;
                }
            }
            if (message.successorLane != null && message.hasOwnProperty("successorLane")) {
                if (!Array.isArray(message.successorLane))
                    return "successorLane: array expected";
                for (let i = 0; i < message.successorLane.length; ++i) {
                    let error = $root.osi3.LogicalLane.LaneConnection.verify(message.successorLane[i]);
                    if (error)
                        return "successorLane." + error;
                }
            }
            if (message.streetName != null && message.hasOwnProperty("streetName"))
                if (!$util.isString(message.streetName))
                    return "streetName: string expected";
            if (message.trafficRule != null && message.hasOwnProperty("trafficRule")) {
                if (!Array.isArray(message.trafficRule))
                    return "trafficRule: array expected";
                for (let i = 0; i < message.trafficRule.length; ++i) {
                    let error = $root.osi3.LogicalLane.TrafficRule.verify(message.trafficRule[i]);
                    if (error)
                        return "trafficRule." + error;
                }
            }
            return null;
        };

        /**
         * Creates a LogicalLane message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof osi3.LogicalLane
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {osi3.LogicalLane} LogicalLane
         */
        LogicalLane.fromObject = function fromObject(object) {
            if (object instanceof $root.osi3.LogicalLane)
                return object;
            let message = new $root.osi3.LogicalLane();
            if (object.id != null) {
                if (typeof object.id !== "object")
                    throw TypeError(".osi3.LogicalLane.id: object expected");
                message.id = $root.osi3.Identifier.fromObject(object.id);
            }
            switch (object.type) {
            default:
                if (typeof object.type === "number") {
                    message.type = object.type;
                    break;
                }
                break;
            case "TYPE_UNKNOWN":
            case 0:
                message.type = 0;
                break;
            case "TYPE_OTHER":
            case 1:
                message.type = 1;
                break;
            case "TYPE_NORMAL":
            case 2:
                message.type = 2;
                break;
            case "TYPE_BIKING":
            case 3:
                message.type = 3;
                break;
            case "TYPE_SIDEWALK":
            case 4:
                message.type = 4;
                break;
            case "TYPE_PARKING":
            case 5:
                message.type = 5;
                break;
            case "TYPE_STOP":
            case 6:
                message.type = 6;
                break;
            case "TYPE_RESTRICTED":
            case 7:
                message.type = 7;
                break;
            case "TYPE_BORDER":
            case 8:
                message.type = 8;
                break;
            case "TYPE_SHOULDER":
            case 9:
                message.type = 9;
                break;
            case "TYPE_EXIT":
            case 10:
                message.type = 10;
                break;
            case "TYPE_ENTRY":
            case 11:
                message.type = 11;
                break;
            case "TYPE_ONRAMP":
            case 12:
                message.type = 12;
                break;
            case "TYPE_OFFRAMP":
            case 13:
                message.type = 13;
                break;
            case "TYPE_CONNECTINGRAMP":
            case 14:
                message.type = 14;
                break;
            case "TYPE_MEDIAN":
            case 15:
                message.type = 15;
                break;
            case "TYPE_CURB":
            case 16:
                message.type = 16;
                break;
            case "TYPE_RAIL":
            case 17:
                message.type = 17;
                break;
            case "TYPE_TRAM":
            case 18:
                message.type = 18;
                break;
            }
            if (object.sourceReference) {
                if (!Array.isArray(object.sourceReference))
                    throw TypeError(".osi3.LogicalLane.sourceReference: array expected");
                message.sourceReference = [];
                for (let i = 0; i < object.sourceReference.length; ++i) {
                    if (typeof object.sourceReference[i] !== "object")
                        throw TypeError(".osi3.LogicalLane.sourceReference: object expected");
                    message.sourceReference[i] = $root.osi3.ExternalReference.fromObject(object.sourceReference[i]);
                }
            }
            if (object.physicalLaneReference) {
                if (!Array.isArray(object.physicalLaneReference))
                    throw TypeError(".osi3.LogicalLane.physicalLaneReference: array expected");
                message.physicalLaneReference = [];
                for (let i = 0; i < object.physicalLaneReference.length; ++i) {
                    if (typeof object.physicalLaneReference[i] !== "object")
                        throw TypeError(".osi3.LogicalLane.physicalLaneReference: object expected");
                    message.physicalLaneReference[i] = $root.osi3.LogicalLane.PhysicalLaneReference.fromObject(object.physicalLaneReference[i]);
                }
            }
            if (object.referenceLineId != null) {
                if (typeof object.referenceLineId !== "object")
                    throw TypeError(".osi3.LogicalLane.referenceLineId: object expected");
                message.referenceLineId = $root.osi3.Identifier.fromObject(object.referenceLineId);
            }
            if (object.startS != null)
                message.startS = Number(object.startS);
            if (object.endS != null)
                message.endS = Number(object.endS);
            switch (object.moveDirection) {
            default:
                if (typeof object.moveDirection === "number") {
                    message.moveDirection = object.moveDirection;
                    break;
                }
                break;
            case "MOVE_DIRECTION_UNKNOWN":
            case 0:
                message.moveDirection = 0;
                break;
            case "MOVE_DIRECTION_OTHER":
            case 1:
                message.moveDirection = 1;
                break;
            case "MOVE_DIRECTION_INCREASING_S":
            case 2:
                message.moveDirection = 2;
                break;
            case "MOVE_DIRECTION_DECREASING_S":
            case 3:
                message.moveDirection = 3;
                break;
            case "MOVE_DIRECTION_BOTH_ALLOWED":
            case 4:
                message.moveDirection = 4;
                break;
            }
            if (object.rightAdjacentLane) {
                if (!Array.isArray(object.rightAdjacentLane))
                    throw TypeError(".osi3.LogicalLane.rightAdjacentLane: array expected");
                message.rightAdjacentLane = [];
                for (let i = 0; i < object.rightAdjacentLane.length; ++i) {
                    if (typeof object.rightAdjacentLane[i] !== "object")
                        throw TypeError(".osi3.LogicalLane.rightAdjacentLane: object expected");
                    message.rightAdjacentLane[i] = $root.osi3.LogicalLane.LaneRelation.fromObject(object.rightAdjacentLane[i]);
                }
            }
            if (object.leftAdjacentLane) {
                if (!Array.isArray(object.leftAdjacentLane))
                    throw TypeError(".osi3.LogicalLane.leftAdjacentLane: array expected");
                message.leftAdjacentLane = [];
                for (let i = 0; i < object.leftAdjacentLane.length; ++i) {
                    if (typeof object.leftAdjacentLane[i] !== "object")
                        throw TypeError(".osi3.LogicalLane.leftAdjacentLane: object expected");
                    message.leftAdjacentLane[i] = $root.osi3.LogicalLane.LaneRelation.fromObject(object.leftAdjacentLane[i]);
                }
            }
            if (object.overlappingLane) {
                if (!Array.isArray(object.overlappingLane))
                    throw TypeError(".osi3.LogicalLane.overlappingLane: array expected");
                message.overlappingLane = [];
                for (let i = 0; i < object.overlappingLane.length; ++i) {
                    if (typeof object.overlappingLane[i] !== "object")
                        throw TypeError(".osi3.LogicalLane.overlappingLane: object expected");
                    message.overlappingLane[i] = $root.osi3.LogicalLane.LaneRelation.fromObject(object.overlappingLane[i]);
                }
            }
            if (object.rightBoundaryId) {
                if (!Array.isArray(object.rightBoundaryId))
                    throw TypeError(".osi3.LogicalLane.rightBoundaryId: array expected");
                message.rightBoundaryId = [];
                for (let i = 0; i < object.rightBoundaryId.length; ++i) {
                    if (typeof object.rightBoundaryId[i] !== "object")
                        throw TypeError(".osi3.LogicalLane.rightBoundaryId: object expected");
                    message.rightBoundaryId[i] = $root.osi3.Identifier.fromObject(object.rightBoundaryId[i]);
                }
            }
            if (object.leftBoundaryId) {
                if (!Array.isArray(object.leftBoundaryId))
                    throw TypeError(".osi3.LogicalLane.leftBoundaryId: array expected");
                message.leftBoundaryId = [];
                for (let i = 0; i < object.leftBoundaryId.length; ++i) {
                    if (typeof object.leftBoundaryId[i] !== "object")
                        throw TypeError(".osi3.LogicalLane.leftBoundaryId: object expected");
                    message.leftBoundaryId[i] = $root.osi3.Identifier.fromObject(object.leftBoundaryId[i]);
                }
            }
            if (object.predecessorLane) {
                if (!Array.isArray(object.predecessorLane))
                    throw TypeError(".osi3.LogicalLane.predecessorLane: array expected");
                message.predecessorLane = [];
                for (let i = 0; i < object.predecessorLane.length; ++i) {
                    if (typeof object.predecessorLane[i] !== "object")
                        throw TypeError(".osi3.LogicalLane.predecessorLane: object expected");
                    message.predecessorLane[i] = $root.osi3.LogicalLane.LaneConnection.fromObject(object.predecessorLane[i]);
                }
            }
            if (object.successorLane) {
                if (!Array.isArray(object.successorLane))
                    throw TypeError(".osi3.LogicalLane.successorLane: array expected");
                message.successorLane = [];
                for (let i = 0; i < object.successorLane.length; ++i) {
                    if (typeof object.successorLane[i] !== "object")
                        throw TypeError(".osi3.LogicalLane.successorLane: object expected");
                    message.successorLane[i] = $root.osi3.LogicalLane.LaneConnection.fromObject(object.successorLane[i]);
                }
            }
            if (object.streetName != null)
                message.streetName = String(object.streetName);
            if (object.trafficRule) {
                if (!Array.isArray(object.trafficRule))
                    throw TypeError(".osi3.LogicalLane.trafficRule: array expected");
                message.trafficRule = [];
                for (let i = 0; i < object.trafficRule.length; ++i) {
                    if (typeof object.trafficRule[i] !== "object")
                        throw TypeError(".osi3.LogicalLane.trafficRule: object expected");
                    message.trafficRule[i] = $root.osi3.LogicalLane.TrafficRule.fromObject(object.trafficRule[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a LogicalLane message. Also converts values to other types if specified.
         * @function toObject
         * @memberof osi3.LogicalLane
         * @static
         * @param {osi3.LogicalLane} message LogicalLane
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        LogicalLane.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.sourceReference = [];
                object.physicalLaneReference = [];
                object.rightAdjacentLane = [];
                object.leftAdjacentLane = [];
                object.overlappingLane = [];
                object.rightBoundaryId = [];
                object.leftBoundaryId = [];
                object.predecessorLane = [];
                object.successorLane = [];
                object.trafficRule = [];
            }
            if (options.defaults) {
                object.id = null;
                object.type = options.enums === String ? "TYPE_UNKNOWN" : 0;
                object.referenceLineId = null;
                object.startS = 0;
                object.endS = 0;
                object.moveDirection = options.enums === String ? "MOVE_DIRECTION_UNKNOWN" : 0;
                object.streetName = "";
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = $root.osi3.Identifier.toObject(message.id, options);
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.osi3.LogicalLane.Type[message.type] === undefined ? message.type : $root.osi3.LogicalLane.Type[message.type] : message.type;
            if (message.sourceReference && message.sourceReference.length) {
                object.sourceReference = [];
                for (let j = 0; j < message.sourceReference.length; ++j)
                    object.sourceReference[j] = $root.osi3.ExternalReference.toObject(message.sourceReference[j], options);
            }
            if (message.physicalLaneReference && message.physicalLaneReference.length) {
                object.physicalLaneReference = [];
                for (let j = 0; j < message.physicalLaneReference.length; ++j)
                    object.physicalLaneReference[j] = $root.osi3.LogicalLane.PhysicalLaneReference.toObject(message.physicalLaneReference[j], options);
            }
            if (message.referenceLineId != null && message.hasOwnProperty("referenceLineId"))
                object.referenceLineId = $root.osi3.Identifier.toObject(message.referenceLineId, options);
            if (message.startS != null && message.hasOwnProperty("startS"))
                object.startS = options.json && !isFinite(message.startS) ? String(message.startS) : message.startS;
            if (message.endS != null && message.hasOwnProperty("endS"))
                object.endS = options.json && !isFinite(message.endS) ? String(message.endS) : message.endS;
            if (message.moveDirection != null && message.hasOwnProperty("moveDirection"))
                object.moveDirection = options.enums === String ? $root.osi3.LogicalLane.MoveDirection[message.moveDirection] === undefined ? message.moveDirection : $root.osi3.LogicalLane.MoveDirection[message.moveDirection] : message.moveDirection;
            if (message.rightAdjacentLane && message.rightAdjacentLane.length) {
                object.rightAdjacentLane = [];
                for (let j = 0; j < message.rightAdjacentLane.length; ++j)
                    object.rightAdjacentLane[j] = $root.osi3.LogicalLane.LaneRelation.toObject(message.rightAdjacentLane[j], options);
            }
            if (message.leftAdjacentLane && message.leftAdjacentLane.length) {
                object.leftAdjacentLane = [];
                for (let j = 0; j < message.leftAdjacentLane.length; ++j)
                    object.leftAdjacentLane[j] = $root.osi3.LogicalLane.LaneRelation.toObject(message.leftAdjacentLane[j], options);
            }
            if (message.overlappingLane && message.overlappingLane.length) {
                object.overlappingLane = [];
                for (let j = 0; j < message.overlappingLane.length; ++j)
                    object.overlappingLane[j] = $root.osi3.LogicalLane.LaneRelation.toObject(message.overlappingLane[j], options);
            }
            if (message.rightBoundaryId && message.rightBoundaryId.length) {
                object.rightBoundaryId = [];
                for (let j = 0; j < message.rightBoundaryId.length; ++j)
                    object.rightBoundaryId[j] = $root.osi3.Identifier.toObject(message.rightBoundaryId[j], options);
            }
            if (message.leftBoundaryId && message.leftBoundaryId.length) {
                object.leftBoundaryId = [];
                for (let j = 0; j < message.leftBoundaryId.length; ++j)
                    object.leftBoundaryId[j] = $root.osi3.Identifier.toObject(message.leftBoundaryId[j], options);
            }
            if (message.predecessorLane && message.predecessorLane.length) {
                object.predecessorLane = [];
                for (let j = 0; j < message.predecessorLane.length; ++j)
                    object.predecessorLane[j] = $root.osi3.LogicalLane.LaneConnection.toObject(message.predecessorLane[j], options);
            }
            if (message.successorLane && message.successorLane.length) {
                object.successorLane = [];
                for (let j = 0; j < message.successorLane.length; ++j)
                    object.successorLane[j] = $root.osi3.LogicalLane.LaneConnection.toObject(message.successorLane[j], options);
            }
            if (message.streetName != null && message.hasOwnProperty("streetName"))
                object.streetName = message.streetName;
            if (message.trafficRule && message.trafficRule.length) {
                object.trafficRule = [];
                for (let j = 0; j < message.trafficRule.length; ++j)
                    object.trafficRule[j] = $root.osi3.LogicalLane.TrafficRule.toObject(message.trafficRule[j], options);
            }
            return object;
        };

        /**
         * Converts this LogicalLane to JSON.
         * @function toJSON
         * @memberof osi3.LogicalLane
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        LogicalLane.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for LogicalLane
         * @function getTypeUrl
         * @memberof osi3.LogicalLane
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        LogicalLane.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/osi3.LogicalLane";
        };

        /**
         * Type enum.
         * @name osi3.LogicalLane.Type
         * @enum {number}
         * @property {number} TYPE_UNKNOWN=0 TYPE_UNKNOWN value
         * @property {number} TYPE_OTHER=1 TYPE_OTHER value
         * @property {number} TYPE_NORMAL=2 TYPE_NORMAL value
         * @property {number} TYPE_BIKING=3 TYPE_BIKING value
         * @property {number} TYPE_SIDEWALK=4 TYPE_SIDEWALK value
         * @property {number} TYPE_PARKING=5 TYPE_PARKING value
         * @property {number} TYPE_STOP=6 TYPE_STOP value
         * @property {number} TYPE_RESTRICTED=7 TYPE_RESTRICTED value
         * @property {number} TYPE_BORDER=8 TYPE_BORDER value
         * @property {number} TYPE_SHOULDER=9 TYPE_SHOULDER value
         * @property {number} TYPE_EXIT=10 TYPE_EXIT value
         * @property {number} TYPE_ENTRY=11 TYPE_ENTRY value
         * @property {number} TYPE_ONRAMP=12 TYPE_ONRAMP value
         * @property {number} TYPE_OFFRAMP=13 TYPE_OFFRAMP value
         * @property {number} TYPE_CONNECTINGRAMP=14 TYPE_CONNECTINGRAMP value
         * @property {number} TYPE_MEDIAN=15 TYPE_MEDIAN value
         * @property {number} TYPE_CURB=16 TYPE_CURB value
         * @property {number} TYPE_RAIL=17 TYPE_RAIL value
         * @property {number} TYPE_TRAM=18 TYPE_TRAM value
         */
        LogicalLane.Type = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "TYPE_UNKNOWN"] = 0;
            values[valuesById[1] = "TYPE_OTHER"] = 1;
            values[valuesById[2] = "TYPE_NORMAL"] = 2;
            values[valuesById[3] = "TYPE_BIKING"] = 3;
            values[valuesById[4] = "TYPE_SIDEWALK"] = 4;
            values[valuesById[5] = "TYPE_PARKING"] = 5;
            values[valuesById[6] = "TYPE_STOP"] = 6;
            values[valuesById[7] = "TYPE_RESTRICTED"] = 7;
            values[valuesById[8] = "TYPE_BORDER"] = 8;
            values[valuesById[9] = "TYPE_SHOULDER"] = 9;
            values[valuesById[10] = "TYPE_EXIT"] = 10;
            values[valuesById[11] = "TYPE_ENTRY"] = 11;
            values[valuesById[12] = "TYPE_ONRAMP"] = 12;
            values[valuesById[13] = "TYPE_OFFRAMP"] = 13;
            values[valuesById[14] = "TYPE_CONNECTINGRAMP"] = 14;
            values[valuesById[15] = "TYPE_MEDIAN"] = 15;
            values[valuesById[16] = "TYPE_CURB"] = 16;
            values[valuesById[17] = "TYPE_RAIL"] = 17;
            values[valuesById[18] = "TYPE_TRAM"] = 18;
            return values;
        })();

        LogicalLane.PhysicalLaneReference = (function() {

            /**
             * Properties of a PhysicalLaneReference.
             * @memberof osi3.LogicalLane
             * @interface IPhysicalLaneReference
             * @property {osi3.IIdentifier|null} [physicalLaneId] PhysicalLaneReference physicalLaneId
             * @property {number|null} [startS] PhysicalLaneReference startS
             * @property {number|null} [endS] PhysicalLaneReference endS
             */

            /**
             * Constructs a new PhysicalLaneReference.
             * @memberof osi3.LogicalLane
             * @classdesc Represents a PhysicalLaneReference.
             * @implements IPhysicalLaneReference
             * @constructor
             * @param {osi3.LogicalLane.IPhysicalLaneReference=} [properties] Properties to set
             */
            function PhysicalLaneReference(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PhysicalLaneReference physicalLaneId.
             * @member {osi3.IIdentifier|null|undefined} physicalLaneId
             * @memberof osi3.LogicalLane.PhysicalLaneReference
             * @instance
             */
            PhysicalLaneReference.prototype.physicalLaneId = null;

            /**
             * PhysicalLaneReference startS.
             * @member {number} startS
             * @memberof osi3.LogicalLane.PhysicalLaneReference
             * @instance
             */
            PhysicalLaneReference.prototype.startS = 0;

            /**
             * PhysicalLaneReference endS.
             * @member {number} endS
             * @memberof osi3.LogicalLane.PhysicalLaneReference
             * @instance
             */
            PhysicalLaneReference.prototype.endS = 0;

            /**
             * Creates a new PhysicalLaneReference instance using the specified properties.
             * @function create
             * @memberof osi3.LogicalLane.PhysicalLaneReference
             * @static
             * @param {osi3.LogicalLane.IPhysicalLaneReference=} [properties] Properties to set
             * @returns {osi3.LogicalLane.PhysicalLaneReference} PhysicalLaneReference instance
             */
            PhysicalLaneReference.create = function create(properties) {
                return new PhysicalLaneReference(properties);
            };

            /**
             * Encodes the specified PhysicalLaneReference message. Does not implicitly {@link osi3.LogicalLane.PhysicalLaneReference.verify|verify} messages.
             * @function encode
             * @memberof osi3.LogicalLane.PhysicalLaneReference
             * @static
             * @param {osi3.LogicalLane.IPhysicalLaneReference} message PhysicalLaneReference message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PhysicalLaneReference.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.physicalLaneId != null && Object.hasOwnProperty.call(message, "physicalLaneId"))
                    $root.osi3.Identifier.encode(message.physicalLaneId, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.startS != null && Object.hasOwnProperty.call(message, "startS"))
                    writer.uint32(/* id 2, wireType 1 =*/17).double(message.startS);
                if (message.endS != null && Object.hasOwnProperty.call(message, "endS"))
                    writer.uint32(/* id 3, wireType 1 =*/25).double(message.endS);
                return writer;
            };

            /**
             * Encodes the specified PhysicalLaneReference message, length delimited. Does not implicitly {@link osi3.LogicalLane.PhysicalLaneReference.verify|verify} messages.
             * @function encodeDelimited
             * @memberof osi3.LogicalLane.PhysicalLaneReference
             * @static
             * @param {osi3.LogicalLane.IPhysicalLaneReference} message PhysicalLaneReference message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PhysicalLaneReference.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PhysicalLaneReference message from the specified reader or buffer.
             * @function decode
             * @memberof osi3.LogicalLane.PhysicalLaneReference
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {osi3.LogicalLane.PhysicalLaneReference} PhysicalLaneReference
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PhysicalLaneReference.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.osi3.LogicalLane.PhysicalLaneReference();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.physicalLaneId = $root.osi3.Identifier.decode(reader, reader.uint32());
                            break;
                        }
                    case 2: {
                            message.startS = reader.double();
                            break;
                        }
                    case 3: {
                            message.endS = reader.double();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PhysicalLaneReference message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof osi3.LogicalLane.PhysicalLaneReference
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {osi3.LogicalLane.PhysicalLaneReference} PhysicalLaneReference
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PhysicalLaneReference.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PhysicalLaneReference message.
             * @function verify
             * @memberof osi3.LogicalLane.PhysicalLaneReference
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PhysicalLaneReference.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.physicalLaneId != null && message.hasOwnProperty("physicalLaneId")) {
                    let error = $root.osi3.Identifier.verify(message.physicalLaneId);
                    if (error)
                        return "physicalLaneId." + error;
                }
                if (message.startS != null && message.hasOwnProperty("startS"))
                    if (typeof message.startS !== "number")
                        return "startS: number expected";
                if (message.endS != null && message.hasOwnProperty("endS"))
                    if (typeof message.endS !== "number")
                        return "endS: number expected";
                return null;
            };

            /**
             * Creates a PhysicalLaneReference message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof osi3.LogicalLane.PhysicalLaneReference
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {osi3.LogicalLane.PhysicalLaneReference} PhysicalLaneReference
             */
            PhysicalLaneReference.fromObject = function fromObject(object) {
                if (object instanceof $root.osi3.LogicalLane.PhysicalLaneReference)
                    return object;
                let message = new $root.osi3.LogicalLane.PhysicalLaneReference();
                if (object.physicalLaneId != null) {
                    if (typeof object.physicalLaneId !== "object")
                        throw TypeError(".osi3.LogicalLane.PhysicalLaneReference.physicalLaneId: object expected");
                    message.physicalLaneId = $root.osi3.Identifier.fromObject(object.physicalLaneId);
                }
                if (object.startS != null)
                    message.startS = Number(object.startS);
                if (object.endS != null)
                    message.endS = Number(object.endS);
                return message;
            };

            /**
             * Creates a plain object from a PhysicalLaneReference message. Also converts values to other types if specified.
             * @function toObject
             * @memberof osi3.LogicalLane.PhysicalLaneReference
             * @static
             * @param {osi3.LogicalLane.PhysicalLaneReference} message PhysicalLaneReference
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PhysicalLaneReference.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.physicalLaneId = null;
                    object.startS = 0;
                    object.endS = 0;
                }
                if (message.physicalLaneId != null && message.hasOwnProperty("physicalLaneId"))
                    object.physicalLaneId = $root.osi3.Identifier.toObject(message.physicalLaneId, options);
                if (message.startS != null && message.hasOwnProperty("startS"))
                    object.startS = options.json && !isFinite(message.startS) ? String(message.startS) : message.startS;
                if (message.endS != null && message.hasOwnProperty("endS"))
                    object.endS = options.json && !isFinite(message.endS) ? String(message.endS) : message.endS;
                return object;
            };

            /**
             * Converts this PhysicalLaneReference to JSON.
             * @function toJSON
             * @memberof osi3.LogicalLane.PhysicalLaneReference
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PhysicalLaneReference.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for PhysicalLaneReference
             * @function getTypeUrl
             * @memberof osi3.LogicalLane.PhysicalLaneReference
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            PhysicalLaneReference.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/osi3.LogicalLane.PhysicalLaneReference";
            };

            return PhysicalLaneReference;
        })();

        /**
         * MoveDirection enum.
         * @name osi3.LogicalLane.MoveDirection
         * @enum {number}
         * @property {number} MOVE_DIRECTION_UNKNOWN=0 MOVE_DIRECTION_UNKNOWN value
         * @property {number} MOVE_DIRECTION_OTHER=1 MOVE_DIRECTION_OTHER value
         * @property {number} MOVE_DIRECTION_INCREASING_S=2 MOVE_DIRECTION_INCREASING_S value
         * @property {number} MOVE_DIRECTION_DECREASING_S=3 MOVE_DIRECTION_DECREASING_S value
         * @property {number} MOVE_DIRECTION_BOTH_ALLOWED=4 MOVE_DIRECTION_BOTH_ALLOWED value
         */
        LogicalLane.MoveDirection = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "MOVE_DIRECTION_UNKNOWN"] = 0;
            values[valuesById[1] = "MOVE_DIRECTION_OTHER"] = 1;
            values[valuesById[2] = "MOVE_DIRECTION_INCREASING_S"] = 2;
            values[valuesById[3] = "MOVE_DIRECTION_DECREASING_S"] = 3;
            values[valuesById[4] = "MOVE_DIRECTION_BOTH_ALLOWED"] = 4;
            return values;
        })();

        LogicalLane.LaneConnection = (function() {

            /**
             * Properties of a LaneConnection.
             * @memberof osi3.LogicalLane
             * @interface ILaneConnection
             * @property {osi3.IIdentifier|null} [otherLaneId] LaneConnection otherLaneId
             * @property {boolean|null} [atBeginOfOtherLane] LaneConnection atBeginOfOtherLane
             */

            /**
             * Constructs a new LaneConnection.
             * @memberof osi3.LogicalLane
             * @classdesc Represents a LaneConnection.
             * @implements ILaneConnection
             * @constructor
             * @param {osi3.LogicalLane.ILaneConnection=} [properties] Properties to set
             */
            function LaneConnection(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * LaneConnection otherLaneId.
             * @member {osi3.IIdentifier|null|undefined} otherLaneId
             * @memberof osi3.LogicalLane.LaneConnection
             * @instance
             */
            LaneConnection.prototype.otherLaneId = null;

            /**
             * LaneConnection atBeginOfOtherLane.
             * @member {boolean} atBeginOfOtherLane
             * @memberof osi3.LogicalLane.LaneConnection
             * @instance
             */
            LaneConnection.prototype.atBeginOfOtherLane = false;

            /**
             * Creates a new LaneConnection instance using the specified properties.
             * @function create
             * @memberof osi3.LogicalLane.LaneConnection
             * @static
             * @param {osi3.LogicalLane.ILaneConnection=} [properties] Properties to set
             * @returns {osi3.LogicalLane.LaneConnection} LaneConnection instance
             */
            LaneConnection.create = function create(properties) {
                return new LaneConnection(properties);
            };

            /**
             * Encodes the specified LaneConnection message. Does not implicitly {@link osi3.LogicalLane.LaneConnection.verify|verify} messages.
             * @function encode
             * @memberof osi3.LogicalLane.LaneConnection
             * @static
             * @param {osi3.LogicalLane.ILaneConnection} message LaneConnection message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LaneConnection.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.otherLaneId != null && Object.hasOwnProperty.call(message, "otherLaneId"))
                    $root.osi3.Identifier.encode(message.otherLaneId, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.atBeginOfOtherLane != null && Object.hasOwnProperty.call(message, "atBeginOfOtherLane"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.atBeginOfOtherLane);
                return writer;
            };

            /**
             * Encodes the specified LaneConnection message, length delimited. Does not implicitly {@link osi3.LogicalLane.LaneConnection.verify|verify} messages.
             * @function encodeDelimited
             * @memberof osi3.LogicalLane.LaneConnection
             * @static
             * @param {osi3.LogicalLane.ILaneConnection} message LaneConnection message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LaneConnection.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a LaneConnection message from the specified reader or buffer.
             * @function decode
             * @memberof osi3.LogicalLane.LaneConnection
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {osi3.LogicalLane.LaneConnection} LaneConnection
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LaneConnection.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.osi3.LogicalLane.LaneConnection();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.otherLaneId = $root.osi3.Identifier.decode(reader, reader.uint32());
                            break;
                        }
                    case 2: {
                            message.atBeginOfOtherLane = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a LaneConnection message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof osi3.LogicalLane.LaneConnection
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {osi3.LogicalLane.LaneConnection} LaneConnection
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LaneConnection.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a LaneConnection message.
             * @function verify
             * @memberof osi3.LogicalLane.LaneConnection
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            LaneConnection.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.otherLaneId != null && message.hasOwnProperty("otherLaneId")) {
                    let error = $root.osi3.Identifier.verify(message.otherLaneId);
                    if (error)
                        return "otherLaneId." + error;
                }
                if (message.atBeginOfOtherLane != null && message.hasOwnProperty("atBeginOfOtherLane"))
                    if (typeof message.atBeginOfOtherLane !== "boolean")
                        return "atBeginOfOtherLane: boolean expected";
                return null;
            };

            /**
             * Creates a LaneConnection message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof osi3.LogicalLane.LaneConnection
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {osi3.LogicalLane.LaneConnection} LaneConnection
             */
            LaneConnection.fromObject = function fromObject(object) {
                if (object instanceof $root.osi3.LogicalLane.LaneConnection)
                    return object;
                let message = new $root.osi3.LogicalLane.LaneConnection();
                if (object.otherLaneId != null) {
                    if (typeof object.otherLaneId !== "object")
                        throw TypeError(".osi3.LogicalLane.LaneConnection.otherLaneId: object expected");
                    message.otherLaneId = $root.osi3.Identifier.fromObject(object.otherLaneId);
                }
                if (object.atBeginOfOtherLane != null)
                    message.atBeginOfOtherLane = Boolean(object.atBeginOfOtherLane);
                return message;
            };

            /**
             * Creates a plain object from a LaneConnection message. Also converts values to other types if specified.
             * @function toObject
             * @memberof osi3.LogicalLane.LaneConnection
             * @static
             * @param {osi3.LogicalLane.LaneConnection} message LaneConnection
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            LaneConnection.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.otherLaneId = null;
                    object.atBeginOfOtherLane = false;
                }
                if (message.otherLaneId != null && message.hasOwnProperty("otherLaneId"))
                    object.otherLaneId = $root.osi3.Identifier.toObject(message.otherLaneId, options);
                if (message.atBeginOfOtherLane != null && message.hasOwnProperty("atBeginOfOtherLane"))
                    object.atBeginOfOtherLane = message.atBeginOfOtherLane;
                return object;
            };

            /**
             * Converts this LaneConnection to JSON.
             * @function toJSON
             * @memberof osi3.LogicalLane.LaneConnection
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            LaneConnection.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for LaneConnection
             * @function getTypeUrl
             * @memberof osi3.LogicalLane.LaneConnection
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            LaneConnection.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/osi3.LogicalLane.LaneConnection";
            };

            return LaneConnection;
        })();

        LogicalLane.LaneRelation = (function() {

            /**
             * Properties of a LaneRelation.
             * @memberof osi3.LogicalLane
             * @interface ILaneRelation
             * @property {osi3.IIdentifier|null} [otherLaneId] LaneRelation otherLaneId
             * @property {number|null} [startS] LaneRelation startS
             * @property {number|null} [endS] LaneRelation endS
             * @property {number|null} [startSOther] LaneRelation startSOther
             * @property {number|null} [endSOther] LaneRelation endSOther
             */

            /**
             * Constructs a new LaneRelation.
             * @memberof osi3.LogicalLane
             * @classdesc Represents a LaneRelation.
             * @implements ILaneRelation
             * @constructor
             * @param {osi3.LogicalLane.ILaneRelation=} [properties] Properties to set
             */
            function LaneRelation(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * LaneRelation otherLaneId.
             * @member {osi3.IIdentifier|null|undefined} otherLaneId
             * @memberof osi3.LogicalLane.LaneRelation
             * @instance
             */
            LaneRelation.prototype.otherLaneId = null;

            /**
             * LaneRelation startS.
             * @member {number} startS
             * @memberof osi3.LogicalLane.LaneRelation
             * @instance
             */
            LaneRelation.prototype.startS = 0;

            /**
             * LaneRelation endS.
             * @member {number} endS
             * @memberof osi3.LogicalLane.LaneRelation
             * @instance
             */
            LaneRelation.prototype.endS = 0;

            /**
             * LaneRelation startSOther.
             * @member {number} startSOther
             * @memberof osi3.LogicalLane.LaneRelation
             * @instance
             */
            LaneRelation.prototype.startSOther = 0;

            /**
             * LaneRelation endSOther.
             * @member {number} endSOther
             * @memberof osi3.LogicalLane.LaneRelation
             * @instance
             */
            LaneRelation.prototype.endSOther = 0;

            /**
             * Creates a new LaneRelation instance using the specified properties.
             * @function create
             * @memberof osi3.LogicalLane.LaneRelation
             * @static
             * @param {osi3.LogicalLane.ILaneRelation=} [properties] Properties to set
             * @returns {osi3.LogicalLane.LaneRelation} LaneRelation instance
             */
            LaneRelation.create = function create(properties) {
                return new LaneRelation(properties);
            };

            /**
             * Encodes the specified LaneRelation message. Does not implicitly {@link osi3.LogicalLane.LaneRelation.verify|verify} messages.
             * @function encode
             * @memberof osi3.LogicalLane.LaneRelation
             * @static
             * @param {osi3.LogicalLane.ILaneRelation} message LaneRelation message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LaneRelation.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.otherLaneId != null && Object.hasOwnProperty.call(message, "otherLaneId"))
                    $root.osi3.Identifier.encode(message.otherLaneId, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.startS != null && Object.hasOwnProperty.call(message, "startS"))
                    writer.uint32(/* id 2, wireType 1 =*/17).double(message.startS);
                if (message.endS != null && Object.hasOwnProperty.call(message, "endS"))
                    writer.uint32(/* id 3, wireType 1 =*/25).double(message.endS);
                if (message.startSOther != null && Object.hasOwnProperty.call(message, "startSOther"))
                    writer.uint32(/* id 4, wireType 1 =*/33).double(message.startSOther);
                if (message.endSOther != null && Object.hasOwnProperty.call(message, "endSOther"))
                    writer.uint32(/* id 5, wireType 1 =*/41).double(message.endSOther);
                return writer;
            };

            /**
             * Encodes the specified LaneRelation message, length delimited. Does not implicitly {@link osi3.LogicalLane.LaneRelation.verify|verify} messages.
             * @function encodeDelimited
             * @memberof osi3.LogicalLane.LaneRelation
             * @static
             * @param {osi3.LogicalLane.ILaneRelation} message LaneRelation message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LaneRelation.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a LaneRelation message from the specified reader or buffer.
             * @function decode
             * @memberof osi3.LogicalLane.LaneRelation
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {osi3.LogicalLane.LaneRelation} LaneRelation
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LaneRelation.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.osi3.LogicalLane.LaneRelation();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.otherLaneId = $root.osi3.Identifier.decode(reader, reader.uint32());
                            break;
                        }
                    case 2: {
                            message.startS = reader.double();
                            break;
                        }
                    case 3: {
                            message.endS = reader.double();
                            break;
                        }
                    case 4: {
                            message.startSOther = reader.double();
                            break;
                        }
                    case 5: {
                            message.endSOther = reader.double();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a LaneRelation message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof osi3.LogicalLane.LaneRelation
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {osi3.LogicalLane.LaneRelation} LaneRelation
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LaneRelation.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a LaneRelation message.
             * @function verify
             * @memberof osi3.LogicalLane.LaneRelation
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            LaneRelation.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.otherLaneId != null && message.hasOwnProperty("otherLaneId")) {
                    let error = $root.osi3.Identifier.verify(message.otherLaneId);
                    if (error)
                        return "otherLaneId." + error;
                }
                if (message.startS != null && message.hasOwnProperty("startS"))
                    if (typeof message.startS !== "number")
                        return "startS: number expected";
                if (message.endS != null && message.hasOwnProperty("endS"))
                    if (typeof message.endS !== "number")
                        return "endS: number expected";
                if (message.startSOther != null && message.hasOwnProperty("startSOther"))
                    if (typeof message.startSOther !== "number")
                        return "startSOther: number expected";
                if (message.endSOther != null && message.hasOwnProperty("endSOther"))
                    if (typeof message.endSOther !== "number")
                        return "endSOther: number expected";
                return null;
            };

            /**
             * Creates a LaneRelation message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof osi3.LogicalLane.LaneRelation
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {osi3.LogicalLane.LaneRelation} LaneRelation
             */
            LaneRelation.fromObject = function fromObject(object) {
                if (object instanceof $root.osi3.LogicalLane.LaneRelation)
                    return object;
                let message = new $root.osi3.LogicalLane.LaneRelation();
                if (object.otherLaneId != null) {
                    if (typeof object.otherLaneId !== "object")
                        throw TypeError(".osi3.LogicalLane.LaneRelation.otherLaneId: object expected");
                    message.otherLaneId = $root.osi3.Identifier.fromObject(object.otherLaneId);
                }
                if (object.startS != null)
                    message.startS = Number(object.startS);
                if (object.endS != null)
                    message.endS = Number(object.endS);
                if (object.startSOther != null)
                    message.startSOther = Number(object.startSOther);
                if (object.endSOther != null)
                    message.endSOther = Number(object.endSOther);
                return message;
            };

            /**
             * Creates a plain object from a LaneRelation message. Also converts values to other types if specified.
             * @function toObject
             * @memberof osi3.LogicalLane.LaneRelation
             * @static
             * @param {osi3.LogicalLane.LaneRelation} message LaneRelation
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            LaneRelation.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.otherLaneId = null;
                    object.startS = 0;
                    object.endS = 0;
                    object.startSOther = 0;
                    object.endSOther = 0;
                }
                if (message.otherLaneId != null && message.hasOwnProperty("otherLaneId"))
                    object.otherLaneId = $root.osi3.Identifier.toObject(message.otherLaneId, options);
                if (message.startS != null && message.hasOwnProperty("startS"))
                    object.startS = options.json && !isFinite(message.startS) ? String(message.startS) : message.startS;
                if (message.endS != null && message.hasOwnProperty("endS"))
                    object.endS = options.json && !isFinite(message.endS) ? String(message.endS) : message.endS;
                if (message.startSOther != null && message.hasOwnProperty("startSOther"))
                    object.startSOther = options.json && !isFinite(message.startSOther) ? String(message.startSOther) : message.startSOther;
                if (message.endSOther != null && message.hasOwnProperty("endSOther"))
                    object.endSOther = options.json && !isFinite(message.endSOther) ? String(message.endSOther) : message.endSOther;
                return object;
            };

            /**
             * Converts this LaneRelation to JSON.
             * @function toJSON
             * @memberof osi3.LogicalLane.LaneRelation
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            LaneRelation.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for LaneRelation
             * @function getTypeUrl
             * @memberof osi3.LogicalLane.LaneRelation
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            LaneRelation.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/osi3.LogicalLane.LaneRelation";
            };

            return LaneRelation;
        })();

        LogicalLane.TrafficRule = (function() {

            /**
             * Properties of a TrafficRule.
             * @memberof osi3.LogicalLane
             * @interface ITrafficRule
             * @property {osi3.LogicalLane.TrafficRule.TrafficRuleType|null} [trafficRuleType] TrafficRule trafficRuleType
             * @property {osi3.LogicalLane.TrafficRule.ITrafficRuleValidity|null} [trafficRuleValidity] TrafficRule trafficRuleValidity
             * @property {osi3.LogicalLane.TrafficRule.ISpeedLimit|null} [speedLimit] TrafficRule speedLimit
             */

            /**
             * Constructs a new TrafficRule.
             * @memberof osi3.LogicalLane
             * @classdesc Represents a TrafficRule.
             * @implements ITrafficRule
             * @constructor
             * @param {osi3.LogicalLane.ITrafficRule=} [properties] Properties to set
             */
            function TrafficRule(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TrafficRule trafficRuleType.
             * @member {osi3.LogicalLane.TrafficRule.TrafficRuleType} trafficRuleType
             * @memberof osi3.LogicalLane.TrafficRule
             * @instance
             */
            TrafficRule.prototype.trafficRuleType = 0;

            /**
             * TrafficRule trafficRuleValidity.
             * @member {osi3.LogicalLane.TrafficRule.ITrafficRuleValidity|null|undefined} trafficRuleValidity
             * @memberof osi3.LogicalLane.TrafficRule
             * @instance
             */
            TrafficRule.prototype.trafficRuleValidity = null;

            /**
             * TrafficRule speedLimit.
             * @member {osi3.LogicalLane.TrafficRule.ISpeedLimit|null|undefined} speedLimit
             * @memberof osi3.LogicalLane.TrafficRule
             * @instance
             */
            TrafficRule.prototype.speedLimit = null;

            /**
             * Creates a new TrafficRule instance using the specified properties.
             * @function create
             * @memberof osi3.LogicalLane.TrafficRule
             * @static
             * @param {osi3.LogicalLane.ITrafficRule=} [properties] Properties to set
             * @returns {osi3.LogicalLane.TrafficRule} TrafficRule instance
             */
            TrafficRule.create = function create(properties) {
                return new TrafficRule(properties);
            };

            /**
             * Encodes the specified TrafficRule message. Does not implicitly {@link osi3.LogicalLane.TrafficRule.verify|verify} messages.
             * @function encode
             * @memberof osi3.LogicalLane.TrafficRule
             * @static
             * @param {osi3.LogicalLane.ITrafficRule} message TrafficRule message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TrafficRule.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.trafficRuleType != null && Object.hasOwnProperty.call(message, "trafficRuleType"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.trafficRuleType);
                if (message.trafficRuleValidity != null && Object.hasOwnProperty.call(message, "trafficRuleValidity"))
                    $root.osi3.LogicalLane.TrafficRule.TrafficRuleValidity.encode(message.trafficRuleValidity, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.speedLimit != null && Object.hasOwnProperty.call(message, "speedLimit"))
                    $root.osi3.LogicalLane.TrafficRule.SpeedLimit.encode(message.speedLimit, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified TrafficRule message, length delimited. Does not implicitly {@link osi3.LogicalLane.TrafficRule.verify|verify} messages.
             * @function encodeDelimited
             * @memberof osi3.LogicalLane.TrafficRule
             * @static
             * @param {osi3.LogicalLane.ITrafficRule} message TrafficRule message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TrafficRule.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a TrafficRule message from the specified reader or buffer.
             * @function decode
             * @memberof osi3.LogicalLane.TrafficRule
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {osi3.LogicalLane.TrafficRule} TrafficRule
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TrafficRule.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.osi3.LogicalLane.TrafficRule();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.trafficRuleType = reader.int32();
                            break;
                        }
                    case 2: {
                            message.trafficRuleValidity = $root.osi3.LogicalLane.TrafficRule.TrafficRuleValidity.decode(reader, reader.uint32());
                            break;
                        }
                    case 3: {
                            message.speedLimit = $root.osi3.LogicalLane.TrafficRule.SpeedLimit.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a TrafficRule message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof osi3.LogicalLane.TrafficRule
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {osi3.LogicalLane.TrafficRule} TrafficRule
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TrafficRule.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a TrafficRule message.
             * @function verify
             * @memberof osi3.LogicalLane.TrafficRule
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TrafficRule.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.trafficRuleType != null && message.hasOwnProperty("trafficRuleType"))
                    switch (message.trafficRuleType) {
                    default:
                        return "trafficRuleType: enum value expected";
                    case 0:
                        break;
                    }
                if (message.trafficRuleValidity != null && message.hasOwnProperty("trafficRuleValidity")) {
                    let error = $root.osi3.LogicalLane.TrafficRule.TrafficRuleValidity.verify(message.trafficRuleValidity);
                    if (error)
                        return "trafficRuleValidity." + error;
                }
                if (message.speedLimit != null && message.hasOwnProperty("speedLimit")) {
                    let error = $root.osi3.LogicalLane.TrafficRule.SpeedLimit.verify(message.speedLimit);
                    if (error)
                        return "speedLimit." + error;
                }
                return null;
            };

            /**
             * Creates a TrafficRule message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof osi3.LogicalLane.TrafficRule
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {osi3.LogicalLane.TrafficRule} TrafficRule
             */
            TrafficRule.fromObject = function fromObject(object) {
                if (object instanceof $root.osi3.LogicalLane.TrafficRule)
                    return object;
                let message = new $root.osi3.LogicalLane.TrafficRule();
                switch (object.trafficRuleType) {
                default:
                    if (typeof object.trafficRuleType === "number") {
                        message.trafficRuleType = object.trafficRuleType;
                        break;
                    }
                    break;
                case "TRAFFIC_RULE_TYPE_SPEED_LIMIT":
                case 0:
                    message.trafficRuleType = 0;
                    break;
                }
                if (object.trafficRuleValidity != null) {
                    if (typeof object.trafficRuleValidity !== "object")
                        throw TypeError(".osi3.LogicalLane.TrafficRule.trafficRuleValidity: object expected");
                    message.trafficRuleValidity = $root.osi3.LogicalLane.TrafficRule.TrafficRuleValidity.fromObject(object.trafficRuleValidity);
                }
                if (object.speedLimit != null) {
                    if (typeof object.speedLimit !== "object")
                        throw TypeError(".osi3.LogicalLane.TrafficRule.speedLimit: object expected");
                    message.speedLimit = $root.osi3.LogicalLane.TrafficRule.SpeedLimit.fromObject(object.speedLimit);
                }
                return message;
            };

            /**
             * Creates a plain object from a TrafficRule message. Also converts values to other types if specified.
             * @function toObject
             * @memberof osi3.LogicalLane.TrafficRule
             * @static
             * @param {osi3.LogicalLane.TrafficRule} message TrafficRule
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TrafficRule.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.trafficRuleType = options.enums === String ? "TRAFFIC_RULE_TYPE_SPEED_LIMIT" : 0;
                    object.trafficRuleValidity = null;
                    object.speedLimit = null;
                }
                if (message.trafficRuleType != null && message.hasOwnProperty("trafficRuleType"))
                    object.trafficRuleType = options.enums === String ? $root.osi3.LogicalLane.TrafficRule.TrafficRuleType[message.trafficRuleType] === undefined ? message.trafficRuleType : $root.osi3.LogicalLane.TrafficRule.TrafficRuleType[message.trafficRuleType] : message.trafficRuleType;
                if (message.trafficRuleValidity != null && message.hasOwnProperty("trafficRuleValidity"))
                    object.trafficRuleValidity = $root.osi3.LogicalLane.TrafficRule.TrafficRuleValidity.toObject(message.trafficRuleValidity, options);
                if (message.speedLimit != null && message.hasOwnProperty("speedLimit"))
                    object.speedLimit = $root.osi3.LogicalLane.TrafficRule.SpeedLimit.toObject(message.speedLimit, options);
                return object;
            };

            /**
             * Converts this TrafficRule to JSON.
             * @function toJSON
             * @memberof osi3.LogicalLane.TrafficRule
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TrafficRule.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for TrafficRule
             * @function getTypeUrl
             * @memberof osi3.LogicalLane.TrafficRule
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            TrafficRule.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/osi3.LogicalLane.TrafficRule";
            };

            /**
             * TrafficRuleType enum.
             * @name osi3.LogicalLane.TrafficRule.TrafficRuleType
             * @enum {number}
             * @property {number} TRAFFIC_RULE_TYPE_SPEED_LIMIT=0 TRAFFIC_RULE_TYPE_SPEED_LIMIT value
             */
            TrafficRule.TrafficRuleType = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "TRAFFIC_RULE_TYPE_SPEED_LIMIT"] = 0;
                return values;
            })();

            TrafficRule.TrafficRuleValidity = (function() {

                /**
                 * Properties of a TrafficRuleValidity.
                 * @memberof osi3.LogicalLane.TrafficRule
                 * @interface ITrafficRuleValidity
                 * @property {number|null} [startS] TrafficRuleValidity startS
                 * @property {number|null} [endS] TrafficRuleValidity endS
                 * @property {Array.<osi3.LogicalLane.TrafficRule.TrafficRuleValidity.ITypeValidity>|null} [validForType] TrafficRuleValidity validForType
                 */

                /**
                 * Constructs a new TrafficRuleValidity.
                 * @memberof osi3.LogicalLane.TrafficRule
                 * @classdesc Represents a TrafficRuleValidity.
                 * @implements ITrafficRuleValidity
                 * @constructor
                 * @param {osi3.LogicalLane.TrafficRule.ITrafficRuleValidity=} [properties] Properties to set
                 */
                function TrafficRuleValidity(properties) {
                    this.validForType = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * TrafficRuleValidity startS.
                 * @member {number} startS
                 * @memberof osi3.LogicalLane.TrafficRule.TrafficRuleValidity
                 * @instance
                 */
                TrafficRuleValidity.prototype.startS = 0;

                /**
                 * TrafficRuleValidity endS.
                 * @member {number} endS
                 * @memberof osi3.LogicalLane.TrafficRule.TrafficRuleValidity
                 * @instance
                 */
                TrafficRuleValidity.prototype.endS = 0;

                /**
                 * TrafficRuleValidity validForType.
                 * @member {Array.<osi3.LogicalLane.TrafficRule.TrafficRuleValidity.ITypeValidity>} validForType
                 * @memberof osi3.LogicalLane.TrafficRule.TrafficRuleValidity
                 * @instance
                 */
                TrafficRuleValidity.prototype.validForType = $util.emptyArray;

                /**
                 * Creates a new TrafficRuleValidity instance using the specified properties.
                 * @function create
                 * @memberof osi3.LogicalLane.TrafficRule.TrafficRuleValidity
                 * @static
                 * @param {osi3.LogicalLane.TrafficRule.ITrafficRuleValidity=} [properties] Properties to set
                 * @returns {osi3.LogicalLane.TrafficRule.TrafficRuleValidity} TrafficRuleValidity instance
                 */
                TrafficRuleValidity.create = function create(properties) {
                    return new TrafficRuleValidity(properties);
                };

                /**
                 * Encodes the specified TrafficRuleValidity message. Does not implicitly {@link osi3.LogicalLane.TrafficRule.TrafficRuleValidity.verify|verify} messages.
                 * @function encode
                 * @memberof osi3.LogicalLane.TrafficRule.TrafficRuleValidity
                 * @static
                 * @param {osi3.LogicalLane.TrafficRule.ITrafficRuleValidity} message TrafficRuleValidity message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TrafficRuleValidity.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.startS != null && Object.hasOwnProperty.call(message, "startS"))
                        writer.uint32(/* id 1, wireType 1 =*/9).double(message.startS);
                    if (message.endS != null && Object.hasOwnProperty.call(message, "endS"))
                        writer.uint32(/* id 2, wireType 1 =*/17).double(message.endS);
                    if (message.validForType != null && message.validForType.length)
                        for (let i = 0; i < message.validForType.length; ++i)
                            $root.osi3.LogicalLane.TrafficRule.TrafficRuleValidity.TypeValidity.encode(message.validForType[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified TrafficRuleValidity message, length delimited. Does not implicitly {@link osi3.LogicalLane.TrafficRule.TrafficRuleValidity.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof osi3.LogicalLane.TrafficRule.TrafficRuleValidity
                 * @static
                 * @param {osi3.LogicalLane.TrafficRule.ITrafficRuleValidity} message TrafficRuleValidity message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TrafficRuleValidity.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a TrafficRuleValidity message from the specified reader or buffer.
                 * @function decode
                 * @memberof osi3.LogicalLane.TrafficRule.TrafficRuleValidity
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {osi3.LogicalLane.TrafficRule.TrafficRuleValidity} TrafficRuleValidity
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TrafficRuleValidity.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.osi3.LogicalLane.TrafficRule.TrafficRuleValidity();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                message.startS = reader.double();
                                break;
                            }
                        case 2: {
                                message.endS = reader.double();
                                break;
                            }
                        case 3: {
                                if (!(message.validForType && message.validForType.length))
                                    message.validForType = [];
                                message.validForType.push($root.osi3.LogicalLane.TrafficRule.TrafficRuleValidity.TypeValidity.decode(reader, reader.uint32()));
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a TrafficRuleValidity message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof osi3.LogicalLane.TrafficRule.TrafficRuleValidity
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {osi3.LogicalLane.TrafficRule.TrafficRuleValidity} TrafficRuleValidity
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TrafficRuleValidity.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a TrafficRuleValidity message.
                 * @function verify
                 * @memberof osi3.LogicalLane.TrafficRule.TrafficRuleValidity
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                TrafficRuleValidity.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.startS != null && message.hasOwnProperty("startS"))
                        if (typeof message.startS !== "number")
                            return "startS: number expected";
                    if (message.endS != null && message.hasOwnProperty("endS"))
                        if (typeof message.endS !== "number")
                            return "endS: number expected";
                    if (message.validForType != null && message.hasOwnProperty("validForType")) {
                        if (!Array.isArray(message.validForType))
                            return "validForType: array expected";
                        for (let i = 0; i < message.validForType.length; ++i) {
                            let error = $root.osi3.LogicalLane.TrafficRule.TrafficRuleValidity.TypeValidity.verify(message.validForType[i]);
                            if (error)
                                return "validForType." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a TrafficRuleValidity message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof osi3.LogicalLane.TrafficRule.TrafficRuleValidity
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {osi3.LogicalLane.TrafficRule.TrafficRuleValidity} TrafficRuleValidity
                 */
                TrafficRuleValidity.fromObject = function fromObject(object) {
                    if (object instanceof $root.osi3.LogicalLane.TrafficRule.TrafficRuleValidity)
                        return object;
                    let message = new $root.osi3.LogicalLane.TrafficRule.TrafficRuleValidity();
                    if (object.startS != null)
                        message.startS = Number(object.startS);
                    if (object.endS != null)
                        message.endS = Number(object.endS);
                    if (object.validForType) {
                        if (!Array.isArray(object.validForType))
                            throw TypeError(".osi3.LogicalLane.TrafficRule.TrafficRuleValidity.validForType: array expected");
                        message.validForType = [];
                        for (let i = 0; i < object.validForType.length; ++i) {
                            if (typeof object.validForType[i] !== "object")
                                throw TypeError(".osi3.LogicalLane.TrafficRule.TrafficRuleValidity.validForType: object expected");
                            message.validForType[i] = $root.osi3.LogicalLane.TrafficRule.TrafficRuleValidity.TypeValidity.fromObject(object.validForType[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a TrafficRuleValidity message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof osi3.LogicalLane.TrafficRule.TrafficRuleValidity
                 * @static
                 * @param {osi3.LogicalLane.TrafficRule.TrafficRuleValidity} message TrafficRuleValidity
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                TrafficRuleValidity.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.validForType = [];
                    if (options.defaults) {
                        object.startS = 0;
                        object.endS = 0;
                    }
                    if (message.startS != null && message.hasOwnProperty("startS"))
                        object.startS = options.json && !isFinite(message.startS) ? String(message.startS) : message.startS;
                    if (message.endS != null && message.hasOwnProperty("endS"))
                        object.endS = options.json && !isFinite(message.endS) ? String(message.endS) : message.endS;
                    if (message.validForType && message.validForType.length) {
                        object.validForType = [];
                        for (let j = 0; j < message.validForType.length; ++j)
                            object.validForType[j] = $root.osi3.LogicalLane.TrafficRule.TrafficRuleValidity.TypeValidity.toObject(message.validForType[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this TrafficRuleValidity to JSON.
                 * @function toJSON
                 * @memberof osi3.LogicalLane.TrafficRule.TrafficRuleValidity
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                TrafficRuleValidity.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for TrafficRuleValidity
                 * @function getTypeUrl
                 * @memberof osi3.LogicalLane.TrafficRule.TrafficRuleValidity
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                TrafficRuleValidity.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/osi3.LogicalLane.TrafficRule.TrafficRuleValidity";
                };

                TrafficRuleValidity.TypeValidity = (function() {

                    /**
                     * Properties of a TypeValidity.
                     * @memberof osi3.LogicalLane.TrafficRule.TrafficRuleValidity
                     * @interface ITypeValidity
                     * @property {osi3.MovingObject.Type|null} [type] TypeValidity type
                     * @property {osi3.MovingObject.VehicleClassification.Type|null} [vehicleType] TypeValidity vehicleType
                     * @property {osi3.MovingObject.VehicleClassification.Role|null} [vehicleRole] TypeValidity vehicleRole
                     */

                    /**
                     * Constructs a new TypeValidity.
                     * @memberof osi3.LogicalLane.TrafficRule.TrafficRuleValidity
                     * @classdesc Represents a TypeValidity.
                     * @implements ITypeValidity
                     * @constructor
                     * @param {osi3.LogicalLane.TrafficRule.TrafficRuleValidity.ITypeValidity=} [properties] Properties to set
                     */
                    function TypeValidity(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * TypeValidity type.
                     * @member {osi3.MovingObject.Type} type
                     * @memberof osi3.LogicalLane.TrafficRule.TrafficRuleValidity.TypeValidity
                     * @instance
                     */
                    TypeValidity.prototype.type = 0;

                    /**
                     * TypeValidity vehicleType.
                     * @member {osi3.MovingObject.VehicleClassification.Type} vehicleType
                     * @memberof osi3.LogicalLane.TrafficRule.TrafficRuleValidity.TypeValidity
                     * @instance
                     */
                    TypeValidity.prototype.vehicleType = 0;

                    /**
                     * TypeValidity vehicleRole.
                     * @member {osi3.MovingObject.VehicleClassification.Role} vehicleRole
                     * @memberof osi3.LogicalLane.TrafficRule.TrafficRuleValidity.TypeValidity
                     * @instance
                     */
                    TypeValidity.prototype.vehicleRole = 0;

                    /**
                     * Creates a new TypeValidity instance using the specified properties.
                     * @function create
                     * @memberof osi3.LogicalLane.TrafficRule.TrafficRuleValidity.TypeValidity
                     * @static
                     * @param {osi3.LogicalLane.TrafficRule.TrafficRuleValidity.ITypeValidity=} [properties] Properties to set
                     * @returns {osi3.LogicalLane.TrafficRule.TrafficRuleValidity.TypeValidity} TypeValidity instance
                     */
                    TypeValidity.create = function create(properties) {
                        return new TypeValidity(properties);
                    };

                    /**
                     * Encodes the specified TypeValidity message. Does not implicitly {@link osi3.LogicalLane.TrafficRule.TrafficRuleValidity.TypeValidity.verify|verify} messages.
                     * @function encode
                     * @memberof osi3.LogicalLane.TrafficRule.TrafficRuleValidity.TypeValidity
                     * @static
                     * @param {osi3.LogicalLane.TrafficRule.TrafficRuleValidity.ITypeValidity} message TypeValidity message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    TypeValidity.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                        if (message.vehicleType != null && Object.hasOwnProperty.call(message, "vehicleType"))
                            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.vehicleType);
                        if (message.vehicleRole != null && Object.hasOwnProperty.call(message, "vehicleRole"))
                            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.vehicleRole);
                        return writer;
                    };

                    /**
                     * Encodes the specified TypeValidity message, length delimited. Does not implicitly {@link osi3.LogicalLane.TrafficRule.TrafficRuleValidity.TypeValidity.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof osi3.LogicalLane.TrafficRule.TrafficRuleValidity.TypeValidity
                     * @static
                     * @param {osi3.LogicalLane.TrafficRule.TrafficRuleValidity.ITypeValidity} message TypeValidity message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    TypeValidity.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a TypeValidity message from the specified reader or buffer.
                     * @function decode
                     * @memberof osi3.LogicalLane.TrafficRule.TrafficRuleValidity.TypeValidity
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {osi3.LogicalLane.TrafficRule.TrafficRuleValidity.TypeValidity} TypeValidity
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    TypeValidity.decode = function decode(reader, length, error) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.osi3.LogicalLane.TrafficRule.TrafficRuleValidity.TypeValidity();
                        while (reader.pos < end) {
                            let tag = reader.uint32();
                            if (tag === error)
                                break;
                            switch (tag >>> 3) {
                            case 1: {
                                    message.type = reader.int32();
                                    break;
                                }
                            case 2: {
                                    message.vehicleType = reader.int32();
                                    break;
                                }
                            case 3: {
                                    message.vehicleRole = reader.int32();
                                    break;
                                }
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a TypeValidity message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof osi3.LogicalLane.TrafficRule.TrafficRuleValidity.TypeValidity
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {osi3.LogicalLane.TrafficRule.TrafficRuleValidity.TypeValidity} TypeValidity
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    TypeValidity.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a TypeValidity message.
                     * @function verify
                     * @memberof osi3.LogicalLane.TrafficRule.TrafficRuleValidity.TypeValidity
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    TypeValidity.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.type != null && message.hasOwnProperty("type"))
                            switch (message.type) {
                            default:
                                return "type: enum value expected";
                            case 0:
                            case 1:
                            case 2:
                            case 3:
                            case 4:
                                break;
                            }
                        if (message.vehicleType != null && message.hasOwnProperty("vehicleType"))
                            switch (message.vehicleType) {
                            default:
                                return "vehicleType: enum value expected";
                            case 0:
                            case 1:
                            case 2:
                            case 3:
                            case 4:
                            case 4:
                            case 5:
                            case 6:
                            case 7:
                            case 16:
                            case 8:
                            case 9:
                            case 10:
                            case 11:
                            case 12:
                            case 13:
                            case 14:
                            case 15:
                            case 17:
                                break;
                            }
                        if (message.vehicleRole != null && message.hasOwnProperty("vehicleRole"))
                            switch (message.vehicleRole) {
                            default:
                                return "vehicleRole: enum value expected";
                            case 0:
                            case 1:
                            case 2:
                            case 3:
                            case 4:
                            case 5:
                            case 6:
                            case 7:
                            case 8:
                            case 9:
                            case 10:
                                break;
                            }
                        return null;
                    };

                    /**
                     * Creates a TypeValidity message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof osi3.LogicalLane.TrafficRule.TrafficRuleValidity.TypeValidity
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {osi3.LogicalLane.TrafficRule.TrafficRuleValidity.TypeValidity} TypeValidity
                     */
                    TypeValidity.fromObject = function fromObject(object) {
                        if (object instanceof $root.osi3.LogicalLane.TrafficRule.TrafficRuleValidity.TypeValidity)
                            return object;
                        let message = new $root.osi3.LogicalLane.TrafficRule.TrafficRuleValidity.TypeValidity();
                        switch (object.type) {
                        default:
                            if (typeof object.type === "number") {
                                message.type = object.type;
                                break;
                            }
                            break;
                        case "TYPE_UNKNOWN":
                        case 0:
                            message.type = 0;
                            break;
                        case "TYPE_OTHER":
                        case 1:
                            message.type = 1;
                            break;
                        case "TYPE_VEHICLE":
                        case 2:
                            message.type = 2;
                            break;
                        case "TYPE_PEDESTRIAN":
                        case 3:
                            message.type = 3;
                            break;
                        case "TYPE_ANIMAL":
                        case 4:
                            message.type = 4;
                            break;
                        }
                        switch (object.vehicleType) {
                        default:
                            if (typeof object.vehicleType === "number") {
                                message.vehicleType = object.vehicleType;
                                break;
                            }
                            break;
                        case "TYPE_UNKNOWN":
                        case 0:
                            message.vehicleType = 0;
                            break;
                        case "TYPE_OTHER":
                        case 1:
                            message.vehicleType = 1;
                            break;
                        case "TYPE_SMALL_CAR":
                        case 2:
                            message.vehicleType = 2;
                            break;
                        case "TYPE_COMPACT_CAR":
                        case 3:
                            message.vehicleType = 3;
                            break;
                        case "TYPE_CAR":
                        case 4:
                            message.vehicleType = 4;
                            break;
                        case "TYPE_MEDIUM_CAR":
                        case 4:
                            message.vehicleType = 4;
                            break;
                        case "TYPE_LUXURY_CAR":
                        case 5:
                            message.vehicleType = 5;
                            break;
                        case "TYPE_DELIVERY_VAN":
                        case 6:
                            message.vehicleType = 6;
                            break;
                        case "TYPE_HEAVY_TRUCK":
                        case 7:
                            message.vehicleType = 7;
                            break;
                        case "TYPE_SEMITRACTOR":
                        case 16:
                            message.vehicleType = 16;
                            break;
                        case "TYPE_SEMITRAILER":
                        case 8:
                            message.vehicleType = 8;
                            break;
                        case "TYPE_TRAILER":
                        case 9:
                            message.vehicleType = 9;
                            break;
                        case "TYPE_MOTORBIKE":
                        case 10:
                            message.vehicleType = 10;
                            break;
                        case "TYPE_BICYCLE":
                        case 11:
                            message.vehicleType = 11;
                            break;
                        case "TYPE_BUS":
                        case 12:
                            message.vehicleType = 12;
                            break;
                        case "TYPE_TRAM":
                        case 13:
                            message.vehicleType = 13;
                            break;
                        case "TYPE_TRAIN":
                        case 14:
                            message.vehicleType = 14;
                            break;
                        case "TYPE_WHEELCHAIR":
                        case 15:
                            message.vehicleType = 15;
                            break;
                        case "TYPE_STANDUP_SCOOTER":
                        case 17:
                            message.vehicleType = 17;
                            break;
                        }
                        switch (object.vehicleRole) {
                        default:
                            if (typeof object.vehicleRole === "number") {
                                message.vehicleRole = object.vehicleRole;
                                break;
                            }
                            break;
                        case "ROLE_UNKNOWN":
                        case 0:
                            message.vehicleRole = 0;
                            break;
                        case "ROLE_OTHER":
                        case 1:
                            message.vehicleRole = 1;
                            break;
                        case "ROLE_CIVIL":
                        case 2:
                            message.vehicleRole = 2;
                            break;
                        case "ROLE_AMBULANCE":
                        case 3:
                            message.vehicleRole = 3;
                            break;
                        case "ROLE_FIRE":
                        case 4:
                            message.vehicleRole = 4;
                            break;
                        case "ROLE_POLICE":
                        case 5:
                            message.vehicleRole = 5;
                            break;
                        case "ROLE_PUBLIC_TRANSPORT":
                        case 6:
                            message.vehicleRole = 6;
                            break;
                        case "ROLE_ROAD_ASSISTANCE":
                        case 7:
                            message.vehicleRole = 7;
                            break;
                        case "ROLE_GARBAGE_COLLECTION":
                        case 8:
                            message.vehicleRole = 8;
                            break;
                        case "ROLE_ROAD_CONSTRUCTION":
                        case 9:
                            message.vehicleRole = 9;
                            break;
                        case "ROLE_MILITARY":
                        case 10:
                            message.vehicleRole = 10;
                            break;
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a TypeValidity message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof osi3.LogicalLane.TrafficRule.TrafficRuleValidity.TypeValidity
                     * @static
                     * @param {osi3.LogicalLane.TrafficRule.TrafficRuleValidity.TypeValidity} message TypeValidity
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    TypeValidity.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.type = options.enums === String ? "TYPE_UNKNOWN" : 0;
                            object.vehicleType = options.enums === String ? "TYPE_UNKNOWN" : 0;
                            object.vehicleRole = options.enums === String ? "ROLE_UNKNOWN" : 0;
                        }
                        if (message.type != null && message.hasOwnProperty("type"))
                            object.type = options.enums === String ? $root.osi3.MovingObject.Type[message.type] === undefined ? message.type : $root.osi3.MovingObject.Type[message.type] : message.type;
                        if (message.vehicleType != null && message.hasOwnProperty("vehicleType"))
                            object.vehicleType = options.enums === String ? $root.osi3.MovingObject.VehicleClassification.Type[message.vehicleType] === undefined ? message.vehicleType : $root.osi3.MovingObject.VehicleClassification.Type[message.vehicleType] : message.vehicleType;
                        if (message.vehicleRole != null && message.hasOwnProperty("vehicleRole"))
                            object.vehicleRole = options.enums === String ? $root.osi3.MovingObject.VehicleClassification.Role[message.vehicleRole] === undefined ? message.vehicleRole : $root.osi3.MovingObject.VehicleClassification.Role[message.vehicleRole] : message.vehicleRole;
                        return object;
                    };

                    /**
                     * Converts this TypeValidity to JSON.
                     * @function toJSON
                     * @memberof osi3.LogicalLane.TrafficRule.TrafficRuleValidity.TypeValidity
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    TypeValidity.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Gets the default type url for TypeValidity
                     * @function getTypeUrl
                     * @memberof osi3.LogicalLane.TrafficRule.TrafficRuleValidity.TypeValidity
                     * @static
                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                     * @returns {string} The default type url
                     */
                    TypeValidity.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                        if (typeUrlPrefix === undefined) {
                            typeUrlPrefix = "type.googleapis.com";
                        }
                        return typeUrlPrefix + "/osi3.LogicalLane.TrafficRule.TrafficRuleValidity.TypeValidity";
                    };

                    return TypeValidity;
                })();

                return TrafficRuleValidity;
            })();

            TrafficRule.SpeedLimit = (function() {

                /**
                 * Properties of a SpeedLimit.
                 * @memberof osi3.LogicalLane.TrafficRule
                 * @interface ISpeedLimit
                 * @property {osi3.ITrafficSignValue|null} [speedLimitValue] SpeedLimit speedLimitValue
                 */

                /**
                 * Constructs a new SpeedLimit.
                 * @memberof osi3.LogicalLane.TrafficRule
                 * @classdesc Represents a SpeedLimit.
                 * @implements ISpeedLimit
                 * @constructor
                 * @param {osi3.LogicalLane.TrafficRule.ISpeedLimit=} [properties] Properties to set
                 */
                function SpeedLimit(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * SpeedLimit speedLimitValue.
                 * @member {osi3.ITrafficSignValue|null|undefined} speedLimitValue
                 * @memberof osi3.LogicalLane.TrafficRule.SpeedLimit
                 * @instance
                 */
                SpeedLimit.prototype.speedLimitValue = null;

                /**
                 * Creates a new SpeedLimit instance using the specified properties.
                 * @function create
                 * @memberof osi3.LogicalLane.TrafficRule.SpeedLimit
                 * @static
                 * @param {osi3.LogicalLane.TrafficRule.ISpeedLimit=} [properties] Properties to set
                 * @returns {osi3.LogicalLane.TrafficRule.SpeedLimit} SpeedLimit instance
                 */
                SpeedLimit.create = function create(properties) {
                    return new SpeedLimit(properties);
                };

                /**
                 * Encodes the specified SpeedLimit message. Does not implicitly {@link osi3.LogicalLane.TrafficRule.SpeedLimit.verify|verify} messages.
                 * @function encode
                 * @memberof osi3.LogicalLane.TrafficRule.SpeedLimit
                 * @static
                 * @param {osi3.LogicalLane.TrafficRule.ISpeedLimit} message SpeedLimit message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SpeedLimit.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.speedLimitValue != null && Object.hasOwnProperty.call(message, "speedLimitValue"))
                        $root.osi3.TrafficSignValue.encode(message.speedLimitValue, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified SpeedLimit message, length delimited. Does not implicitly {@link osi3.LogicalLane.TrafficRule.SpeedLimit.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof osi3.LogicalLane.TrafficRule.SpeedLimit
                 * @static
                 * @param {osi3.LogicalLane.TrafficRule.ISpeedLimit} message SpeedLimit message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SpeedLimit.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a SpeedLimit message from the specified reader or buffer.
                 * @function decode
                 * @memberof osi3.LogicalLane.TrafficRule.SpeedLimit
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {osi3.LogicalLane.TrafficRule.SpeedLimit} SpeedLimit
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SpeedLimit.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.osi3.LogicalLane.TrafficRule.SpeedLimit();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                message.speedLimitValue = $root.osi3.TrafficSignValue.decode(reader, reader.uint32());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a SpeedLimit message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof osi3.LogicalLane.TrafficRule.SpeedLimit
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {osi3.LogicalLane.TrafficRule.SpeedLimit} SpeedLimit
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SpeedLimit.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a SpeedLimit message.
                 * @function verify
                 * @memberof osi3.LogicalLane.TrafficRule.SpeedLimit
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                SpeedLimit.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.speedLimitValue != null && message.hasOwnProperty("speedLimitValue")) {
                        let error = $root.osi3.TrafficSignValue.verify(message.speedLimitValue);
                        if (error)
                            return "speedLimitValue." + error;
                    }
                    return null;
                };

                /**
                 * Creates a SpeedLimit message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof osi3.LogicalLane.TrafficRule.SpeedLimit
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {osi3.LogicalLane.TrafficRule.SpeedLimit} SpeedLimit
                 */
                SpeedLimit.fromObject = function fromObject(object) {
                    if (object instanceof $root.osi3.LogicalLane.TrafficRule.SpeedLimit)
                        return object;
                    let message = new $root.osi3.LogicalLane.TrafficRule.SpeedLimit();
                    if (object.speedLimitValue != null) {
                        if (typeof object.speedLimitValue !== "object")
                            throw TypeError(".osi3.LogicalLane.TrafficRule.SpeedLimit.speedLimitValue: object expected");
                        message.speedLimitValue = $root.osi3.TrafficSignValue.fromObject(object.speedLimitValue);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a SpeedLimit message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof osi3.LogicalLane.TrafficRule.SpeedLimit
                 * @static
                 * @param {osi3.LogicalLane.TrafficRule.SpeedLimit} message SpeedLimit
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                SpeedLimit.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        object.speedLimitValue = null;
                    if (message.speedLimitValue != null && message.hasOwnProperty("speedLimitValue"))
                        object.speedLimitValue = $root.osi3.TrafficSignValue.toObject(message.speedLimitValue, options);
                    return object;
                };

                /**
                 * Converts this SpeedLimit to JSON.
                 * @function toJSON
                 * @memberof osi3.LogicalLane.TrafficRule.SpeedLimit
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                SpeedLimit.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for SpeedLimit
                 * @function getTypeUrl
                 * @memberof osi3.LogicalLane.TrafficRule.SpeedLimit
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                SpeedLimit.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/osi3.LogicalLane.TrafficRule.SpeedLimit";
                };

                return SpeedLimit;
            })();

            return TrafficRule;
        })();

        return LogicalLane;
    })();

    osi3.StationaryObject = (function() {

        /**
         * Properties of a StationaryObject.
         * @memberof osi3
         * @interface IStationaryObject
         * @property {osi3.IIdentifier|null} [id] StationaryObject id
         * @property {osi3.IBaseStationary|null} [base] StationaryObject base
         * @property {osi3.StationaryObject.IClassification|null} [classification] StationaryObject classification
         * @property {string|null} [modelReference] StationaryObject modelReference
         * @property {Array.<osi3.IExternalReference>|null} [sourceReference] StationaryObject sourceReference
         * @property {osi3.IColorDescription|null} [colorDescription] StationaryObject colorDescription
         */

        /**
         * Constructs a new StationaryObject.
         * @memberof osi3
         * @classdesc Represents a StationaryObject.
         * @implements IStationaryObject
         * @constructor
         * @param {osi3.IStationaryObject=} [properties] Properties to set
         */
        function StationaryObject(properties) {
            this.sourceReference = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StationaryObject id.
         * @member {osi3.IIdentifier|null|undefined} id
         * @memberof osi3.StationaryObject
         * @instance
         */
        StationaryObject.prototype.id = null;

        /**
         * StationaryObject base.
         * @member {osi3.IBaseStationary|null|undefined} base
         * @memberof osi3.StationaryObject
         * @instance
         */
        StationaryObject.prototype.base = null;

        /**
         * StationaryObject classification.
         * @member {osi3.StationaryObject.IClassification|null|undefined} classification
         * @memberof osi3.StationaryObject
         * @instance
         */
        StationaryObject.prototype.classification = null;

        /**
         * StationaryObject modelReference.
         * @member {string} modelReference
         * @memberof osi3.StationaryObject
         * @instance
         */
        StationaryObject.prototype.modelReference = "";

        /**
         * StationaryObject sourceReference.
         * @member {Array.<osi3.IExternalReference>} sourceReference
         * @memberof osi3.StationaryObject
         * @instance
         */
        StationaryObject.prototype.sourceReference = $util.emptyArray;

        /**
         * StationaryObject colorDescription.
         * @member {osi3.IColorDescription|null|undefined} colorDescription
         * @memberof osi3.StationaryObject
         * @instance
         */
        StationaryObject.prototype.colorDescription = null;

        /**
         * Creates a new StationaryObject instance using the specified properties.
         * @function create
         * @memberof osi3.StationaryObject
         * @static
         * @param {osi3.IStationaryObject=} [properties] Properties to set
         * @returns {osi3.StationaryObject} StationaryObject instance
         */
        StationaryObject.create = function create(properties) {
            return new StationaryObject(properties);
        };

        /**
         * Encodes the specified StationaryObject message. Does not implicitly {@link osi3.StationaryObject.verify|verify} messages.
         * @function encode
         * @memberof osi3.StationaryObject
         * @static
         * @param {osi3.IStationaryObject} message StationaryObject message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StationaryObject.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                $root.osi3.Identifier.encode(message.id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.base != null && Object.hasOwnProperty.call(message, "base"))
                $root.osi3.BaseStationary.encode(message.base, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.classification != null && Object.hasOwnProperty.call(message, "classification"))
                $root.osi3.StationaryObject.Classification.encode(message.classification, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.modelReference != null && Object.hasOwnProperty.call(message, "modelReference"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.modelReference);
            if (message.sourceReference != null && message.sourceReference.length)
                for (let i = 0; i < message.sourceReference.length; ++i)
                    $root.osi3.ExternalReference.encode(message.sourceReference[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.colorDescription != null && Object.hasOwnProperty.call(message, "colorDescription"))
                $root.osi3.ColorDescription.encode(message.colorDescription, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified StationaryObject message, length delimited. Does not implicitly {@link osi3.StationaryObject.verify|verify} messages.
         * @function encodeDelimited
         * @memberof osi3.StationaryObject
         * @static
         * @param {osi3.IStationaryObject} message StationaryObject message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StationaryObject.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a StationaryObject message from the specified reader or buffer.
         * @function decode
         * @memberof osi3.StationaryObject
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {osi3.StationaryObject} StationaryObject
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StationaryObject.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.osi3.StationaryObject();
            while (reader.pos < end) {
                let tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.id = $root.osi3.Identifier.decode(reader, reader.uint32());
                        break;
                    }
                case 2: {
                        message.base = $root.osi3.BaseStationary.decode(reader, reader.uint32());
                        break;
                    }
                case 3: {
                        message.classification = $root.osi3.StationaryObject.Classification.decode(reader, reader.uint32());
                        break;
                    }
                case 4: {
                        message.modelReference = reader.string();
                        break;
                    }
                case 5: {
                        if (!(message.sourceReference && message.sourceReference.length))
                            message.sourceReference = [];
                        message.sourceReference.push($root.osi3.ExternalReference.decode(reader, reader.uint32()));
                        break;
                    }
                case 6: {
                        message.colorDescription = $root.osi3.ColorDescription.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a StationaryObject message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof osi3.StationaryObject
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {osi3.StationaryObject} StationaryObject
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StationaryObject.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a StationaryObject message.
         * @function verify
         * @memberof osi3.StationaryObject
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        StationaryObject.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id")) {
                let error = $root.osi3.Identifier.verify(message.id);
                if (error)
                    return "id." + error;
            }
            if (message.base != null && message.hasOwnProperty("base")) {
                let error = $root.osi3.BaseStationary.verify(message.base);
                if (error)
                    return "base." + error;
            }
            if (message.classification != null && message.hasOwnProperty("classification")) {
                let error = $root.osi3.StationaryObject.Classification.verify(message.classification);
                if (error)
                    return "classification." + error;
            }
            if (message.modelReference != null && message.hasOwnProperty("modelReference"))
                if (!$util.isString(message.modelReference))
                    return "modelReference: string expected";
            if (message.sourceReference != null && message.hasOwnProperty("sourceReference")) {
                if (!Array.isArray(message.sourceReference))
                    return "sourceReference: array expected";
                for (let i = 0; i < message.sourceReference.length; ++i) {
                    let error = $root.osi3.ExternalReference.verify(message.sourceReference[i]);
                    if (error)
                        return "sourceReference." + error;
                }
            }
            if (message.colorDescription != null && message.hasOwnProperty("colorDescription")) {
                let error = $root.osi3.ColorDescription.verify(message.colorDescription);
                if (error)
                    return "colorDescription." + error;
            }
            return null;
        };

        /**
         * Creates a StationaryObject message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof osi3.StationaryObject
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {osi3.StationaryObject} StationaryObject
         */
        StationaryObject.fromObject = function fromObject(object) {
            if (object instanceof $root.osi3.StationaryObject)
                return object;
            let message = new $root.osi3.StationaryObject();
            if (object.id != null) {
                if (typeof object.id !== "object")
                    throw TypeError(".osi3.StationaryObject.id: object expected");
                message.id = $root.osi3.Identifier.fromObject(object.id);
            }
            if (object.base != null) {
                if (typeof object.base !== "object")
                    throw TypeError(".osi3.StationaryObject.base: object expected");
                message.base = $root.osi3.BaseStationary.fromObject(object.base);
            }
            if (object.classification != null) {
                if (typeof object.classification !== "object")
                    throw TypeError(".osi3.StationaryObject.classification: object expected");
                message.classification = $root.osi3.StationaryObject.Classification.fromObject(object.classification);
            }
            if (object.modelReference != null)
                message.modelReference = String(object.modelReference);
            if (object.sourceReference) {
                if (!Array.isArray(object.sourceReference))
                    throw TypeError(".osi3.StationaryObject.sourceReference: array expected");
                message.sourceReference = [];
                for (let i = 0; i < object.sourceReference.length; ++i) {
                    if (typeof object.sourceReference[i] !== "object")
                        throw TypeError(".osi3.StationaryObject.sourceReference: object expected");
                    message.sourceReference[i] = $root.osi3.ExternalReference.fromObject(object.sourceReference[i]);
                }
            }
            if (object.colorDescription != null) {
                if (typeof object.colorDescription !== "object")
                    throw TypeError(".osi3.StationaryObject.colorDescription: object expected");
                message.colorDescription = $root.osi3.ColorDescription.fromObject(object.colorDescription);
            }
            return message;
        };

        /**
         * Creates a plain object from a StationaryObject message. Also converts values to other types if specified.
         * @function toObject
         * @memberof osi3.StationaryObject
         * @static
         * @param {osi3.StationaryObject} message StationaryObject
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        StationaryObject.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.sourceReference = [];
            if (options.defaults) {
                object.id = null;
                object.base = null;
                object.classification = null;
                object.modelReference = "";
                object.colorDescription = null;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = $root.osi3.Identifier.toObject(message.id, options);
            if (message.base != null && message.hasOwnProperty("base"))
                object.base = $root.osi3.BaseStationary.toObject(message.base, options);
            if (message.classification != null && message.hasOwnProperty("classification"))
                object.classification = $root.osi3.StationaryObject.Classification.toObject(message.classification, options);
            if (message.modelReference != null && message.hasOwnProperty("modelReference"))
                object.modelReference = message.modelReference;
            if (message.sourceReference && message.sourceReference.length) {
                object.sourceReference = [];
                for (let j = 0; j < message.sourceReference.length; ++j)
                    object.sourceReference[j] = $root.osi3.ExternalReference.toObject(message.sourceReference[j], options);
            }
            if (message.colorDescription != null && message.hasOwnProperty("colorDescription"))
                object.colorDescription = $root.osi3.ColorDescription.toObject(message.colorDescription, options);
            return object;
        };

        /**
         * Converts this StationaryObject to JSON.
         * @function toJSON
         * @memberof osi3.StationaryObject
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        StationaryObject.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for StationaryObject
         * @function getTypeUrl
         * @memberof osi3.StationaryObject
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        StationaryObject.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/osi3.StationaryObject";
        };

        StationaryObject.Classification = (function() {

            /**
             * Properties of a Classification.
             * @memberof osi3.StationaryObject
             * @interface IClassification
             * @property {osi3.StationaryObject.Classification.Type|null} [type] Classification type
             * @property {osi3.StationaryObject.Classification.Material|null} [material] Classification material
             * @property {osi3.StationaryObject.Classification.Density|null} [density] Classification density
             * @property {osi3.StationaryObject.Classification.Color|null} [color] Classification color
             * @property {osi3.StationaryObject.Classification.IEmittingStructureAttribute|null} [emittingStructureAttribute] Classification emittingStructureAttribute
             * @property {Array.<osi3.IIdentifier>|null} [assignedLaneId] Classification assignedLaneId
             * @property {Array.<number>|null} [assignedLanePercentage] Classification assignedLanePercentage
             * @property {Array.<osi3.ILogicalLaneAssignment>|null} [logicalLaneAssignment] Classification logicalLaneAssignment
             */

            /**
             * Constructs a new Classification.
             * @memberof osi3.StationaryObject
             * @classdesc Represents a Classification.
             * @implements IClassification
             * @constructor
             * @param {osi3.StationaryObject.IClassification=} [properties] Properties to set
             */
            function Classification(properties) {
                this.assignedLaneId = [];
                this.assignedLanePercentage = [];
                this.logicalLaneAssignment = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Classification type.
             * @member {osi3.StationaryObject.Classification.Type} type
             * @memberof osi3.StationaryObject.Classification
             * @instance
             */
            Classification.prototype.type = 0;

            /**
             * Classification material.
             * @member {osi3.StationaryObject.Classification.Material} material
             * @memberof osi3.StationaryObject.Classification
             * @instance
             */
            Classification.prototype.material = 0;

            /**
             * Classification density.
             * @member {osi3.StationaryObject.Classification.Density} density
             * @memberof osi3.StationaryObject.Classification
             * @instance
             */
            Classification.prototype.density = 0;

            /**
             * Classification color.
             * @member {osi3.StationaryObject.Classification.Color} color
             * @memberof osi3.StationaryObject.Classification
             * @instance
             */
            Classification.prototype.color = 0;

            /**
             * Classification emittingStructureAttribute.
             * @member {osi3.StationaryObject.Classification.IEmittingStructureAttribute|null|undefined} emittingStructureAttribute
             * @memberof osi3.StationaryObject.Classification
             * @instance
             */
            Classification.prototype.emittingStructureAttribute = null;

            /**
             * Classification assignedLaneId.
             * @member {Array.<osi3.IIdentifier>} assignedLaneId
             * @memberof osi3.StationaryObject.Classification
             * @instance
             */
            Classification.prototype.assignedLaneId = $util.emptyArray;

            /**
             * Classification assignedLanePercentage.
             * @member {Array.<number>} assignedLanePercentage
             * @memberof osi3.StationaryObject.Classification
             * @instance
             */
            Classification.prototype.assignedLanePercentage = $util.emptyArray;

            /**
             * Classification logicalLaneAssignment.
             * @member {Array.<osi3.ILogicalLaneAssignment>} logicalLaneAssignment
             * @memberof osi3.StationaryObject.Classification
             * @instance
             */
            Classification.prototype.logicalLaneAssignment = $util.emptyArray;

            /**
             * Creates a new Classification instance using the specified properties.
             * @function create
             * @memberof osi3.StationaryObject.Classification
             * @static
             * @param {osi3.StationaryObject.IClassification=} [properties] Properties to set
             * @returns {osi3.StationaryObject.Classification} Classification instance
             */
            Classification.create = function create(properties) {
                return new Classification(properties);
            };

            /**
             * Encodes the specified Classification message. Does not implicitly {@link osi3.StationaryObject.Classification.verify|verify} messages.
             * @function encode
             * @memberof osi3.StationaryObject.Classification
             * @static
             * @param {osi3.StationaryObject.IClassification} message Classification message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Classification.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                if (message.material != null && Object.hasOwnProperty.call(message, "material"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.material);
                if (message.density != null && Object.hasOwnProperty.call(message, "density"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.density);
                if (message.color != null && Object.hasOwnProperty.call(message, "color"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.color);
                if (message.emittingStructureAttribute != null && Object.hasOwnProperty.call(message, "emittingStructureAttribute"))
                    $root.osi3.StationaryObject.Classification.EmittingStructureAttribute.encode(message.emittingStructureAttribute, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.assignedLaneId != null && message.assignedLaneId.length)
                    for (let i = 0; i < message.assignedLaneId.length; ++i)
                        $root.osi3.Identifier.encode(message.assignedLaneId[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.assignedLanePercentage != null && message.assignedLanePercentage.length)
                    for (let i = 0; i < message.assignedLanePercentage.length; ++i)
                        writer.uint32(/* id 7, wireType 1 =*/57).double(message.assignedLanePercentage[i]);
                if (message.logicalLaneAssignment != null && message.logicalLaneAssignment.length)
                    for (let i = 0; i < message.logicalLaneAssignment.length; ++i)
                        $root.osi3.LogicalLaneAssignment.encode(message.logicalLaneAssignment[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Classification message, length delimited. Does not implicitly {@link osi3.StationaryObject.Classification.verify|verify} messages.
             * @function encodeDelimited
             * @memberof osi3.StationaryObject.Classification
             * @static
             * @param {osi3.StationaryObject.IClassification} message Classification message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Classification.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Classification message from the specified reader or buffer.
             * @function decode
             * @memberof osi3.StationaryObject.Classification
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {osi3.StationaryObject.Classification} Classification
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Classification.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.osi3.StationaryObject.Classification();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.type = reader.int32();
                            break;
                        }
                    case 2: {
                            message.material = reader.int32();
                            break;
                        }
                    case 3: {
                            message.density = reader.int32();
                            break;
                        }
                    case 4: {
                            message.color = reader.int32();
                            break;
                        }
                    case 5: {
                            message.emittingStructureAttribute = $root.osi3.StationaryObject.Classification.EmittingStructureAttribute.decode(reader, reader.uint32());
                            break;
                        }
                    case 6: {
                            if (!(message.assignedLaneId && message.assignedLaneId.length))
                                message.assignedLaneId = [];
                            message.assignedLaneId.push($root.osi3.Identifier.decode(reader, reader.uint32()));
                            break;
                        }
                    case 7: {
                            if (!(message.assignedLanePercentage && message.assignedLanePercentage.length))
                                message.assignedLanePercentage = [];
                            if ((tag & 7) === 2) {
                                let end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.assignedLanePercentage.push(reader.double());
                            } else
                                message.assignedLanePercentage.push(reader.double());
                            break;
                        }
                    case 8: {
                            if (!(message.logicalLaneAssignment && message.logicalLaneAssignment.length))
                                message.logicalLaneAssignment = [];
                            message.logicalLaneAssignment.push($root.osi3.LogicalLaneAssignment.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Classification message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof osi3.StationaryObject.Classification
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {osi3.StationaryObject.Classification} Classification
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Classification.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Classification message.
             * @function verify
             * @memberof osi3.StationaryObject.Classification
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Classification.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                    case 9:
                    case 10:
                    case 11:
                    case 12:
                    case 13:
                    case 14:
                    case 15:
                    case 16:
                    case 17:
                    case 18:
                        break;
                    }
                if (message.material != null && message.hasOwnProperty("material"))
                    switch (message.material) {
                    default:
                        return "material: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 7:
                    case 8:
                        break;
                    }
                if (message.density != null && message.hasOwnProperty("density"))
                    switch (message.density) {
                    default:
                        return "density: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                        break;
                    }
                if (message.color != null && message.hasOwnProperty("color"))
                    switch (message.color) {
                    default:
                        return "color: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                    case 9:
                    case 9:
                    case 10:
                        break;
                    }
                if (message.emittingStructureAttribute != null && message.hasOwnProperty("emittingStructureAttribute")) {
                    let error = $root.osi3.StationaryObject.Classification.EmittingStructureAttribute.verify(message.emittingStructureAttribute);
                    if (error)
                        return "emittingStructureAttribute." + error;
                }
                if (message.assignedLaneId != null && message.hasOwnProperty("assignedLaneId")) {
                    if (!Array.isArray(message.assignedLaneId))
                        return "assignedLaneId: array expected";
                    for (let i = 0; i < message.assignedLaneId.length; ++i) {
                        let error = $root.osi3.Identifier.verify(message.assignedLaneId[i]);
                        if (error)
                            return "assignedLaneId." + error;
                    }
                }
                if (message.assignedLanePercentage != null && message.hasOwnProperty("assignedLanePercentage")) {
                    if (!Array.isArray(message.assignedLanePercentage))
                        return "assignedLanePercentage: array expected";
                    for (let i = 0; i < message.assignedLanePercentage.length; ++i)
                        if (typeof message.assignedLanePercentage[i] !== "number")
                            return "assignedLanePercentage: number[] expected";
                }
                if (message.logicalLaneAssignment != null && message.hasOwnProperty("logicalLaneAssignment")) {
                    if (!Array.isArray(message.logicalLaneAssignment))
                        return "logicalLaneAssignment: array expected";
                    for (let i = 0; i < message.logicalLaneAssignment.length; ++i) {
                        let error = $root.osi3.LogicalLaneAssignment.verify(message.logicalLaneAssignment[i]);
                        if (error)
                            return "logicalLaneAssignment." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a Classification message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof osi3.StationaryObject.Classification
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {osi3.StationaryObject.Classification} Classification
             */
            Classification.fromObject = function fromObject(object) {
                if (object instanceof $root.osi3.StationaryObject.Classification)
                    return object;
                let message = new $root.osi3.StationaryObject.Classification();
                switch (object.type) {
                default:
                    if (typeof object.type === "number") {
                        message.type = object.type;
                        break;
                    }
                    break;
                case "TYPE_UNKNOWN":
                case 0:
                    message.type = 0;
                    break;
                case "TYPE_OTHER":
                case 1:
                    message.type = 1;
                    break;
                case "TYPE_BRIDGE":
                case 2:
                    message.type = 2;
                    break;
                case "TYPE_BUILDING":
                case 3:
                    message.type = 3;
                    break;
                case "TYPE_POLE":
                case 4:
                    message.type = 4;
                    break;
                case "TYPE_PYLON":
                case 5:
                    message.type = 5;
                    break;
                case "TYPE_DELINEATOR":
                case 6:
                    message.type = 6;
                    break;
                case "TYPE_TREE":
                case 7:
                    message.type = 7;
                    break;
                case "TYPE_BARRIER":
                case 8:
                    message.type = 8;
                    break;
                case "TYPE_VEGETATION":
                case 9:
                    message.type = 9;
                    break;
                case "TYPE_CURBSTONE":
                case 10:
                    message.type = 10;
                    break;
                case "TYPE_WALL":
                case 11:
                    message.type = 11;
                    break;
                case "TYPE_VERTICAL_STRUCTURE":
                case 12:
                    message.type = 12;
                    break;
                case "TYPE_RECTANGULAR_STRUCTURE":
                case 13:
                    message.type = 13;
                    break;
                case "TYPE_OVERHEAD_STRUCTURE":
                case 14:
                    message.type = 14;
                    break;
                case "TYPE_REFLECTIVE_STRUCTURE":
                case 15:
                    message.type = 15;
                    break;
                case "TYPE_CONSTRUCTION_SITE_ELEMENT":
                case 16:
                    message.type = 16;
                    break;
                case "TYPE_SPEED_BUMP":
                case 17:
                    message.type = 17;
                    break;
                case "TYPE_EMITTING_STRUCTURE":
                case 18:
                    message.type = 18;
                    break;
                }
                switch (object.material) {
                default:
                    if (typeof object.material === "number") {
                        message.material = object.material;
                        break;
                    }
                    break;
                case "MATERIAL_UNKNOWN":
                case 0:
                    message.material = 0;
                    break;
                case "MATERIAL_OTHER":
                case 1:
                    message.material = 1;
                    break;
                case "MATERIAL_WOOD":
                case 2:
                    message.material = 2;
                    break;
                case "MATERIAL_PLASTIC":
                case 3:
                    message.material = 3;
                    break;
                case "MATERIAL_CONCRETE":
                case 4:
                    message.material = 4;
                    break;
                case "MATERIAL_METAL":
                case 5:
                    message.material = 5;
                    break;
                case "MATERIAL_STONE":
                case 6:
                    message.material = 6;
                    break;
                case "MATERIAL_GLASS":
                case 7:
                    message.material = 7;
                    break;
                case "MATERIAL_GLAS":
                case 7:
                    message.material = 7;
                    break;
                case "MATERIAL_MUD":
                case 8:
                    message.material = 8;
                    break;
                }
                switch (object.density) {
                default:
                    if (typeof object.density === "number") {
                        message.density = object.density;
                        break;
                    }
                    break;
                case "DENSITY_UNKNOWN":
                case 0:
                    message.density = 0;
                    break;
                case "DENSITY_OTHER":
                case 1:
                    message.density = 1;
                    break;
                case "DENSITY_SOLID":
                case 2:
                    message.density = 2;
                    break;
                case "DENSITY_SMALL_MESH":
                case 3:
                    message.density = 3;
                    break;
                case "DENSITY_MEDIAN_MESH":
                case 4:
                    message.density = 4;
                    break;
                case "DENSITY_LARGE_MESH":
                case 5:
                    message.density = 5;
                    break;
                case "DENSITY_OPEN":
                case 6:
                    message.density = 6;
                    break;
                }
                switch (object.color) {
                default:
                    if (typeof object.color === "number") {
                        message.color = object.color;
                        break;
                    }
                    break;
                case "COLOR_UNKNOWN":
                case 0:
                    message.color = 0;
                    break;
                case "COLOR_OTHER":
                case 1:
                    message.color = 1;
                    break;
                case "COLOR_YELLOW":
                case 2:
                    message.color = 2;
                    break;
                case "COLOR_GREEN":
                case 3:
                    message.color = 3;
                    break;
                case "COLOR_BLUE":
                case 4:
                    message.color = 4;
                    break;
                case "COLOR_VIOLET":
                case 5:
                    message.color = 5;
                    break;
                case "COLOR_RED":
                case 6:
                    message.color = 6;
                    break;
                case "COLOR_ORANGE":
                case 7:
                    message.color = 7;
                    break;
                case "COLOR_BLACK":
                case 8:
                    message.color = 8;
                    break;
                case "COLOR_GRAY":
                case 9:
                    message.color = 9;
                    break;
                case "COLOR_GREY":
                case 9:
                    message.color = 9;
                    break;
                case "COLOR_WHITE":
                case 10:
                    message.color = 10;
                    break;
                }
                if (object.emittingStructureAttribute != null) {
                    if (typeof object.emittingStructureAttribute !== "object")
                        throw TypeError(".osi3.StationaryObject.Classification.emittingStructureAttribute: object expected");
                    message.emittingStructureAttribute = $root.osi3.StationaryObject.Classification.EmittingStructureAttribute.fromObject(object.emittingStructureAttribute);
                }
                if (object.assignedLaneId) {
                    if (!Array.isArray(object.assignedLaneId))
                        throw TypeError(".osi3.StationaryObject.Classification.assignedLaneId: array expected");
                    message.assignedLaneId = [];
                    for (let i = 0; i < object.assignedLaneId.length; ++i) {
                        if (typeof object.assignedLaneId[i] !== "object")
                            throw TypeError(".osi3.StationaryObject.Classification.assignedLaneId: object expected");
                        message.assignedLaneId[i] = $root.osi3.Identifier.fromObject(object.assignedLaneId[i]);
                    }
                }
                if (object.assignedLanePercentage) {
                    if (!Array.isArray(object.assignedLanePercentage))
                        throw TypeError(".osi3.StationaryObject.Classification.assignedLanePercentage: array expected");
                    message.assignedLanePercentage = [];
                    for (let i = 0; i < object.assignedLanePercentage.length; ++i)
                        message.assignedLanePercentage[i] = Number(object.assignedLanePercentage[i]);
                }
                if (object.logicalLaneAssignment) {
                    if (!Array.isArray(object.logicalLaneAssignment))
                        throw TypeError(".osi3.StationaryObject.Classification.logicalLaneAssignment: array expected");
                    message.logicalLaneAssignment = [];
                    for (let i = 0; i < object.logicalLaneAssignment.length; ++i) {
                        if (typeof object.logicalLaneAssignment[i] !== "object")
                            throw TypeError(".osi3.StationaryObject.Classification.logicalLaneAssignment: object expected");
                        message.logicalLaneAssignment[i] = $root.osi3.LogicalLaneAssignment.fromObject(object.logicalLaneAssignment[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a Classification message. Also converts values to other types if specified.
             * @function toObject
             * @memberof osi3.StationaryObject.Classification
             * @static
             * @param {osi3.StationaryObject.Classification} message Classification
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Classification.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults) {
                    object.assignedLaneId = [];
                    object.assignedLanePercentage = [];
                    object.logicalLaneAssignment = [];
                }
                if (options.defaults) {
                    object.type = options.enums === String ? "TYPE_UNKNOWN" : 0;
                    object.material = options.enums === String ? "MATERIAL_UNKNOWN" : 0;
                    object.density = options.enums === String ? "DENSITY_UNKNOWN" : 0;
                    object.color = options.enums === String ? "COLOR_UNKNOWN" : 0;
                    object.emittingStructureAttribute = null;
                }
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.osi3.StationaryObject.Classification.Type[message.type] === undefined ? message.type : $root.osi3.StationaryObject.Classification.Type[message.type] : message.type;
                if (message.material != null && message.hasOwnProperty("material"))
                    object.material = options.enums === String ? $root.osi3.StationaryObject.Classification.Material[message.material] === undefined ? message.material : $root.osi3.StationaryObject.Classification.Material[message.material] : message.material;
                if (message.density != null && message.hasOwnProperty("density"))
                    object.density = options.enums === String ? $root.osi3.StationaryObject.Classification.Density[message.density] === undefined ? message.density : $root.osi3.StationaryObject.Classification.Density[message.density] : message.density;
                if (message.color != null && message.hasOwnProperty("color"))
                    object.color = options.enums === String ? $root.osi3.StationaryObject.Classification.Color[message.color] === undefined ? message.color : $root.osi3.StationaryObject.Classification.Color[message.color] : message.color;
                if (message.emittingStructureAttribute != null && message.hasOwnProperty("emittingStructureAttribute"))
                    object.emittingStructureAttribute = $root.osi3.StationaryObject.Classification.EmittingStructureAttribute.toObject(message.emittingStructureAttribute, options);
                if (message.assignedLaneId && message.assignedLaneId.length) {
                    object.assignedLaneId = [];
                    for (let j = 0; j < message.assignedLaneId.length; ++j)
                        object.assignedLaneId[j] = $root.osi3.Identifier.toObject(message.assignedLaneId[j], options);
                }
                if (message.assignedLanePercentage && message.assignedLanePercentage.length) {
                    object.assignedLanePercentage = [];
                    for (let j = 0; j < message.assignedLanePercentage.length; ++j)
                        object.assignedLanePercentage[j] = options.json && !isFinite(message.assignedLanePercentage[j]) ? String(message.assignedLanePercentage[j]) : message.assignedLanePercentage[j];
                }
                if (message.logicalLaneAssignment && message.logicalLaneAssignment.length) {
                    object.logicalLaneAssignment = [];
                    for (let j = 0; j < message.logicalLaneAssignment.length; ++j)
                        object.logicalLaneAssignment[j] = $root.osi3.LogicalLaneAssignment.toObject(message.logicalLaneAssignment[j], options);
                }
                return object;
            };

            /**
             * Converts this Classification to JSON.
             * @function toJSON
             * @memberof osi3.StationaryObject.Classification
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Classification.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Classification
             * @function getTypeUrl
             * @memberof osi3.StationaryObject.Classification
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Classification.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/osi3.StationaryObject.Classification";
            };

            /**
             * Type enum.
             * @name osi3.StationaryObject.Classification.Type
             * @enum {number}
             * @property {number} TYPE_UNKNOWN=0 TYPE_UNKNOWN value
             * @property {number} TYPE_OTHER=1 TYPE_OTHER value
             * @property {number} TYPE_BRIDGE=2 TYPE_BRIDGE value
             * @property {number} TYPE_BUILDING=3 TYPE_BUILDING value
             * @property {number} TYPE_POLE=4 TYPE_POLE value
             * @property {number} TYPE_PYLON=5 TYPE_PYLON value
             * @property {number} TYPE_DELINEATOR=6 TYPE_DELINEATOR value
             * @property {number} TYPE_TREE=7 TYPE_TREE value
             * @property {number} TYPE_BARRIER=8 TYPE_BARRIER value
             * @property {number} TYPE_VEGETATION=9 TYPE_VEGETATION value
             * @property {number} TYPE_CURBSTONE=10 TYPE_CURBSTONE value
             * @property {number} TYPE_WALL=11 TYPE_WALL value
             * @property {number} TYPE_VERTICAL_STRUCTURE=12 TYPE_VERTICAL_STRUCTURE value
             * @property {number} TYPE_RECTANGULAR_STRUCTURE=13 TYPE_RECTANGULAR_STRUCTURE value
             * @property {number} TYPE_OVERHEAD_STRUCTURE=14 TYPE_OVERHEAD_STRUCTURE value
             * @property {number} TYPE_REFLECTIVE_STRUCTURE=15 TYPE_REFLECTIVE_STRUCTURE value
             * @property {number} TYPE_CONSTRUCTION_SITE_ELEMENT=16 TYPE_CONSTRUCTION_SITE_ELEMENT value
             * @property {number} TYPE_SPEED_BUMP=17 TYPE_SPEED_BUMP value
             * @property {number} TYPE_EMITTING_STRUCTURE=18 TYPE_EMITTING_STRUCTURE value
             */
            Classification.Type = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "TYPE_UNKNOWN"] = 0;
                values[valuesById[1] = "TYPE_OTHER"] = 1;
                values[valuesById[2] = "TYPE_BRIDGE"] = 2;
                values[valuesById[3] = "TYPE_BUILDING"] = 3;
                values[valuesById[4] = "TYPE_POLE"] = 4;
                values[valuesById[5] = "TYPE_PYLON"] = 5;
                values[valuesById[6] = "TYPE_DELINEATOR"] = 6;
                values[valuesById[7] = "TYPE_TREE"] = 7;
                values[valuesById[8] = "TYPE_BARRIER"] = 8;
                values[valuesById[9] = "TYPE_VEGETATION"] = 9;
                values[valuesById[10] = "TYPE_CURBSTONE"] = 10;
                values[valuesById[11] = "TYPE_WALL"] = 11;
                values[valuesById[12] = "TYPE_VERTICAL_STRUCTURE"] = 12;
                values[valuesById[13] = "TYPE_RECTANGULAR_STRUCTURE"] = 13;
                values[valuesById[14] = "TYPE_OVERHEAD_STRUCTURE"] = 14;
                values[valuesById[15] = "TYPE_REFLECTIVE_STRUCTURE"] = 15;
                values[valuesById[16] = "TYPE_CONSTRUCTION_SITE_ELEMENT"] = 16;
                values[valuesById[17] = "TYPE_SPEED_BUMP"] = 17;
                values[valuesById[18] = "TYPE_EMITTING_STRUCTURE"] = 18;
                return values;
            })();

            /**
             * Material enum.
             * @name osi3.StationaryObject.Classification.Material
             * @enum {number}
             * @property {number} MATERIAL_UNKNOWN=0 MATERIAL_UNKNOWN value
             * @property {number} MATERIAL_OTHER=1 MATERIAL_OTHER value
             * @property {number} MATERIAL_WOOD=2 MATERIAL_WOOD value
             * @property {number} MATERIAL_PLASTIC=3 MATERIAL_PLASTIC value
             * @property {number} MATERIAL_CONCRETE=4 MATERIAL_CONCRETE value
             * @property {number} MATERIAL_METAL=5 MATERIAL_METAL value
             * @property {number} MATERIAL_STONE=6 MATERIAL_STONE value
             * @property {number} MATERIAL_GLASS=7 MATERIAL_GLASS value
             * @property {number} MATERIAL_GLAS=7 MATERIAL_GLAS value
             * @property {number} MATERIAL_MUD=8 MATERIAL_MUD value
             */
            Classification.Material = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "MATERIAL_UNKNOWN"] = 0;
                values[valuesById[1] = "MATERIAL_OTHER"] = 1;
                values[valuesById[2] = "MATERIAL_WOOD"] = 2;
                values[valuesById[3] = "MATERIAL_PLASTIC"] = 3;
                values[valuesById[4] = "MATERIAL_CONCRETE"] = 4;
                values[valuesById[5] = "MATERIAL_METAL"] = 5;
                values[valuesById[6] = "MATERIAL_STONE"] = 6;
                values[valuesById[7] = "MATERIAL_GLASS"] = 7;
                values["MATERIAL_GLAS"] = 7;
                values[valuesById[8] = "MATERIAL_MUD"] = 8;
                return values;
            })();

            /**
             * Density enum.
             * @name osi3.StationaryObject.Classification.Density
             * @enum {number}
             * @property {number} DENSITY_UNKNOWN=0 DENSITY_UNKNOWN value
             * @property {number} DENSITY_OTHER=1 DENSITY_OTHER value
             * @property {number} DENSITY_SOLID=2 DENSITY_SOLID value
             * @property {number} DENSITY_SMALL_MESH=3 DENSITY_SMALL_MESH value
             * @property {number} DENSITY_MEDIAN_MESH=4 DENSITY_MEDIAN_MESH value
             * @property {number} DENSITY_LARGE_MESH=5 DENSITY_LARGE_MESH value
             * @property {number} DENSITY_OPEN=6 DENSITY_OPEN value
             */
            Classification.Density = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "DENSITY_UNKNOWN"] = 0;
                values[valuesById[1] = "DENSITY_OTHER"] = 1;
                values[valuesById[2] = "DENSITY_SOLID"] = 2;
                values[valuesById[3] = "DENSITY_SMALL_MESH"] = 3;
                values[valuesById[4] = "DENSITY_MEDIAN_MESH"] = 4;
                values[valuesById[5] = "DENSITY_LARGE_MESH"] = 5;
                values[valuesById[6] = "DENSITY_OPEN"] = 6;
                return values;
            })();

            /**
             * Color enum.
             * @name osi3.StationaryObject.Classification.Color
             * @enum {number}
             * @property {number} COLOR_UNKNOWN=0 COLOR_UNKNOWN value
             * @property {number} COLOR_OTHER=1 COLOR_OTHER value
             * @property {number} COLOR_YELLOW=2 COLOR_YELLOW value
             * @property {number} COLOR_GREEN=3 COLOR_GREEN value
             * @property {number} COLOR_BLUE=4 COLOR_BLUE value
             * @property {number} COLOR_VIOLET=5 COLOR_VIOLET value
             * @property {number} COLOR_RED=6 COLOR_RED value
             * @property {number} COLOR_ORANGE=7 COLOR_ORANGE value
             * @property {number} COLOR_BLACK=8 COLOR_BLACK value
             * @property {number} COLOR_GRAY=9 COLOR_GRAY value
             * @property {number} COLOR_GREY=9 COLOR_GREY value
             * @property {number} COLOR_WHITE=10 COLOR_WHITE value
             */
            Classification.Color = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "COLOR_UNKNOWN"] = 0;
                values[valuesById[1] = "COLOR_OTHER"] = 1;
                values[valuesById[2] = "COLOR_YELLOW"] = 2;
                values[valuesById[3] = "COLOR_GREEN"] = 3;
                values[valuesById[4] = "COLOR_BLUE"] = 4;
                values[valuesById[5] = "COLOR_VIOLET"] = 5;
                values[valuesById[6] = "COLOR_RED"] = 6;
                values[valuesById[7] = "COLOR_ORANGE"] = 7;
                values[valuesById[8] = "COLOR_BLACK"] = 8;
                values[valuesById[9] = "COLOR_GRAY"] = 9;
                values["COLOR_GREY"] = 9;
                values[valuesById[10] = "COLOR_WHITE"] = 10;
                return values;
            })();

            Classification.EmittingStructureAttribute = (function() {

                /**
                 * Properties of an EmittingStructureAttribute.
                 * @memberof osi3.StationaryObject.Classification
                 * @interface IEmittingStructureAttribute
                 * @property {Array.<osi3.IWavelengthData>|null} [wavelengthData] EmittingStructureAttribute wavelengthData
                 * @property {Array.<osi3.ISpatialSignalStrength>|null} [emittedSpatialSignalStrength] EmittingStructureAttribute emittedSpatialSignalStrength
                 */

                /**
                 * Constructs a new EmittingStructureAttribute.
                 * @memberof osi3.StationaryObject.Classification
                 * @classdesc Represents an EmittingStructureAttribute.
                 * @implements IEmittingStructureAttribute
                 * @constructor
                 * @param {osi3.StationaryObject.Classification.IEmittingStructureAttribute=} [properties] Properties to set
                 */
                function EmittingStructureAttribute(properties) {
                    this.wavelengthData = [];
                    this.emittedSpatialSignalStrength = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * EmittingStructureAttribute wavelengthData.
                 * @member {Array.<osi3.IWavelengthData>} wavelengthData
                 * @memberof osi3.StationaryObject.Classification.EmittingStructureAttribute
                 * @instance
                 */
                EmittingStructureAttribute.prototype.wavelengthData = $util.emptyArray;

                /**
                 * EmittingStructureAttribute emittedSpatialSignalStrength.
                 * @member {Array.<osi3.ISpatialSignalStrength>} emittedSpatialSignalStrength
                 * @memberof osi3.StationaryObject.Classification.EmittingStructureAttribute
                 * @instance
                 */
                EmittingStructureAttribute.prototype.emittedSpatialSignalStrength = $util.emptyArray;

                /**
                 * Creates a new EmittingStructureAttribute instance using the specified properties.
                 * @function create
                 * @memberof osi3.StationaryObject.Classification.EmittingStructureAttribute
                 * @static
                 * @param {osi3.StationaryObject.Classification.IEmittingStructureAttribute=} [properties] Properties to set
                 * @returns {osi3.StationaryObject.Classification.EmittingStructureAttribute} EmittingStructureAttribute instance
                 */
                EmittingStructureAttribute.create = function create(properties) {
                    return new EmittingStructureAttribute(properties);
                };

                /**
                 * Encodes the specified EmittingStructureAttribute message. Does not implicitly {@link osi3.StationaryObject.Classification.EmittingStructureAttribute.verify|verify} messages.
                 * @function encode
                 * @memberof osi3.StationaryObject.Classification.EmittingStructureAttribute
                 * @static
                 * @param {osi3.StationaryObject.Classification.IEmittingStructureAttribute} message EmittingStructureAttribute message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EmittingStructureAttribute.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.wavelengthData != null && message.wavelengthData.length)
                        for (let i = 0; i < message.wavelengthData.length; ++i)
                            $root.osi3.WavelengthData.encode(message.wavelengthData[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.emittedSpatialSignalStrength != null && message.emittedSpatialSignalStrength.length)
                        for (let i = 0; i < message.emittedSpatialSignalStrength.length; ++i)
                            $root.osi3.SpatialSignalStrength.encode(message.emittedSpatialSignalStrength[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified EmittingStructureAttribute message, length delimited. Does not implicitly {@link osi3.StationaryObject.Classification.EmittingStructureAttribute.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof osi3.StationaryObject.Classification.EmittingStructureAttribute
                 * @static
                 * @param {osi3.StationaryObject.Classification.IEmittingStructureAttribute} message EmittingStructureAttribute message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EmittingStructureAttribute.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an EmittingStructureAttribute message from the specified reader or buffer.
                 * @function decode
                 * @memberof osi3.StationaryObject.Classification.EmittingStructureAttribute
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {osi3.StationaryObject.Classification.EmittingStructureAttribute} EmittingStructureAttribute
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EmittingStructureAttribute.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.osi3.StationaryObject.Classification.EmittingStructureAttribute();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                if (!(message.wavelengthData && message.wavelengthData.length))
                                    message.wavelengthData = [];
                                message.wavelengthData.push($root.osi3.WavelengthData.decode(reader, reader.uint32()));
                                break;
                            }
                        case 3: {
                                if (!(message.emittedSpatialSignalStrength && message.emittedSpatialSignalStrength.length))
                                    message.emittedSpatialSignalStrength = [];
                                message.emittedSpatialSignalStrength.push($root.osi3.SpatialSignalStrength.decode(reader, reader.uint32()));
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an EmittingStructureAttribute message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof osi3.StationaryObject.Classification.EmittingStructureAttribute
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {osi3.StationaryObject.Classification.EmittingStructureAttribute} EmittingStructureAttribute
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EmittingStructureAttribute.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an EmittingStructureAttribute message.
                 * @function verify
                 * @memberof osi3.StationaryObject.Classification.EmittingStructureAttribute
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                EmittingStructureAttribute.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.wavelengthData != null && message.hasOwnProperty("wavelengthData")) {
                        if (!Array.isArray(message.wavelengthData))
                            return "wavelengthData: array expected";
                        for (let i = 0; i < message.wavelengthData.length; ++i) {
                            let error = $root.osi3.WavelengthData.verify(message.wavelengthData[i]);
                            if (error)
                                return "wavelengthData." + error;
                        }
                    }
                    if (message.emittedSpatialSignalStrength != null && message.hasOwnProperty("emittedSpatialSignalStrength")) {
                        if (!Array.isArray(message.emittedSpatialSignalStrength))
                            return "emittedSpatialSignalStrength: array expected";
                        for (let i = 0; i < message.emittedSpatialSignalStrength.length; ++i) {
                            let error = $root.osi3.SpatialSignalStrength.verify(message.emittedSpatialSignalStrength[i]);
                            if (error)
                                return "emittedSpatialSignalStrength." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates an EmittingStructureAttribute message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof osi3.StationaryObject.Classification.EmittingStructureAttribute
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {osi3.StationaryObject.Classification.EmittingStructureAttribute} EmittingStructureAttribute
                 */
                EmittingStructureAttribute.fromObject = function fromObject(object) {
                    if (object instanceof $root.osi3.StationaryObject.Classification.EmittingStructureAttribute)
                        return object;
                    let message = new $root.osi3.StationaryObject.Classification.EmittingStructureAttribute();
                    if (object.wavelengthData) {
                        if (!Array.isArray(object.wavelengthData))
                            throw TypeError(".osi3.StationaryObject.Classification.EmittingStructureAttribute.wavelengthData: array expected");
                        message.wavelengthData = [];
                        for (let i = 0; i < object.wavelengthData.length; ++i) {
                            if (typeof object.wavelengthData[i] !== "object")
                                throw TypeError(".osi3.StationaryObject.Classification.EmittingStructureAttribute.wavelengthData: object expected");
                            message.wavelengthData[i] = $root.osi3.WavelengthData.fromObject(object.wavelengthData[i]);
                        }
                    }
                    if (object.emittedSpatialSignalStrength) {
                        if (!Array.isArray(object.emittedSpatialSignalStrength))
                            throw TypeError(".osi3.StationaryObject.Classification.EmittingStructureAttribute.emittedSpatialSignalStrength: array expected");
                        message.emittedSpatialSignalStrength = [];
                        for (let i = 0; i < object.emittedSpatialSignalStrength.length; ++i) {
                            if (typeof object.emittedSpatialSignalStrength[i] !== "object")
                                throw TypeError(".osi3.StationaryObject.Classification.EmittingStructureAttribute.emittedSpatialSignalStrength: object expected");
                            message.emittedSpatialSignalStrength[i] = $root.osi3.SpatialSignalStrength.fromObject(object.emittedSpatialSignalStrength[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from an EmittingStructureAttribute message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof osi3.StationaryObject.Classification.EmittingStructureAttribute
                 * @static
                 * @param {osi3.StationaryObject.Classification.EmittingStructureAttribute} message EmittingStructureAttribute
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                EmittingStructureAttribute.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults) {
                        object.wavelengthData = [];
                        object.emittedSpatialSignalStrength = [];
                    }
                    if (message.wavelengthData && message.wavelengthData.length) {
                        object.wavelengthData = [];
                        for (let j = 0; j < message.wavelengthData.length; ++j)
                            object.wavelengthData[j] = $root.osi3.WavelengthData.toObject(message.wavelengthData[j], options);
                    }
                    if (message.emittedSpatialSignalStrength && message.emittedSpatialSignalStrength.length) {
                        object.emittedSpatialSignalStrength = [];
                        for (let j = 0; j < message.emittedSpatialSignalStrength.length; ++j)
                            object.emittedSpatialSignalStrength[j] = $root.osi3.SpatialSignalStrength.toObject(message.emittedSpatialSignalStrength[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this EmittingStructureAttribute to JSON.
                 * @function toJSON
                 * @memberof osi3.StationaryObject.Classification.EmittingStructureAttribute
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                EmittingStructureAttribute.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for EmittingStructureAttribute
                 * @function getTypeUrl
                 * @memberof osi3.StationaryObject.Classification.EmittingStructureAttribute
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                EmittingStructureAttribute.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/osi3.StationaryObject.Classification.EmittingStructureAttribute";
                };

                return EmittingStructureAttribute;
            })();

            return Classification;
        })();

        return StationaryObject;
    })();

    osi3.MovingObject = (function() {

        /**
         * Properties of a MovingObject.
         * @memberof osi3
         * @interface IMovingObject
         * @property {osi3.IIdentifier|null} [id] MovingObject id
         * @property {osi3.IBaseMoving|null} [base] MovingObject base
         * @property {osi3.MovingObject.Type|null} [type] MovingObject type
         * @property {Array.<osi3.IIdentifier>|null} [assignedLaneId] MovingObject assignedLaneId
         * @property {osi3.MovingObject.IVehicleAttributes|null} [vehicleAttributes] MovingObject vehicleAttributes
         * @property {osi3.MovingObject.IVehicleClassification|null} [vehicleClassification] MovingObject vehicleClassification
         * @property {string|null} [modelReference] MovingObject modelReference
         * @property {Array.<osi3.IStatePoint>|null} [futureTrajectory] MovingObject futureTrajectory
         * @property {osi3.MovingObject.IMovingObjectClassification|null} [movingObjectClassification] MovingObject movingObjectClassification
         * @property {Array.<osi3.IExternalReference>|null} [sourceReference] MovingObject sourceReference
         * @property {osi3.IColorDescription|null} [colorDescription] MovingObject colorDescription
         * @property {osi3.MovingObject.IPedestrianAttributes|null} [pedestrianAttributes] MovingObject pedestrianAttributes
         */

        /**
         * Constructs a new MovingObject.
         * @memberof osi3
         * @classdesc Represents a MovingObject.
         * @implements IMovingObject
         * @constructor
         * @param {osi3.IMovingObject=} [properties] Properties to set
         */
        function MovingObject(properties) {
            this.assignedLaneId = [];
            this.futureTrajectory = [];
            this.sourceReference = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MovingObject id.
         * @member {osi3.IIdentifier|null|undefined} id
         * @memberof osi3.MovingObject
         * @instance
         */
        MovingObject.prototype.id = null;

        /**
         * MovingObject base.
         * @member {osi3.IBaseMoving|null|undefined} base
         * @memberof osi3.MovingObject
         * @instance
         */
        MovingObject.prototype.base = null;

        /**
         * MovingObject type.
         * @member {osi3.MovingObject.Type} type
         * @memberof osi3.MovingObject
         * @instance
         */
        MovingObject.prototype.type = 0;

        /**
         * MovingObject assignedLaneId.
         * @member {Array.<osi3.IIdentifier>} assignedLaneId
         * @memberof osi3.MovingObject
         * @instance
         */
        MovingObject.prototype.assignedLaneId = $util.emptyArray;

        /**
         * MovingObject vehicleAttributes.
         * @member {osi3.MovingObject.IVehicleAttributes|null|undefined} vehicleAttributes
         * @memberof osi3.MovingObject
         * @instance
         */
        MovingObject.prototype.vehicleAttributes = null;

        /**
         * MovingObject vehicleClassification.
         * @member {osi3.MovingObject.IVehicleClassification|null|undefined} vehicleClassification
         * @memberof osi3.MovingObject
         * @instance
         */
        MovingObject.prototype.vehicleClassification = null;

        /**
         * MovingObject modelReference.
         * @member {string} modelReference
         * @memberof osi3.MovingObject
         * @instance
         */
        MovingObject.prototype.modelReference = "";

        /**
         * MovingObject futureTrajectory.
         * @member {Array.<osi3.IStatePoint>} futureTrajectory
         * @memberof osi3.MovingObject
         * @instance
         */
        MovingObject.prototype.futureTrajectory = $util.emptyArray;

        /**
         * MovingObject movingObjectClassification.
         * @member {osi3.MovingObject.IMovingObjectClassification|null|undefined} movingObjectClassification
         * @memberof osi3.MovingObject
         * @instance
         */
        MovingObject.prototype.movingObjectClassification = null;

        /**
         * MovingObject sourceReference.
         * @member {Array.<osi3.IExternalReference>} sourceReference
         * @memberof osi3.MovingObject
         * @instance
         */
        MovingObject.prototype.sourceReference = $util.emptyArray;

        /**
         * MovingObject colorDescription.
         * @member {osi3.IColorDescription|null|undefined} colorDescription
         * @memberof osi3.MovingObject
         * @instance
         */
        MovingObject.prototype.colorDescription = null;

        /**
         * MovingObject pedestrianAttributes.
         * @member {osi3.MovingObject.IPedestrianAttributes|null|undefined} pedestrianAttributes
         * @memberof osi3.MovingObject
         * @instance
         */
        MovingObject.prototype.pedestrianAttributes = null;

        /**
         * Creates a new MovingObject instance using the specified properties.
         * @function create
         * @memberof osi3.MovingObject
         * @static
         * @param {osi3.IMovingObject=} [properties] Properties to set
         * @returns {osi3.MovingObject} MovingObject instance
         */
        MovingObject.create = function create(properties) {
            return new MovingObject(properties);
        };

        /**
         * Encodes the specified MovingObject message. Does not implicitly {@link osi3.MovingObject.verify|verify} messages.
         * @function encode
         * @memberof osi3.MovingObject
         * @static
         * @param {osi3.IMovingObject} message MovingObject message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MovingObject.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                $root.osi3.Identifier.encode(message.id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.base != null && Object.hasOwnProperty.call(message, "base"))
                $root.osi3.BaseMoving.encode(message.base, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.type);
            if (message.assignedLaneId != null && message.assignedLaneId.length)
                for (let i = 0; i < message.assignedLaneId.length; ++i)
                    $root.osi3.Identifier.encode(message.assignedLaneId[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.vehicleAttributes != null && Object.hasOwnProperty.call(message, "vehicleAttributes"))
                $root.osi3.MovingObject.VehicleAttributes.encode(message.vehicleAttributes, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.vehicleClassification != null && Object.hasOwnProperty.call(message, "vehicleClassification"))
                $root.osi3.MovingObject.VehicleClassification.encode(message.vehicleClassification, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.modelReference != null && Object.hasOwnProperty.call(message, "modelReference"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.modelReference);
            if (message.futureTrajectory != null && message.futureTrajectory.length)
                for (let i = 0; i < message.futureTrajectory.length; ++i)
                    $root.osi3.StatePoint.encode(message.futureTrajectory[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.movingObjectClassification != null && Object.hasOwnProperty.call(message, "movingObjectClassification"))
                $root.osi3.MovingObject.MovingObjectClassification.encode(message.movingObjectClassification, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            if (message.sourceReference != null && message.sourceReference.length)
                for (let i = 0; i < message.sourceReference.length; ++i)
                    $root.osi3.ExternalReference.encode(message.sourceReference[i], writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            if (message.colorDescription != null && Object.hasOwnProperty.call(message, "colorDescription"))
                $root.osi3.ColorDescription.encode(message.colorDescription, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
            if (message.pedestrianAttributes != null && Object.hasOwnProperty.call(message, "pedestrianAttributes"))
                $root.osi3.MovingObject.PedestrianAttributes.encode(message.pedestrianAttributes, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified MovingObject message, length delimited. Does not implicitly {@link osi3.MovingObject.verify|verify} messages.
         * @function encodeDelimited
         * @memberof osi3.MovingObject
         * @static
         * @param {osi3.IMovingObject} message MovingObject message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MovingObject.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MovingObject message from the specified reader or buffer.
         * @function decode
         * @memberof osi3.MovingObject
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {osi3.MovingObject} MovingObject
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MovingObject.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.osi3.MovingObject();
            while (reader.pos < end) {
                let tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.id = $root.osi3.Identifier.decode(reader, reader.uint32());
                        break;
                    }
                case 2: {
                        message.base = $root.osi3.BaseMoving.decode(reader, reader.uint32());
                        break;
                    }
                case 3: {
                        message.type = reader.int32();
                        break;
                    }
                case 4: {
                        if (!(message.assignedLaneId && message.assignedLaneId.length))
                            message.assignedLaneId = [];
                        message.assignedLaneId.push($root.osi3.Identifier.decode(reader, reader.uint32()));
                        break;
                    }
                case 5: {
                        message.vehicleAttributes = $root.osi3.MovingObject.VehicleAttributes.decode(reader, reader.uint32());
                        break;
                    }
                case 6: {
                        message.vehicleClassification = $root.osi3.MovingObject.VehicleClassification.decode(reader, reader.uint32());
                        break;
                    }
                case 7: {
                        message.modelReference = reader.string();
                        break;
                    }
                case 8: {
                        if (!(message.futureTrajectory && message.futureTrajectory.length))
                            message.futureTrajectory = [];
                        message.futureTrajectory.push($root.osi3.StatePoint.decode(reader, reader.uint32()));
                        break;
                    }
                case 9: {
                        message.movingObjectClassification = $root.osi3.MovingObject.MovingObjectClassification.decode(reader, reader.uint32());
                        break;
                    }
                case 10: {
                        if (!(message.sourceReference && message.sourceReference.length))
                            message.sourceReference = [];
                        message.sourceReference.push($root.osi3.ExternalReference.decode(reader, reader.uint32()));
                        break;
                    }
                case 11: {
                        message.colorDescription = $root.osi3.ColorDescription.decode(reader, reader.uint32());
                        break;
                    }
                case 12: {
                        message.pedestrianAttributes = $root.osi3.MovingObject.PedestrianAttributes.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MovingObject message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof osi3.MovingObject
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {osi3.MovingObject} MovingObject
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MovingObject.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MovingObject message.
         * @function verify
         * @memberof osi3.MovingObject
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MovingObject.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id")) {
                let error = $root.osi3.Identifier.verify(message.id);
                if (error)
                    return "id." + error;
            }
            if (message.base != null && message.hasOwnProperty("base")) {
                let error = $root.osi3.BaseMoving.verify(message.base);
                if (error)
                    return "base." + error;
            }
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                    break;
                }
            if (message.assignedLaneId != null && message.hasOwnProperty("assignedLaneId")) {
                if (!Array.isArray(message.assignedLaneId))
                    return "assignedLaneId: array expected";
                for (let i = 0; i < message.assignedLaneId.length; ++i) {
                    let error = $root.osi3.Identifier.verify(message.assignedLaneId[i]);
                    if (error)
                        return "assignedLaneId." + error;
                }
            }
            if (message.vehicleAttributes != null && message.hasOwnProperty("vehicleAttributes")) {
                let error = $root.osi3.MovingObject.VehicleAttributes.verify(message.vehicleAttributes);
                if (error)
                    return "vehicleAttributes." + error;
            }
            if (message.vehicleClassification != null && message.hasOwnProperty("vehicleClassification")) {
                let error = $root.osi3.MovingObject.VehicleClassification.verify(message.vehicleClassification);
                if (error)
                    return "vehicleClassification." + error;
            }
            if (message.modelReference != null && message.hasOwnProperty("modelReference"))
                if (!$util.isString(message.modelReference))
                    return "modelReference: string expected";
            if (message.futureTrajectory != null && message.hasOwnProperty("futureTrajectory")) {
                if (!Array.isArray(message.futureTrajectory))
                    return "futureTrajectory: array expected";
                for (let i = 0; i < message.futureTrajectory.length; ++i) {
                    let error = $root.osi3.StatePoint.verify(message.futureTrajectory[i]);
                    if (error)
                        return "futureTrajectory." + error;
                }
            }
            if (message.movingObjectClassification != null && message.hasOwnProperty("movingObjectClassification")) {
                let error = $root.osi3.MovingObject.MovingObjectClassification.verify(message.movingObjectClassification);
                if (error)
                    return "movingObjectClassification." + error;
            }
            if (message.sourceReference != null && message.hasOwnProperty("sourceReference")) {
                if (!Array.isArray(message.sourceReference))
                    return "sourceReference: array expected";
                for (let i = 0; i < message.sourceReference.length; ++i) {
                    let error = $root.osi3.ExternalReference.verify(message.sourceReference[i]);
                    if (error)
                        return "sourceReference." + error;
                }
            }
            if (message.colorDescription != null && message.hasOwnProperty("colorDescription")) {
                let error = $root.osi3.ColorDescription.verify(message.colorDescription);
                if (error)
                    return "colorDescription." + error;
            }
            if (message.pedestrianAttributes != null && message.hasOwnProperty("pedestrianAttributes")) {
                let error = $root.osi3.MovingObject.PedestrianAttributes.verify(message.pedestrianAttributes);
                if (error)
                    return "pedestrianAttributes." + error;
            }
            return null;
        };

        /**
         * Creates a MovingObject message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof osi3.MovingObject
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {osi3.MovingObject} MovingObject
         */
        MovingObject.fromObject = function fromObject(object) {
            if (object instanceof $root.osi3.MovingObject)
                return object;
            let message = new $root.osi3.MovingObject();
            if (object.id != null) {
                if (typeof object.id !== "object")
                    throw TypeError(".osi3.MovingObject.id: object expected");
                message.id = $root.osi3.Identifier.fromObject(object.id);
            }
            if (object.base != null) {
                if (typeof object.base !== "object")
                    throw TypeError(".osi3.MovingObject.base: object expected");
                message.base = $root.osi3.BaseMoving.fromObject(object.base);
            }
            switch (object.type) {
            default:
                if (typeof object.type === "number") {
                    message.type = object.type;
                    break;
                }
                break;
            case "TYPE_UNKNOWN":
            case 0:
                message.type = 0;
                break;
            case "TYPE_OTHER":
            case 1:
                message.type = 1;
                break;
            case "TYPE_VEHICLE":
            case 2:
                message.type = 2;
                break;
            case "TYPE_PEDESTRIAN":
            case 3:
                message.type = 3;
                break;
            case "TYPE_ANIMAL":
            case 4:
                message.type = 4;
                break;
            }
            if (object.assignedLaneId) {
                if (!Array.isArray(object.assignedLaneId))
                    throw TypeError(".osi3.MovingObject.assignedLaneId: array expected");
                message.assignedLaneId = [];
                for (let i = 0; i < object.assignedLaneId.length; ++i) {
                    if (typeof object.assignedLaneId[i] !== "object")
                        throw TypeError(".osi3.MovingObject.assignedLaneId: object expected");
                    message.assignedLaneId[i] = $root.osi3.Identifier.fromObject(object.assignedLaneId[i]);
                }
            }
            if (object.vehicleAttributes != null) {
                if (typeof object.vehicleAttributes !== "object")
                    throw TypeError(".osi3.MovingObject.vehicleAttributes: object expected");
                message.vehicleAttributes = $root.osi3.MovingObject.VehicleAttributes.fromObject(object.vehicleAttributes);
            }
            if (object.vehicleClassification != null) {
                if (typeof object.vehicleClassification !== "object")
                    throw TypeError(".osi3.MovingObject.vehicleClassification: object expected");
                message.vehicleClassification = $root.osi3.MovingObject.VehicleClassification.fromObject(object.vehicleClassification);
            }
            if (object.modelReference != null)
                message.modelReference = String(object.modelReference);
            if (object.futureTrajectory) {
                if (!Array.isArray(object.futureTrajectory))
                    throw TypeError(".osi3.MovingObject.futureTrajectory: array expected");
                message.futureTrajectory = [];
                for (let i = 0; i < object.futureTrajectory.length; ++i) {
                    if (typeof object.futureTrajectory[i] !== "object")
                        throw TypeError(".osi3.MovingObject.futureTrajectory: object expected");
                    message.futureTrajectory[i] = $root.osi3.StatePoint.fromObject(object.futureTrajectory[i]);
                }
            }
            if (object.movingObjectClassification != null) {
                if (typeof object.movingObjectClassification !== "object")
                    throw TypeError(".osi3.MovingObject.movingObjectClassification: object expected");
                message.movingObjectClassification = $root.osi3.MovingObject.MovingObjectClassification.fromObject(object.movingObjectClassification);
            }
            if (object.sourceReference) {
                if (!Array.isArray(object.sourceReference))
                    throw TypeError(".osi3.MovingObject.sourceReference: array expected");
                message.sourceReference = [];
                for (let i = 0; i < object.sourceReference.length; ++i) {
                    if (typeof object.sourceReference[i] !== "object")
                        throw TypeError(".osi3.MovingObject.sourceReference: object expected");
                    message.sourceReference[i] = $root.osi3.ExternalReference.fromObject(object.sourceReference[i]);
                }
            }
            if (object.colorDescription != null) {
                if (typeof object.colorDescription !== "object")
                    throw TypeError(".osi3.MovingObject.colorDescription: object expected");
                message.colorDescription = $root.osi3.ColorDescription.fromObject(object.colorDescription);
            }
            if (object.pedestrianAttributes != null) {
                if (typeof object.pedestrianAttributes !== "object")
                    throw TypeError(".osi3.MovingObject.pedestrianAttributes: object expected");
                message.pedestrianAttributes = $root.osi3.MovingObject.PedestrianAttributes.fromObject(object.pedestrianAttributes);
            }
            return message;
        };

        /**
         * Creates a plain object from a MovingObject message. Also converts values to other types if specified.
         * @function toObject
         * @memberof osi3.MovingObject
         * @static
         * @param {osi3.MovingObject} message MovingObject
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MovingObject.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.assignedLaneId = [];
                object.futureTrajectory = [];
                object.sourceReference = [];
            }
            if (options.defaults) {
                object.id = null;
                object.base = null;
                object.type = options.enums === String ? "TYPE_UNKNOWN" : 0;
                object.vehicleAttributes = null;
                object.vehicleClassification = null;
                object.modelReference = "";
                object.movingObjectClassification = null;
                object.colorDescription = null;
                object.pedestrianAttributes = null;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = $root.osi3.Identifier.toObject(message.id, options);
            if (message.base != null && message.hasOwnProperty("base"))
                object.base = $root.osi3.BaseMoving.toObject(message.base, options);
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.osi3.MovingObject.Type[message.type] === undefined ? message.type : $root.osi3.MovingObject.Type[message.type] : message.type;
            if (message.assignedLaneId && message.assignedLaneId.length) {
                object.assignedLaneId = [];
                for (let j = 0; j < message.assignedLaneId.length; ++j)
                    object.assignedLaneId[j] = $root.osi3.Identifier.toObject(message.assignedLaneId[j], options);
            }
            if (message.vehicleAttributes != null && message.hasOwnProperty("vehicleAttributes"))
                object.vehicleAttributes = $root.osi3.MovingObject.VehicleAttributes.toObject(message.vehicleAttributes, options);
            if (message.vehicleClassification != null && message.hasOwnProperty("vehicleClassification"))
                object.vehicleClassification = $root.osi3.MovingObject.VehicleClassification.toObject(message.vehicleClassification, options);
            if (message.modelReference != null && message.hasOwnProperty("modelReference"))
                object.modelReference = message.modelReference;
            if (message.futureTrajectory && message.futureTrajectory.length) {
                object.futureTrajectory = [];
                for (let j = 0; j < message.futureTrajectory.length; ++j)
                    object.futureTrajectory[j] = $root.osi3.StatePoint.toObject(message.futureTrajectory[j], options);
            }
            if (message.movingObjectClassification != null && message.hasOwnProperty("movingObjectClassification"))
                object.movingObjectClassification = $root.osi3.MovingObject.MovingObjectClassification.toObject(message.movingObjectClassification, options);
            if (message.sourceReference && message.sourceReference.length) {
                object.sourceReference = [];
                for (let j = 0; j < message.sourceReference.length; ++j)
                    object.sourceReference[j] = $root.osi3.ExternalReference.toObject(message.sourceReference[j], options);
            }
            if (message.colorDescription != null && message.hasOwnProperty("colorDescription"))
                object.colorDescription = $root.osi3.ColorDescription.toObject(message.colorDescription, options);
            if (message.pedestrianAttributes != null && message.hasOwnProperty("pedestrianAttributes"))
                object.pedestrianAttributes = $root.osi3.MovingObject.PedestrianAttributes.toObject(message.pedestrianAttributes, options);
            return object;
        };

        /**
         * Converts this MovingObject to JSON.
         * @function toJSON
         * @memberof osi3.MovingObject
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MovingObject.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for MovingObject
         * @function getTypeUrl
         * @memberof osi3.MovingObject
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        MovingObject.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/osi3.MovingObject";
        };

        /**
         * Type enum.
         * @name osi3.MovingObject.Type
         * @enum {number}
         * @property {number} TYPE_UNKNOWN=0 TYPE_UNKNOWN value
         * @property {number} TYPE_OTHER=1 TYPE_OTHER value
         * @property {number} TYPE_VEHICLE=2 TYPE_VEHICLE value
         * @property {number} TYPE_PEDESTRIAN=3 TYPE_PEDESTRIAN value
         * @property {number} TYPE_ANIMAL=4 TYPE_ANIMAL value
         */
        MovingObject.Type = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "TYPE_UNKNOWN"] = 0;
            values[valuesById[1] = "TYPE_OTHER"] = 1;
            values[valuesById[2] = "TYPE_VEHICLE"] = 2;
            values[valuesById[3] = "TYPE_PEDESTRIAN"] = 3;
            values[valuesById[4] = "TYPE_ANIMAL"] = 4;
            return values;
        })();

        MovingObject.VehicleAttributes = (function() {

            /**
             * Properties of a VehicleAttributes.
             * @memberof osi3.MovingObject
             * @interface IVehicleAttributes
             * @property {osi3.IIdentifier|null} [driverId] VehicleAttributes driverId
             * @property {number|null} [radiusWheel] VehicleAttributes radiusWheel
             * @property {number|null} [numberWheels] VehicleAttributes numberWheels
             * @property {osi3.IVector3d|null} [bbcenterToRear] VehicleAttributes bbcenterToRear
             * @property {osi3.IVector3d|null} [bbcenterToFront] VehicleAttributes bbcenterToFront
             * @property {number|null} [groundClearance] VehicleAttributes groundClearance
             * @property {Array.<osi3.MovingObject.VehicleAttributes.IWheelData>|null} [wheelData] VehicleAttributes wheelData
             * @property {number|null} [steeringWheelAngle] VehicleAttributes steeringWheelAngle
             */

            /**
             * Constructs a new VehicleAttributes.
             * @memberof osi3.MovingObject
             * @classdesc Represents a VehicleAttributes.
             * @implements IVehicleAttributes
             * @constructor
             * @param {osi3.MovingObject.IVehicleAttributes=} [properties] Properties to set
             */
            function VehicleAttributes(properties) {
                this.wheelData = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * VehicleAttributes driverId.
             * @member {osi3.IIdentifier|null|undefined} driverId
             * @memberof osi3.MovingObject.VehicleAttributes
             * @instance
             */
            VehicleAttributes.prototype.driverId = null;

            /**
             * VehicleAttributes radiusWheel.
             * @member {number} radiusWheel
             * @memberof osi3.MovingObject.VehicleAttributes
             * @instance
             */
            VehicleAttributes.prototype.radiusWheel = 0;

            /**
             * VehicleAttributes numberWheels.
             * @member {number} numberWheels
             * @memberof osi3.MovingObject.VehicleAttributes
             * @instance
             */
            VehicleAttributes.prototype.numberWheels = 0;

            /**
             * VehicleAttributes bbcenterToRear.
             * @member {osi3.IVector3d|null|undefined} bbcenterToRear
             * @memberof osi3.MovingObject.VehicleAttributes
             * @instance
             */
            VehicleAttributes.prototype.bbcenterToRear = null;

            /**
             * VehicleAttributes bbcenterToFront.
             * @member {osi3.IVector3d|null|undefined} bbcenterToFront
             * @memberof osi3.MovingObject.VehicleAttributes
             * @instance
             */
            VehicleAttributes.prototype.bbcenterToFront = null;

            /**
             * VehicleAttributes groundClearance.
             * @member {number} groundClearance
             * @memberof osi3.MovingObject.VehicleAttributes
             * @instance
             */
            VehicleAttributes.prototype.groundClearance = 0;

            /**
             * VehicleAttributes wheelData.
             * @member {Array.<osi3.MovingObject.VehicleAttributes.IWheelData>} wheelData
             * @memberof osi3.MovingObject.VehicleAttributes
             * @instance
             */
            VehicleAttributes.prototype.wheelData = $util.emptyArray;

            /**
             * VehicleAttributes steeringWheelAngle.
             * @member {number} steeringWheelAngle
             * @memberof osi3.MovingObject.VehicleAttributes
             * @instance
             */
            VehicleAttributes.prototype.steeringWheelAngle = 0;

            /**
             * Creates a new VehicleAttributes instance using the specified properties.
             * @function create
             * @memberof osi3.MovingObject.VehicleAttributes
             * @static
             * @param {osi3.MovingObject.IVehicleAttributes=} [properties] Properties to set
             * @returns {osi3.MovingObject.VehicleAttributes} VehicleAttributes instance
             */
            VehicleAttributes.create = function create(properties) {
                return new VehicleAttributes(properties);
            };

            /**
             * Encodes the specified VehicleAttributes message. Does not implicitly {@link osi3.MovingObject.VehicleAttributes.verify|verify} messages.
             * @function encode
             * @memberof osi3.MovingObject.VehicleAttributes
             * @static
             * @param {osi3.MovingObject.IVehicleAttributes} message VehicleAttributes message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            VehicleAttributes.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.driverId != null && Object.hasOwnProperty.call(message, "driverId"))
                    $root.osi3.Identifier.encode(message.driverId, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.radiusWheel != null && Object.hasOwnProperty.call(message, "radiusWheel"))
                    writer.uint32(/* id 2, wireType 1 =*/17).double(message.radiusWheel);
                if (message.numberWheels != null && Object.hasOwnProperty.call(message, "numberWheels"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.numberWheels);
                if (message.bbcenterToRear != null && Object.hasOwnProperty.call(message, "bbcenterToRear"))
                    $root.osi3.Vector3d.encode(message.bbcenterToRear, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.bbcenterToFront != null && Object.hasOwnProperty.call(message, "bbcenterToFront"))
                    $root.osi3.Vector3d.encode(message.bbcenterToFront, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.groundClearance != null && Object.hasOwnProperty.call(message, "groundClearance"))
                    writer.uint32(/* id 6, wireType 1 =*/49).double(message.groundClearance);
                if (message.wheelData != null && message.wheelData.length)
                    for (let i = 0; i < message.wheelData.length; ++i)
                        $root.osi3.MovingObject.VehicleAttributes.WheelData.encode(message.wheelData[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.steeringWheelAngle != null && Object.hasOwnProperty.call(message, "steeringWheelAngle"))
                    writer.uint32(/* id 8, wireType 1 =*/65).double(message.steeringWheelAngle);
                return writer;
            };

            /**
             * Encodes the specified VehicleAttributes message, length delimited. Does not implicitly {@link osi3.MovingObject.VehicleAttributes.verify|verify} messages.
             * @function encodeDelimited
             * @memberof osi3.MovingObject.VehicleAttributes
             * @static
             * @param {osi3.MovingObject.IVehicleAttributes} message VehicleAttributes message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            VehicleAttributes.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a VehicleAttributes message from the specified reader or buffer.
             * @function decode
             * @memberof osi3.MovingObject.VehicleAttributes
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {osi3.MovingObject.VehicleAttributes} VehicleAttributes
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            VehicleAttributes.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.osi3.MovingObject.VehicleAttributes();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.driverId = $root.osi3.Identifier.decode(reader, reader.uint32());
                            break;
                        }
                    case 2: {
                            message.radiusWheel = reader.double();
                            break;
                        }
                    case 3: {
                            message.numberWheels = reader.uint32();
                            break;
                        }
                    case 4: {
                            message.bbcenterToRear = $root.osi3.Vector3d.decode(reader, reader.uint32());
                            break;
                        }
                    case 5: {
                            message.bbcenterToFront = $root.osi3.Vector3d.decode(reader, reader.uint32());
                            break;
                        }
                    case 6: {
                            message.groundClearance = reader.double();
                            break;
                        }
                    case 7: {
                            if (!(message.wheelData && message.wheelData.length))
                                message.wheelData = [];
                            message.wheelData.push($root.osi3.MovingObject.VehicleAttributes.WheelData.decode(reader, reader.uint32()));
                            break;
                        }
                    case 8: {
                            message.steeringWheelAngle = reader.double();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a VehicleAttributes message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof osi3.MovingObject.VehicleAttributes
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {osi3.MovingObject.VehicleAttributes} VehicleAttributes
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            VehicleAttributes.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a VehicleAttributes message.
             * @function verify
             * @memberof osi3.MovingObject.VehicleAttributes
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            VehicleAttributes.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.driverId != null && message.hasOwnProperty("driverId")) {
                    let error = $root.osi3.Identifier.verify(message.driverId);
                    if (error)
                        return "driverId." + error;
                }
                if (message.radiusWheel != null && message.hasOwnProperty("radiusWheel"))
                    if (typeof message.radiusWheel !== "number")
                        return "radiusWheel: number expected";
                if (message.numberWheels != null && message.hasOwnProperty("numberWheels"))
                    if (!$util.isInteger(message.numberWheels))
                        return "numberWheels: integer expected";
                if (message.bbcenterToRear != null && message.hasOwnProperty("bbcenterToRear")) {
                    let error = $root.osi3.Vector3d.verify(message.bbcenterToRear);
                    if (error)
                        return "bbcenterToRear." + error;
                }
                if (message.bbcenterToFront != null && message.hasOwnProperty("bbcenterToFront")) {
                    let error = $root.osi3.Vector3d.verify(message.bbcenterToFront);
                    if (error)
                        return "bbcenterToFront." + error;
                }
                if (message.groundClearance != null && message.hasOwnProperty("groundClearance"))
                    if (typeof message.groundClearance !== "number")
                        return "groundClearance: number expected";
                if (message.wheelData != null && message.hasOwnProperty("wheelData")) {
                    if (!Array.isArray(message.wheelData))
                        return "wheelData: array expected";
                    for (let i = 0; i < message.wheelData.length; ++i) {
                        let error = $root.osi3.MovingObject.VehicleAttributes.WheelData.verify(message.wheelData[i]);
                        if (error)
                            return "wheelData." + error;
                    }
                }
                if (message.steeringWheelAngle != null && message.hasOwnProperty("steeringWheelAngle"))
                    if (typeof message.steeringWheelAngle !== "number")
                        return "steeringWheelAngle: number expected";
                return null;
            };

            /**
             * Creates a VehicleAttributes message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof osi3.MovingObject.VehicleAttributes
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {osi3.MovingObject.VehicleAttributes} VehicleAttributes
             */
            VehicleAttributes.fromObject = function fromObject(object) {
                if (object instanceof $root.osi3.MovingObject.VehicleAttributes)
                    return object;
                let message = new $root.osi3.MovingObject.VehicleAttributes();
                if (object.driverId != null) {
                    if (typeof object.driverId !== "object")
                        throw TypeError(".osi3.MovingObject.VehicleAttributes.driverId: object expected");
                    message.driverId = $root.osi3.Identifier.fromObject(object.driverId);
                }
                if (object.radiusWheel != null)
                    message.radiusWheel = Number(object.radiusWheel);
                if (object.numberWheels != null)
                    message.numberWheels = object.numberWheels >>> 0;
                if (object.bbcenterToRear != null) {
                    if (typeof object.bbcenterToRear !== "object")
                        throw TypeError(".osi3.MovingObject.VehicleAttributes.bbcenterToRear: object expected");
                    message.bbcenterToRear = $root.osi3.Vector3d.fromObject(object.bbcenterToRear);
                }
                if (object.bbcenterToFront != null) {
                    if (typeof object.bbcenterToFront !== "object")
                        throw TypeError(".osi3.MovingObject.VehicleAttributes.bbcenterToFront: object expected");
                    message.bbcenterToFront = $root.osi3.Vector3d.fromObject(object.bbcenterToFront);
                }
                if (object.groundClearance != null)
                    message.groundClearance = Number(object.groundClearance);
                if (object.wheelData) {
                    if (!Array.isArray(object.wheelData))
                        throw TypeError(".osi3.MovingObject.VehicleAttributes.wheelData: array expected");
                    message.wheelData = [];
                    for (let i = 0; i < object.wheelData.length; ++i) {
                        if (typeof object.wheelData[i] !== "object")
                            throw TypeError(".osi3.MovingObject.VehicleAttributes.wheelData: object expected");
                        message.wheelData[i] = $root.osi3.MovingObject.VehicleAttributes.WheelData.fromObject(object.wheelData[i]);
                    }
                }
                if (object.steeringWheelAngle != null)
                    message.steeringWheelAngle = Number(object.steeringWheelAngle);
                return message;
            };

            /**
             * Creates a plain object from a VehicleAttributes message. Also converts values to other types if specified.
             * @function toObject
             * @memberof osi3.MovingObject.VehicleAttributes
             * @static
             * @param {osi3.MovingObject.VehicleAttributes} message VehicleAttributes
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            VehicleAttributes.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.wheelData = [];
                if (options.defaults) {
                    object.driverId = null;
                    object.radiusWheel = 0;
                    object.numberWheels = 0;
                    object.bbcenterToRear = null;
                    object.bbcenterToFront = null;
                    object.groundClearance = 0;
                    object.steeringWheelAngle = 0;
                }
                if (message.driverId != null && message.hasOwnProperty("driverId"))
                    object.driverId = $root.osi3.Identifier.toObject(message.driverId, options);
                if (message.radiusWheel != null && message.hasOwnProperty("radiusWheel"))
                    object.radiusWheel = options.json && !isFinite(message.radiusWheel) ? String(message.radiusWheel) : message.radiusWheel;
                if (message.numberWheels != null && message.hasOwnProperty("numberWheels"))
                    object.numberWheels = message.numberWheels;
                if (message.bbcenterToRear != null && message.hasOwnProperty("bbcenterToRear"))
                    object.bbcenterToRear = $root.osi3.Vector3d.toObject(message.bbcenterToRear, options);
                if (message.bbcenterToFront != null && message.hasOwnProperty("bbcenterToFront"))
                    object.bbcenterToFront = $root.osi3.Vector3d.toObject(message.bbcenterToFront, options);
                if (message.groundClearance != null && message.hasOwnProperty("groundClearance"))
                    object.groundClearance = options.json && !isFinite(message.groundClearance) ? String(message.groundClearance) : message.groundClearance;
                if (message.wheelData && message.wheelData.length) {
                    object.wheelData = [];
                    for (let j = 0; j < message.wheelData.length; ++j)
                        object.wheelData[j] = $root.osi3.MovingObject.VehicleAttributes.WheelData.toObject(message.wheelData[j], options);
                }
                if (message.steeringWheelAngle != null && message.hasOwnProperty("steeringWheelAngle"))
                    object.steeringWheelAngle = options.json && !isFinite(message.steeringWheelAngle) ? String(message.steeringWheelAngle) : message.steeringWheelAngle;
                return object;
            };

            /**
             * Converts this VehicleAttributes to JSON.
             * @function toJSON
             * @memberof osi3.MovingObject.VehicleAttributes
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            VehicleAttributes.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for VehicleAttributes
             * @function getTypeUrl
             * @memberof osi3.MovingObject.VehicleAttributes
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            VehicleAttributes.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/osi3.MovingObject.VehicleAttributes";
            };

            VehicleAttributes.WheelData = (function() {

                /**
                 * Properties of a WheelData.
                 * @memberof osi3.MovingObject.VehicleAttributes
                 * @interface IWheelData
                 * @property {number|null} [axle] WheelData axle
                 * @property {number|null} [index] WheelData index
                 * @property {osi3.IVector3d|null} [position] WheelData position
                 * @property {number|null} [wheelRadius] WheelData wheelRadius
                 * @property {number|null} [rimRadius] WheelData rimRadius
                 * @property {number|null} [width] WheelData width
                 * @property {osi3.IOrientation3d|null} [orientation] WheelData orientation
                 * @property {number|null} [rotationRate] WheelData rotationRate
                 * @property {string|null} [modelReference] WheelData modelReference
                 * @property {number|null} [frictionCoefficient] WheelData frictionCoefficient
                 */

                /**
                 * Constructs a new WheelData.
                 * @memberof osi3.MovingObject.VehicleAttributes
                 * @classdesc Represents a WheelData.
                 * @implements IWheelData
                 * @constructor
                 * @param {osi3.MovingObject.VehicleAttributes.IWheelData=} [properties] Properties to set
                 */
                function WheelData(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * WheelData axle.
                 * @member {number} axle
                 * @memberof osi3.MovingObject.VehicleAttributes.WheelData
                 * @instance
                 */
                WheelData.prototype.axle = 0;

                /**
                 * WheelData index.
                 * @member {number} index
                 * @memberof osi3.MovingObject.VehicleAttributes.WheelData
                 * @instance
                 */
                WheelData.prototype.index = 0;

                /**
                 * WheelData position.
                 * @member {osi3.IVector3d|null|undefined} position
                 * @memberof osi3.MovingObject.VehicleAttributes.WheelData
                 * @instance
                 */
                WheelData.prototype.position = null;

                /**
                 * WheelData wheelRadius.
                 * @member {number} wheelRadius
                 * @memberof osi3.MovingObject.VehicleAttributes.WheelData
                 * @instance
                 */
                WheelData.prototype.wheelRadius = 0;

                /**
                 * WheelData rimRadius.
                 * @member {number} rimRadius
                 * @memberof osi3.MovingObject.VehicleAttributes.WheelData
                 * @instance
                 */
                WheelData.prototype.rimRadius = 0;

                /**
                 * WheelData width.
                 * @member {number} width
                 * @memberof osi3.MovingObject.VehicleAttributes.WheelData
                 * @instance
                 */
                WheelData.prototype.width = 0;

                /**
                 * WheelData orientation.
                 * @member {osi3.IOrientation3d|null|undefined} orientation
                 * @memberof osi3.MovingObject.VehicleAttributes.WheelData
                 * @instance
                 */
                WheelData.prototype.orientation = null;

                /**
                 * WheelData rotationRate.
                 * @member {number} rotationRate
                 * @memberof osi3.MovingObject.VehicleAttributes.WheelData
                 * @instance
                 */
                WheelData.prototype.rotationRate = 0;

                /**
                 * WheelData modelReference.
                 * @member {string} modelReference
                 * @memberof osi3.MovingObject.VehicleAttributes.WheelData
                 * @instance
                 */
                WheelData.prototype.modelReference = "";

                /**
                 * WheelData frictionCoefficient.
                 * @member {number} frictionCoefficient
                 * @memberof osi3.MovingObject.VehicleAttributes.WheelData
                 * @instance
                 */
                WheelData.prototype.frictionCoefficient = 0;

                /**
                 * Creates a new WheelData instance using the specified properties.
                 * @function create
                 * @memberof osi3.MovingObject.VehicleAttributes.WheelData
                 * @static
                 * @param {osi3.MovingObject.VehicleAttributes.IWheelData=} [properties] Properties to set
                 * @returns {osi3.MovingObject.VehicleAttributes.WheelData} WheelData instance
                 */
                WheelData.create = function create(properties) {
                    return new WheelData(properties);
                };

                /**
                 * Encodes the specified WheelData message. Does not implicitly {@link osi3.MovingObject.VehicleAttributes.WheelData.verify|verify} messages.
                 * @function encode
                 * @memberof osi3.MovingObject.VehicleAttributes.WheelData
                 * @static
                 * @param {osi3.MovingObject.VehicleAttributes.IWheelData} message WheelData message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                WheelData.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.axle != null && Object.hasOwnProperty.call(message, "axle"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.axle);
                    if (message.index != null && Object.hasOwnProperty.call(message, "index"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.index);
                    if (message.position != null && Object.hasOwnProperty.call(message, "position"))
                        $root.osi3.Vector3d.encode(message.position, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.wheelRadius != null && Object.hasOwnProperty.call(message, "wheelRadius"))
                        writer.uint32(/* id 4, wireType 1 =*/33).double(message.wheelRadius);
                    if (message.rimRadius != null && Object.hasOwnProperty.call(message, "rimRadius"))
                        writer.uint32(/* id 5, wireType 1 =*/41).double(message.rimRadius);
                    if (message.width != null && Object.hasOwnProperty.call(message, "width"))
                        writer.uint32(/* id 6, wireType 1 =*/49).double(message.width);
                    if (message.orientation != null && Object.hasOwnProperty.call(message, "orientation"))
                        $root.osi3.Orientation3d.encode(message.orientation, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                    if (message.rotationRate != null && Object.hasOwnProperty.call(message, "rotationRate"))
                        writer.uint32(/* id 8, wireType 1 =*/65).double(message.rotationRate);
                    if (message.modelReference != null && Object.hasOwnProperty.call(message, "modelReference"))
                        writer.uint32(/* id 9, wireType 2 =*/74).string(message.modelReference);
                    if (message.frictionCoefficient != null && Object.hasOwnProperty.call(message, "frictionCoefficient"))
                        writer.uint32(/* id 10, wireType 1 =*/81).double(message.frictionCoefficient);
                    return writer;
                };

                /**
                 * Encodes the specified WheelData message, length delimited. Does not implicitly {@link osi3.MovingObject.VehicleAttributes.WheelData.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof osi3.MovingObject.VehicleAttributes.WheelData
                 * @static
                 * @param {osi3.MovingObject.VehicleAttributes.IWheelData} message WheelData message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                WheelData.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a WheelData message from the specified reader or buffer.
                 * @function decode
                 * @memberof osi3.MovingObject.VehicleAttributes.WheelData
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {osi3.MovingObject.VehicleAttributes.WheelData} WheelData
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                WheelData.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.osi3.MovingObject.VehicleAttributes.WheelData();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                message.axle = reader.uint32();
                                break;
                            }
                        case 2: {
                                message.index = reader.uint32();
                                break;
                            }
                        case 3: {
                                message.position = $root.osi3.Vector3d.decode(reader, reader.uint32());
                                break;
                            }
                        case 4: {
                                message.wheelRadius = reader.double();
                                break;
                            }
                        case 5: {
                                message.rimRadius = reader.double();
                                break;
                            }
                        case 6: {
                                message.width = reader.double();
                                break;
                            }
                        case 7: {
                                message.orientation = $root.osi3.Orientation3d.decode(reader, reader.uint32());
                                break;
                            }
                        case 8: {
                                message.rotationRate = reader.double();
                                break;
                            }
                        case 9: {
                                message.modelReference = reader.string();
                                break;
                            }
                        case 10: {
                                message.frictionCoefficient = reader.double();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a WheelData message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof osi3.MovingObject.VehicleAttributes.WheelData
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {osi3.MovingObject.VehicleAttributes.WheelData} WheelData
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                WheelData.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a WheelData message.
                 * @function verify
                 * @memberof osi3.MovingObject.VehicleAttributes.WheelData
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                WheelData.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.axle != null && message.hasOwnProperty("axle"))
                        if (!$util.isInteger(message.axle))
                            return "axle: integer expected";
                    if (message.index != null && message.hasOwnProperty("index"))
                        if (!$util.isInteger(message.index))
                            return "index: integer expected";
                    if (message.position != null && message.hasOwnProperty("position")) {
                        let error = $root.osi3.Vector3d.verify(message.position);
                        if (error)
                            return "position." + error;
                    }
                    if (message.wheelRadius != null && message.hasOwnProperty("wheelRadius"))
                        if (typeof message.wheelRadius !== "number")
                            return "wheelRadius: number expected";
                    if (message.rimRadius != null && message.hasOwnProperty("rimRadius"))
                        if (typeof message.rimRadius !== "number")
                            return "rimRadius: number expected";
                    if (message.width != null && message.hasOwnProperty("width"))
                        if (typeof message.width !== "number")
                            return "width: number expected";
                    if (message.orientation != null && message.hasOwnProperty("orientation")) {
                        let error = $root.osi3.Orientation3d.verify(message.orientation);
                        if (error)
                            return "orientation." + error;
                    }
                    if (message.rotationRate != null && message.hasOwnProperty("rotationRate"))
                        if (typeof message.rotationRate !== "number")
                            return "rotationRate: number expected";
                    if (message.modelReference != null && message.hasOwnProperty("modelReference"))
                        if (!$util.isString(message.modelReference))
                            return "modelReference: string expected";
                    if (message.frictionCoefficient != null && message.hasOwnProperty("frictionCoefficient"))
                        if (typeof message.frictionCoefficient !== "number")
                            return "frictionCoefficient: number expected";
                    return null;
                };

                /**
                 * Creates a WheelData message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof osi3.MovingObject.VehicleAttributes.WheelData
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {osi3.MovingObject.VehicleAttributes.WheelData} WheelData
                 */
                WheelData.fromObject = function fromObject(object) {
                    if (object instanceof $root.osi3.MovingObject.VehicleAttributes.WheelData)
                        return object;
                    let message = new $root.osi3.MovingObject.VehicleAttributes.WheelData();
                    if (object.axle != null)
                        message.axle = object.axle >>> 0;
                    if (object.index != null)
                        message.index = object.index >>> 0;
                    if (object.position != null) {
                        if (typeof object.position !== "object")
                            throw TypeError(".osi3.MovingObject.VehicleAttributes.WheelData.position: object expected");
                        message.position = $root.osi3.Vector3d.fromObject(object.position);
                    }
                    if (object.wheelRadius != null)
                        message.wheelRadius = Number(object.wheelRadius);
                    if (object.rimRadius != null)
                        message.rimRadius = Number(object.rimRadius);
                    if (object.width != null)
                        message.width = Number(object.width);
                    if (object.orientation != null) {
                        if (typeof object.orientation !== "object")
                            throw TypeError(".osi3.MovingObject.VehicleAttributes.WheelData.orientation: object expected");
                        message.orientation = $root.osi3.Orientation3d.fromObject(object.orientation);
                    }
                    if (object.rotationRate != null)
                        message.rotationRate = Number(object.rotationRate);
                    if (object.modelReference != null)
                        message.modelReference = String(object.modelReference);
                    if (object.frictionCoefficient != null)
                        message.frictionCoefficient = Number(object.frictionCoefficient);
                    return message;
                };

                /**
                 * Creates a plain object from a WheelData message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof osi3.MovingObject.VehicleAttributes.WheelData
                 * @static
                 * @param {osi3.MovingObject.VehicleAttributes.WheelData} message WheelData
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                WheelData.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.axle = 0;
                        object.index = 0;
                        object.position = null;
                        object.wheelRadius = 0;
                        object.rimRadius = 0;
                        object.width = 0;
                        object.orientation = null;
                        object.rotationRate = 0;
                        object.modelReference = "";
                        object.frictionCoefficient = 0;
                    }
                    if (message.axle != null && message.hasOwnProperty("axle"))
                        object.axle = message.axle;
                    if (message.index != null && message.hasOwnProperty("index"))
                        object.index = message.index;
                    if (message.position != null && message.hasOwnProperty("position"))
                        object.position = $root.osi3.Vector3d.toObject(message.position, options);
                    if (message.wheelRadius != null && message.hasOwnProperty("wheelRadius"))
                        object.wheelRadius = options.json && !isFinite(message.wheelRadius) ? String(message.wheelRadius) : message.wheelRadius;
                    if (message.rimRadius != null && message.hasOwnProperty("rimRadius"))
                        object.rimRadius = options.json && !isFinite(message.rimRadius) ? String(message.rimRadius) : message.rimRadius;
                    if (message.width != null && message.hasOwnProperty("width"))
                        object.width = options.json && !isFinite(message.width) ? String(message.width) : message.width;
                    if (message.orientation != null && message.hasOwnProperty("orientation"))
                        object.orientation = $root.osi3.Orientation3d.toObject(message.orientation, options);
                    if (message.rotationRate != null && message.hasOwnProperty("rotationRate"))
                        object.rotationRate = options.json && !isFinite(message.rotationRate) ? String(message.rotationRate) : message.rotationRate;
                    if (message.modelReference != null && message.hasOwnProperty("modelReference"))
                        object.modelReference = message.modelReference;
                    if (message.frictionCoefficient != null && message.hasOwnProperty("frictionCoefficient"))
                        object.frictionCoefficient = options.json && !isFinite(message.frictionCoefficient) ? String(message.frictionCoefficient) : message.frictionCoefficient;
                    return object;
                };

                /**
                 * Converts this WheelData to JSON.
                 * @function toJSON
                 * @memberof osi3.MovingObject.VehicleAttributes.WheelData
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                WheelData.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for WheelData
                 * @function getTypeUrl
                 * @memberof osi3.MovingObject.VehicleAttributes.WheelData
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                WheelData.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/osi3.MovingObject.VehicleAttributes.WheelData";
                };

                return WheelData;
            })();

            return VehicleAttributes;
        })();

        MovingObject.MovingObjectClassification = (function() {

            /**
             * Properties of a MovingObjectClassification.
             * @memberof osi3.MovingObject
             * @interface IMovingObjectClassification
             * @property {Array.<osi3.IIdentifier>|null} [assignedLaneId] MovingObjectClassification assignedLaneId
             * @property {Array.<number>|null} [assignedLanePercentage] MovingObjectClassification assignedLanePercentage
             * @property {Array.<osi3.ILogicalLaneAssignment>|null} [logicalLaneAssignment] MovingObjectClassification logicalLaneAssignment
             */

            /**
             * Constructs a new MovingObjectClassification.
             * @memberof osi3.MovingObject
             * @classdesc Represents a MovingObjectClassification.
             * @implements IMovingObjectClassification
             * @constructor
             * @param {osi3.MovingObject.IMovingObjectClassification=} [properties] Properties to set
             */
            function MovingObjectClassification(properties) {
                this.assignedLaneId = [];
                this.assignedLanePercentage = [];
                this.logicalLaneAssignment = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MovingObjectClassification assignedLaneId.
             * @member {Array.<osi3.IIdentifier>} assignedLaneId
             * @memberof osi3.MovingObject.MovingObjectClassification
             * @instance
             */
            MovingObjectClassification.prototype.assignedLaneId = $util.emptyArray;

            /**
             * MovingObjectClassification assignedLanePercentage.
             * @member {Array.<number>} assignedLanePercentage
             * @memberof osi3.MovingObject.MovingObjectClassification
             * @instance
             */
            MovingObjectClassification.prototype.assignedLanePercentage = $util.emptyArray;

            /**
             * MovingObjectClassification logicalLaneAssignment.
             * @member {Array.<osi3.ILogicalLaneAssignment>} logicalLaneAssignment
             * @memberof osi3.MovingObject.MovingObjectClassification
             * @instance
             */
            MovingObjectClassification.prototype.logicalLaneAssignment = $util.emptyArray;

            /**
             * Creates a new MovingObjectClassification instance using the specified properties.
             * @function create
             * @memberof osi3.MovingObject.MovingObjectClassification
             * @static
             * @param {osi3.MovingObject.IMovingObjectClassification=} [properties] Properties to set
             * @returns {osi3.MovingObject.MovingObjectClassification} MovingObjectClassification instance
             */
            MovingObjectClassification.create = function create(properties) {
                return new MovingObjectClassification(properties);
            };

            /**
             * Encodes the specified MovingObjectClassification message. Does not implicitly {@link osi3.MovingObject.MovingObjectClassification.verify|verify} messages.
             * @function encode
             * @memberof osi3.MovingObject.MovingObjectClassification
             * @static
             * @param {osi3.MovingObject.IMovingObjectClassification} message MovingObjectClassification message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MovingObjectClassification.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.assignedLaneId != null && message.assignedLaneId.length)
                    for (let i = 0; i < message.assignedLaneId.length; ++i)
                        $root.osi3.Identifier.encode(message.assignedLaneId[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.assignedLanePercentage != null && message.assignedLanePercentage.length)
                    for (let i = 0; i < message.assignedLanePercentage.length; ++i)
                        writer.uint32(/* id 2, wireType 1 =*/17).double(message.assignedLanePercentage[i]);
                if (message.logicalLaneAssignment != null && message.logicalLaneAssignment.length)
                    for (let i = 0; i < message.logicalLaneAssignment.length; ++i)
                        $root.osi3.LogicalLaneAssignment.encode(message.logicalLaneAssignment[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified MovingObjectClassification message, length delimited. Does not implicitly {@link osi3.MovingObject.MovingObjectClassification.verify|verify} messages.
             * @function encodeDelimited
             * @memberof osi3.MovingObject.MovingObjectClassification
             * @static
             * @param {osi3.MovingObject.IMovingObjectClassification} message MovingObjectClassification message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MovingObjectClassification.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MovingObjectClassification message from the specified reader or buffer.
             * @function decode
             * @memberof osi3.MovingObject.MovingObjectClassification
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {osi3.MovingObject.MovingObjectClassification} MovingObjectClassification
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MovingObjectClassification.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.osi3.MovingObject.MovingObjectClassification();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.assignedLaneId && message.assignedLaneId.length))
                                message.assignedLaneId = [];
                            message.assignedLaneId.push($root.osi3.Identifier.decode(reader, reader.uint32()));
                            break;
                        }
                    case 2: {
                            if (!(message.assignedLanePercentage && message.assignedLanePercentage.length))
                                message.assignedLanePercentage = [];
                            if ((tag & 7) === 2) {
                                let end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.assignedLanePercentage.push(reader.double());
                            } else
                                message.assignedLanePercentage.push(reader.double());
                            break;
                        }
                    case 3: {
                            if (!(message.logicalLaneAssignment && message.logicalLaneAssignment.length))
                                message.logicalLaneAssignment = [];
                            message.logicalLaneAssignment.push($root.osi3.LogicalLaneAssignment.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MovingObjectClassification message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof osi3.MovingObject.MovingObjectClassification
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {osi3.MovingObject.MovingObjectClassification} MovingObjectClassification
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MovingObjectClassification.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MovingObjectClassification message.
             * @function verify
             * @memberof osi3.MovingObject.MovingObjectClassification
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MovingObjectClassification.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.assignedLaneId != null && message.hasOwnProperty("assignedLaneId")) {
                    if (!Array.isArray(message.assignedLaneId))
                        return "assignedLaneId: array expected";
                    for (let i = 0; i < message.assignedLaneId.length; ++i) {
                        let error = $root.osi3.Identifier.verify(message.assignedLaneId[i]);
                        if (error)
                            return "assignedLaneId." + error;
                    }
                }
                if (message.assignedLanePercentage != null && message.hasOwnProperty("assignedLanePercentage")) {
                    if (!Array.isArray(message.assignedLanePercentage))
                        return "assignedLanePercentage: array expected";
                    for (let i = 0; i < message.assignedLanePercentage.length; ++i)
                        if (typeof message.assignedLanePercentage[i] !== "number")
                            return "assignedLanePercentage: number[] expected";
                }
                if (message.logicalLaneAssignment != null && message.hasOwnProperty("logicalLaneAssignment")) {
                    if (!Array.isArray(message.logicalLaneAssignment))
                        return "logicalLaneAssignment: array expected";
                    for (let i = 0; i < message.logicalLaneAssignment.length; ++i) {
                        let error = $root.osi3.LogicalLaneAssignment.verify(message.logicalLaneAssignment[i]);
                        if (error)
                            return "logicalLaneAssignment." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a MovingObjectClassification message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof osi3.MovingObject.MovingObjectClassification
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {osi3.MovingObject.MovingObjectClassification} MovingObjectClassification
             */
            MovingObjectClassification.fromObject = function fromObject(object) {
                if (object instanceof $root.osi3.MovingObject.MovingObjectClassification)
                    return object;
                let message = new $root.osi3.MovingObject.MovingObjectClassification();
                if (object.assignedLaneId) {
                    if (!Array.isArray(object.assignedLaneId))
                        throw TypeError(".osi3.MovingObject.MovingObjectClassification.assignedLaneId: array expected");
                    message.assignedLaneId = [];
                    for (let i = 0; i < object.assignedLaneId.length; ++i) {
                        if (typeof object.assignedLaneId[i] !== "object")
                            throw TypeError(".osi3.MovingObject.MovingObjectClassification.assignedLaneId: object expected");
                        message.assignedLaneId[i] = $root.osi3.Identifier.fromObject(object.assignedLaneId[i]);
                    }
                }
                if (object.assignedLanePercentage) {
                    if (!Array.isArray(object.assignedLanePercentage))
                        throw TypeError(".osi3.MovingObject.MovingObjectClassification.assignedLanePercentage: array expected");
                    message.assignedLanePercentage = [];
                    for (let i = 0; i < object.assignedLanePercentage.length; ++i)
                        message.assignedLanePercentage[i] = Number(object.assignedLanePercentage[i]);
                }
                if (object.logicalLaneAssignment) {
                    if (!Array.isArray(object.logicalLaneAssignment))
                        throw TypeError(".osi3.MovingObject.MovingObjectClassification.logicalLaneAssignment: array expected");
                    message.logicalLaneAssignment = [];
                    for (let i = 0; i < object.logicalLaneAssignment.length; ++i) {
                        if (typeof object.logicalLaneAssignment[i] !== "object")
                            throw TypeError(".osi3.MovingObject.MovingObjectClassification.logicalLaneAssignment: object expected");
                        message.logicalLaneAssignment[i] = $root.osi3.LogicalLaneAssignment.fromObject(object.logicalLaneAssignment[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a MovingObjectClassification message. Also converts values to other types if specified.
             * @function toObject
             * @memberof osi3.MovingObject.MovingObjectClassification
             * @static
             * @param {osi3.MovingObject.MovingObjectClassification} message MovingObjectClassification
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MovingObjectClassification.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults) {
                    object.assignedLaneId = [];
                    object.assignedLanePercentage = [];
                    object.logicalLaneAssignment = [];
                }
                if (message.assignedLaneId && message.assignedLaneId.length) {
                    object.assignedLaneId = [];
                    for (let j = 0; j < message.assignedLaneId.length; ++j)
                        object.assignedLaneId[j] = $root.osi3.Identifier.toObject(message.assignedLaneId[j], options);
                }
                if (message.assignedLanePercentage && message.assignedLanePercentage.length) {
                    object.assignedLanePercentage = [];
                    for (let j = 0; j < message.assignedLanePercentage.length; ++j)
                        object.assignedLanePercentage[j] = options.json && !isFinite(message.assignedLanePercentage[j]) ? String(message.assignedLanePercentage[j]) : message.assignedLanePercentage[j];
                }
                if (message.logicalLaneAssignment && message.logicalLaneAssignment.length) {
                    object.logicalLaneAssignment = [];
                    for (let j = 0; j < message.logicalLaneAssignment.length; ++j)
                        object.logicalLaneAssignment[j] = $root.osi3.LogicalLaneAssignment.toObject(message.logicalLaneAssignment[j], options);
                }
                return object;
            };

            /**
             * Converts this MovingObjectClassification to JSON.
             * @function toJSON
             * @memberof osi3.MovingObject.MovingObjectClassification
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MovingObjectClassification.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for MovingObjectClassification
             * @function getTypeUrl
             * @memberof osi3.MovingObject.MovingObjectClassification
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            MovingObjectClassification.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/osi3.MovingObject.MovingObjectClassification";
            };

            return MovingObjectClassification;
        })();

        MovingObject.VehicleClassification = (function() {

            /**
             * Properties of a VehicleClassification.
             * @memberof osi3.MovingObject
             * @interface IVehicleClassification
             * @property {osi3.MovingObject.VehicleClassification.Type|null} [type] VehicleClassification type
             * @property {osi3.MovingObject.VehicleClassification.ILightState|null} [lightState] VehicleClassification lightState
             * @property {boolean|null} [hasTrailer] VehicleClassification hasTrailer
             * @property {osi3.IIdentifier|null} [trailerId] VehicleClassification trailerId
             * @property {osi3.MovingObject.VehicleClassification.Role|null} [role] VehicleClassification role
             */

            /**
             * Constructs a new VehicleClassification.
             * @memberof osi3.MovingObject
             * @classdesc Represents a VehicleClassification.
             * @implements IVehicleClassification
             * @constructor
             * @param {osi3.MovingObject.IVehicleClassification=} [properties] Properties to set
             */
            function VehicleClassification(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * VehicleClassification type.
             * @member {osi3.MovingObject.VehicleClassification.Type} type
             * @memberof osi3.MovingObject.VehicleClassification
             * @instance
             */
            VehicleClassification.prototype.type = 0;

            /**
             * VehicleClassification lightState.
             * @member {osi3.MovingObject.VehicleClassification.ILightState|null|undefined} lightState
             * @memberof osi3.MovingObject.VehicleClassification
             * @instance
             */
            VehicleClassification.prototype.lightState = null;

            /**
             * VehicleClassification hasTrailer.
             * @member {boolean} hasTrailer
             * @memberof osi3.MovingObject.VehicleClassification
             * @instance
             */
            VehicleClassification.prototype.hasTrailer = false;

            /**
             * VehicleClassification trailerId.
             * @member {osi3.IIdentifier|null|undefined} trailerId
             * @memberof osi3.MovingObject.VehicleClassification
             * @instance
             */
            VehicleClassification.prototype.trailerId = null;

            /**
             * VehicleClassification role.
             * @member {osi3.MovingObject.VehicleClassification.Role} role
             * @memberof osi3.MovingObject.VehicleClassification
             * @instance
             */
            VehicleClassification.prototype.role = 0;

            /**
             * Creates a new VehicleClassification instance using the specified properties.
             * @function create
             * @memberof osi3.MovingObject.VehicleClassification
             * @static
             * @param {osi3.MovingObject.IVehicleClassification=} [properties] Properties to set
             * @returns {osi3.MovingObject.VehicleClassification} VehicleClassification instance
             */
            VehicleClassification.create = function create(properties) {
                return new VehicleClassification(properties);
            };

            /**
             * Encodes the specified VehicleClassification message. Does not implicitly {@link osi3.MovingObject.VehicleClassification.verify|verify} messages.
             * @function encode
             * @memberof osi3.MovingObject.VehicleClassification
             * @static
             * @param {osi3.MovingObject.IVehicleClassification} message VehicleClassification message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            VehicleClassification.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                if (message.lightState != null && Object.hasOwnProperty.call(message, "lightState"))
                    $root.osi3.MovingObject.VehicleClassification.LightState.encode(message.lightState, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.hasTrailer != null && Object.hasOwnProperty.call(message, "hasTrailer"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.hasTrailer);
                if (message.trailerId != null && Object.hasOwnProperty.call(message, "trailerId"))
                    $root.osi3.Identifier.encode(message.trailerId, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.role != null && Object.hasOwnProperty.call(message, "role"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.role);
                return writer;
            };

            /**
             * Encodes the specified VehicleClassification message, length delimited. Does not implicitly {@link osi3.MovingObject.VehicleClassification.verify|verify} messages.
             * @function encodeDelimited
             * @memberof osi3.MovingObject.VehicleClassification
             * @static
             * @param {osi3.MovingObject.IVehicleClassification} message VehicleClassification message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            VehicleClassification.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a VehicleClassification message from the specified reader or buffer.
             * @function decode
             * @memberof osi3.MovingObject.VehicleClassification
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {osi3.MovingObject.VehicleClassification} VehicleClassification
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            VehicleClassification.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.osi3.MovingObject.VehicleClassification();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.type = reader.int32();
                            break;
                        }
                    case 2: {
                            message.lightState = $root.osi3.MovingObject.VehicleClassification.LightState.decode(reader, reader.uint32());
                            break;
                        }
                    case 3: {
                            message.hasTrailer = reader.bool();
                            break;
                        }
                    case 4: {
                            message.trailerId = $root.osi3.Identifier.decode(reader, reader.uint32());
                            break;
                        }
                    case 5: {
                            message.role = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a VehicleClassification message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof osi3.MovingObject.VehicleClassification
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {osi3.MovingObject.VehicleClassification} VehicleClassification
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            VehicleClassification.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a VehicleClassification message.
             * @function verify
             * @memberof osi3.MovingObject.VehicleClassification
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            VehicleClassification.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 16:
                    case 8:
                    case 9:
                    case 10:
                    case 11:
                    case 12:
                    case 13:
                    case 14:
                    case 15:
                    case 17:
                        break;
                    }
                if (message.lightState != null && message.hasOwnProperty("lightState")) {
                    let error = $root.osi3.MovingObject.VehicleClassification.LightState.verify(message.lightState);
                    if (error)
                        return "lightState." + error;
                }
                if (message.hasTrailer != null && message.hasOwnProperty("hasTrailer"))
                    if (typeof message.hasTrailer !== "boolean")
                        return "hasTrailer: boolean expected";
                if (message.trailerId != null && message.hasOwnProperty("trailerId")) {
                    let error = $root.osi3.Identifier.verify(message.trailerId);
                    if (error)
                        return "trailerId." + error;
                }
                if (message.role != null && message.hasOwnProperty("role"))
                    switch (message.role) {
                    default:
                        return "role: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                    case 9:
                    case 10:
                        break;
                    }
                return null;
            };

            /**
             * Creates a VehicleClassification message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof osi3.MovingObject.VehicleClassification
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {osi3.MovingObject.VehicleClassification} VehicleClassification
             */
            VehicleClassification.fromObject = function fromObject(object) {
                if (object instanceof $root.osi3.MovingObject.VehicleClassification)
                    return object;
                let message = new $root.osi3.MovingObject.VehicleClassification();
                switch (object.type) {
                default:
                    if (typeof object.type === "number") {
                        message.type = object.type;
                        break;
                    }
                    break;
                case "TYPE_UNKNOWN":
                case 0:
                    message.type = 0;
                    break;
                case "TYPE_OTHER":
                case 1:
                    message.type = 1;
                    break;
                case "TYPE_SMALL_CAR":
                case 2:
                    message.type = 2;
                    break;
                case "TYPE_COMPACT_CAR":
                case 3:
                    message.type = 3;
                    break;
                case "TYPE_CAR":
                case 4:
                    message.type = 4;
                    break;
                case "TYPE_MEDIUM_CAR":
                case 4:
                    message.type = 4;
                    break;
                case "TYPE_LUXURY_CAR":
                case 5:
                    message.type = 5;
                    break;
                case "TYPE_DELIVERY_VAN":
                case 6:
                    message.type = 6;
                    break;
                case "TYPE_HEAVY_TRUCK":
                case 7:
                    message.type = 7;
                    break;
                case "TYPE_SEMITRACTOR":
                case 16:
                    message.type = 16;
                    break;
                case "TYPE_SEMITRAILER":
                case 8:
                    message.type = 8;
                    break;
                case "TYPE_TRAILER":
                case 9:
                    message.type = 9;
                    break;
                case "TYPE_MOTORBIKE":
                case 10:
                    message.type = 10;
                    break;
                case "TYPE_BICYCLE":
                case 11:
                    message.type = 11;
                    break;
                case "TYPE_BUS":
                case 12:
                    message.type = 12;
                    break;
                case "TYPE_TRAM":
                case 13:
                    message.type = 13;
                    break;
                case "TYPE_TRAIN":
                case 14:
                    message.type = 14;
                    break;
                case "TYPE_WHEELCHAIR":
                case 15:
                    message.type = 15;
                    break;
                case "TYPE_STANDUP_SCOOTER":
                case 17:
                    message.type = 17;
                    break;
                }
                if (object.lightState != null) {
                    if (typeof object.lightState !== "object")
                        throw TypeError(".osi3.MovingObject.VehicleClassification.lightState: object expected");
                    message.lightState = $root.osi3.MovingObject.VehicleClassification.LightState.fromObject(object.lightState);
                }
                if (object.hasTrailer != null)
                    message.hasTrailer = Boolean(object.hasTrailer);
                if (object.trailerId != null) {
                    if (typeof object.trailerId !== "object")
                        throw TypeError(".osi3.MovingObject.VehicleClassification.trailerId: object expected");
                    message.trailerId = $root.osi3.Identifier.fromObject(object.trailerId);
                }
                switch (object.role) {
                default:
                    if (typeof object.role === "number") {
                        message.role = object.role;
                        break;
                    }
                    break;
                case "ROLE_UNKNOWN":
                case 0:
                    message.role = 0;
                    break;
                case "ROLE_OTHER":
                case 1:
                    message.role = 1;
                    break;
                case "ROLE_CIVIL":
                case 2:
                    message.role = 2;
                    break;
                case "ROLE_AMBULANCE":
                case 3:
                    message.role = 3;
                    break;
                case "ROLE_FIRE":
                case 4:
                    message.role = 4;
                    break;
                case "ROLE_POLICE":
                case 5:
                    message.role = 5;
                    break;
                case "ROLE_PUBLIC_TRANSPORT":
                case 6:
                    message.role = 6;
                    break;
                case "ROLE_ROAD_ASSISTANCE":
                case 7:
                    message.role = 7;
                    break;
                case "ROLE_GARBAGE_COLLECTION":
                case 8:
                    message.role = 8;
                    break;
                case "ROLE_ROAD_CONSTRUCTION":
                case 9:
                    message.role = 9;
                    break;
                case "ROLE_MILITARY":
                case 10:
                    message.role = 10;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from a VehicleClassification message. Also converts values to other types if specified.
             * @function toObject
             * @memberof osi3.MovingObject.VehicleClassification
             * @static
             * @param {osi3.MovingObject.VehicleClassification} message VehicleClassification
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            VehicleClassification.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.type = options.enums === String ? "TYPE_UNKNOWN" : 0;
                    object.lightState = null;
                    object.hasTrailer = false;
                    object.trailerId = null;
                    object.role = options.enums === String ? "ROLE_UNKNOWN" : 0;
                }
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.osi3.MovingObject.VehicleClassification.Type[message.type] === undefined ? message.type : $root.osi3.MovingObject.VehicleClassification.Type[message.type] : message.type;
                if (message.lightState != null && message.hasOwnProperty("lightState"))
                    object.lightState = $root.osi3.MovingObject.VehicleClassification.LightState.toObject(message.lightState, options);
                if (message.hasTrailer != null && message.hasOwnProperty("hasTrailer"))
                    object.hasTrailer = message.hasTrailer;
                if (message.trailerId != null && message.hasOwnProperty("trailerId"))
                    object.trailerId = $root.osi3.Identifier.toObject(message.trailerId, options);
                if (message.role != null && message.hasOwnProperty("role"))
                    object.role = options.enums === String ? $root.osi3.MovingObject.VehicleClassification.Role[message.role] === undefined ? message.role : $root.osi3.MovingObject.VehicleClassification.Role[message.role] : message.role;
                return object;
            };

            /**
             * Converts this VehicleClassification to JSON.
             * @function toJSON
             * @memberof osi3.MovingObject.VehicleClassification
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            VehicleClassification.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for VehicleClassification
             * @function getTypeUrl
             * @memberof osi3.MovingObject.VehicleClassification
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            VehicleClassification.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/osi3.MovingObject.VehicleClassification";
            };

            /**
             * Type enum.
             * @name osi3.MovingObject.VehicleClassification.Type
             * @enum {number}
             * @property {number} TYPE_UNKNOWN=0 TYPE_UNKNOWN value
             * @property {number} TYPE_OTHER=1 TYPE_OTHER value
             * @property {number} TYPE_SMALL_CAR=2 TYPE_SMALL_CAR value
             * @property {number} TYPE_COMPACT_CAR=3 TYPE_COMPACT_CAR value
             * @property {number} TYPE_CAR=4 TYPE_CAR value
             * @property {number} TYPE_MEDIUM_CAR=4 TYPE_MEDIUM_CAR value
             * @property {number} TYPE_LUXURY_CAR=5 TYPE_LUXURY_CAR value
             * @property {number} TYPE_DELIVERY_VAN=6 TYPE_DELIVERY_VAN value
             * @property {number} TYPE_HEAVY_TRUCK=7 TYPE_HEAVY_TRUCK value
             * @property {number} TYPE_SEMITRACTOR=16 TYPE_SEMITRACTOR value
             * @property {number} TYPE_SEMITRAILER=8 TYPE_SEMITRAILER value
             * @property {number} TYPE_TRAILER=9 TYPE_TRAILER value
             * @property {number} TYPE_MOTORBIKE=10 TYPE_MOTORBIKE value
             * @property {number} TYPE_BICYCLE=11 TYPE_BICYCLE value
             * @property {number} TYPE_BUS=12 TYPE_BUS value
             * @property {number} TYPE_TRAM=13 TYPE_TRAM value
             * @property {number} TYPE_TRAIN=14 TYPE_TRAIN value
             * @property {number} TYPE_WHEELCHAIR=15 TYPE_WHEELCHAIR value
             * @property {number} TYPE_STANDUP_SCOOTER=17 TYPE_STANDUP_SCOOTER value
             */
            VehicleClassification.Type = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "TYPE_UNKNOWN"] = 0;
                values[valuesById[1] = "TYPE_OTHER"] = 1;
                values[valuesById[2] = "TYPE_SMALL_CAR"] = 2;
                values[valuesById[3] = "TYPE_COMPACT_CAR"] = 3;
                values[valuesById[4] = "TYPE_CAR"] = 4;
                values["TYPE_MEDIUM_CAR"] = 4;
                values[valuesById[5] = "TYPE_LUXURY_CAR"] = 5;
                values[valuesById[6] = "TYPE_DELIVERY_VAN"] = 6;
                values[valuesById[7] = "TYPE_HEAVY_TRUCK"] = 7;
                values[valuesById[16] = "TYPE_SEMITRACTOR"] = 16;
                values[valuesById[8] = "TYPE_SEMITRAILER"] = 8;
                values[valuesById[9] = "TYPE_TRAILER"] = 9;
                values[valuesById[10] = "TYPE_MOTORBIKE"] = 10;
                values[valuesById[11] = "TYPE_BICYCLE"] = 11;
                values[valuesById[12] = "TYPE_BUS"] = 12;
                values[valuesById[13] = "TYPE_TRAM"] = 13;
                values[valuesById[14] = "TYPE_TRAIN"] = 14;
                values[valuesById[15] = "TYPE_WHEELCHAIR"] = 15;
                values[valuesById[17] = "TYPE_STANDUP_SCOOTER"] = 17;
                return values;
            })();

            VehicleClassification.LightState = (function() {

                /**
                 * Properties of a LightState.
                 * @memberof osi3.MovingObject.VehicleClassification
                 * @interface ILightState
                 * @property {osi3.MovingObject.VehicleClassification.LightState.IndicatorState|null} [indicatorState] LightState indicatorState
                 * @property {osi3.MovingObject.VehicleClassification.LightState.GenericLightState|null} [frontFogLight] LightState frontFogLight
                 * @property {osi3.MovingObject.VehicleClassification.LightState.GenericLightState|null} [rearFogLight] LightState rearFogLight
                 * @property {osi3.MovingObject.VehicleClassification.LightState.GenericLightState|null} [headLight] LightState headLight
                 * @property {osi3.MovingObject.VehicleClassification.LightState.GenericLightState|null} [highBeam] LightState highBeam
                 * @property {osi3.MovingObject.VehicleClassification.LightState.GenericLightState|null} [reversingLight] LightState reversingLight
                 * @property {osi3.MovingObject.VehicleClassification.LightState.BrakeLightState|null} [brakeLightState] LightState brakeLightState
                 * @property {osi3.MovingObject.VehicleClassification.LightState.GenericLightState|null} [licensePlateIlluminationRear] LightState licensePlateIlluminationRear
                 * @property {osi3.MovingObject.VehicleClassification.LightState.GenericLightState|null} [emergencyVehicleIllumination] LightState emergencyVehicleIllumination
                 * @property {osi3.MovingObject.VehicleClassification.LightState.GenericLightState|null} [serviceVehicleIllumination] LightState serviceVehicleIllumination
                 */

                /**
                 * Constructs a new LightState.
                 * @memberof osi3.MovingObject.VehicleClassification
                 * @classdesc Represents a LightState.
                 * @implements ILightState
                 * @constructor
                 * @param {osi3.MovingObject.VehicleClassification.ILightState=} [properties] Properties to set
                 */
                function LightState(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * LightState indicatorState.
                 * @member {osi3.MovingObject.VehicleClassification.LightState.IndicatorState} indicatorState
                 * @memberof osi3.MovingObject.VehicleClassification.LightState
                 * @instance
                 */
                LightState.prototype.indicatorState = 0;

                /**
                 * LightState frontFogLight.
                 * @member {osi3.MovingObject.VehicleClassification.LightState.GenericLightState} frontFogLight
                 * @memberof osi3.MovingObject.VehicleClassification.LightState
                 * @instance
                 */
                LightState.prototype.frontFogLight = 0;

                /**
                 * LightState rearFogLight.
                 * @member {osi3.MovingObject.VehicleClassification.LightState.GenericLightState} rearFogLight
                 * @memberof osi3.MovingObject.VehicleClassification.LightState
                 * @instance
                 */
                LightState.prototype.rearFogLight = 0;

                /**
                 * LightState headLight.
                 * @member {osi3.MovingObject.VehicleClassification.LightState.GenericLightState} headLight
                 * @memberof osi3.MovingObject.VehicleClassification.LightState
                 * @instance
                 */
                LightState.prototype.headLight = 0;

                /**
                 * LightState highBeam.
                 * @member {osi3.MovingObject.VehicleClassification.LightState.GenericLightState} highBeam
                 * @memberof osi3.MovingObject.VehicleClassification.LightState
                 * @instance
                 */
                LightState.prototype.highBeam = 0;

                /**
                 * LightState reversingLight.
                 * @member {osi3.MovingObject.VehicleClassification.LightState.GenericLightState} reversingLight
                 * @memberof osi3.MovingObject.VehicleClassification.LightState
                 * @instance
                 */
                LightState.prototype.reversingLight = 0;

                /**
                 * LightState brakeLightState.
                 * @member {osi3.MovingObject.VehicleClassification.LightState.BrakeLightState} brakeLightState
                 * @memberof osi3.MovingObject.VehicleClassification.LightState
                 * @instance
                 */
                LightState.prototype.brakeLightState = 0;

                /**
                 * LightState licensePlateIlluminationRear.
                 * @member {osi3.MovingObject.VehicleClassification.LightState.GenericLightState} licensePlateIlluminationRear
                 * @memberof osi3.MovingObject.VehicleClassification.LightState
                 * @instance
                 */
                LightState.prototype.licensePlateIlluminationRear = 0;

                /**
                 * LightState emergencyVehicleIllumination.
                 * @member {osi3.MovingObject.VehicleClassification.LightState.GenericLightState} emergencyVehicleIllumination
                 * @memberof osi3.MovingObject.VehicleClassification.LightState
                 * @instance
                 */
                LightState.prototype.emergencyVehicleIllumination = 0;

                /**
                 * LightState serviceVehicleIllumination.
                 * @member {osi3.MovingObject.VehicleClassification.LightState.GenericLightState} serviceVehicleIllumination
                 * @memberof osi3.MovingObject.VehicleClassification.LightState
                 * @instance
                 */
                LightState.prototype.serviceVehicleIllumination = 0;

                /**
                 * Creates a new LightState instance using the specified properties.
                 * @function create
                 * @memberof osi3.MovingObject.VehicleClassification.LightState
                 * @static
                 * @param {osi3.MovingObject.VehicleClassification.ILightState=} [properties] Properties to set
                 * @returns {osi3.MovingObject.VehicleClassification.LightState} LightState instance
                 */
                LightState.create = function create(properties) {
                    return new LightState(properties);
                };

                /**
                 * Encodes the specified LightState message. Does not implicitly {@link osi3.MovingObject.VehicleClassification.LightState.verify|verify} messages.
                 * @function encode
                 * @memberof osi3.MovingObject.VehicleClassification.LightState
                 * @static
                 * @param {osi3.MovingObject.VehicleClassification.ILightState} message LightState message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                LightState.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.indicatorState != null && Object.hasOwnProperty.call(message, "indicatorState"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.indicatorState);
                    if (message.frontFogLight != null && Object.hasOwnProperty.call(message, "frontFogLight"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.frontFogLight);
                    if (message.rearFogLight != null && Object.hasOwnProperty.call(message, "rearFogLight"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.rearFogLight);
                    if (message.headLight != null && Object.hasOwnProperty.call(message, "headLight"))
                        writer.uint32(/* id 4, wireType 0 =*/32).int32(message.headLight);
                    if (message.highBeam != null && Object.hasOwnProperty.call(message, "highBeam"))
                        writer.uint32(/* id 5, wireType 0 =*/40).int32(message.highBeam);
                    if (message.reversingLight != null && Object.hasOwnProperty.call(message, "reversingLight"))
                        writer.uint32(/* id 6, wireType 0 =*/48).int32(message.reversingLight);
                    if (message.brakeLightState != null && Object.hasOwnProperty.call(message, "brakeLightState"))
                        writer.uint32(/* id 7, wireType 0 =*/56).int32(message.brakeLightState);
                    if (message.licensePlateIlluminationRear != null && Object.hasOwnProperty.call(message, "licensePlateIlluminationRear"))
                        writer.uint32(/* id 8, wireType 0 =*/64).int32(message.licensePlateIlluminationRear);
                    if (message.emergencyVehicleIllumination != null && Object.hasOwnProperty.call(message, "emergencyVehicleIllumination"))
                        writer.uint32(/* id 9, wireType 0 =*/72).int32(message.emergencyVehicleIllumination);
                    if (message.serviceVehicleIllumination != null && Object.hasOwnProperty.call(message, "serviceVehicleIllumination"))
                        writer.uint32(/* id 10, wireType 0 =*/80).int32(message.serviceVehicleIllumination);
                    return writer;
                };

                /**
                 * Encodes the specified LightState message, length delimited. Does not implicitly {@link osi3.MovingObject.VehicleClassification.LightState.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof osi3.MovingObject.VehicleClassification.LightState
                 * @static
                 * @param {osi3.MovingObject.VehicleClassification.ILightState} message LightState message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                LightState.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a LightState message from the specified reader or buffer.
                 * @function decode
                 * @memberof osi3.MovingObject.VehicleClassification.LightState
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {osi3.MovingObject.VehicleClassification.LightState} LightState
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                LightState.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.osi3.MovingObject.VehicleClassification.LightState();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                message.indicatorState = reader.int32();
                                break;
                            }
                        case 2: {
                                message.frontFogLight = reader.int32();
                                break;
                            }
                        case 3: {
                                message.rearFogLight = reader.int32();
                                break;
                            }
                        case 4: {
                                message.headLight = reader.int32();
                                break;
                            }
                        case 5: {
                                message.highBeam = reader.int32();
                                break;
                            }
                        case 6: {
                                message.reversingLight = reader.int32();
                                break;
                            }
                        case 7: {
                                message.brakeLightState = reader.int32();
                                break;
                            }
                        case 8: {
                                message.licensePlateIlluminationRear = reader.int32();
                                break;
                            }
                        case 9: {
                                message.emergencyVehicleIllumination = reader.int32();
                                break;
                            }
                        case 10: {
                                message.serviceVehicleIllumination = reader.int32();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a LightState message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof osi3.MovingObject.VehicleClassification.LightState
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {osi3.MovingObject.VehicleClassification.LightState} LightState
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                LightState.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a LightState message.
                 * @function verify
                 * @memberof osi3.MovingObject.VehicleClassification.LightState
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                LightState.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.indicatorState != null && message.hasOwnProperty("indicatorState"))
                        switch (message.indicatorState) {
                        default:
                            return "indicatorState: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                            break;
                        }
                    if (message.frontFogLight != null && message.hasOwnProperty("frontFogLight"))
                        switch (message.frontFogLight) {
                        default:
                            return "frontFogLight: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                            break;
                        }
                    if (message.rearFogLight != null && message.hasOwnProperty("rearFogLight"))
                        switch (message.rearFogLight) {
                        default:
                            return "rearFogLight: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                            break;
                        }
                    if (message.headLight != null && message.hasOwnProperty("headLight"))
                        switch (message.headLight) {
                        default:
                            return "headLight: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                            break;
                        }
                    if (message.highBeam != null && message.hasOwnProperty("highBeam"))
                        switch (message.highBeam) {
                        default:
                            return "highBeam: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                            break;
                        }
                    if (message.reversingLight != null && message.hasOwnProperty("reversingLight"))
                        switch (message.reversingLight) {
                        default:
                            return "reversingLight: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                            break;
                        }
                    if (message.brakeLightState != null && message.hasOwnProperty("brakeLightState"))
                        switch (message.brakeLightState) {
                        default:
                            return "brakeLightState: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                            break;
                        }
                    if (message.licensePlateIlluminationRear != null && message.hasOwnProperty("licensePlateIlluminationRear"))
                        switch (message.licensePlateIlluminationRear) {
                        default:
                            return "licensePlateIlluminationRear: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                            break;
                        }
                    if (message.emergencyVehicleIllumination != null && message.hasOwnProperty("emergencyVehicleIllumination"))
                        switch (message.emergencyVehicleIllumination) {
                        default:
                            return "emergencyVehicleIllumination: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                            break;
                        }
                    if (message.serviceVehicleIllumination != null && message.hasOwnProperty("serviceVehicleIllumination"))
                        switch (message.serviceVehicleIllumination) {
                        default:
                            return "serviceVehicleIllumination: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                            break;
                        }
                    return null;
                };

                /**
                 * Creates a LightState message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof osi3.MovingObject.VehicleClassification.LightState
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {osi3.MovingObject.VehicleClassification.LightState} LightState
                 */
                LightState.fromObject = function fromObject(object) {
                    if (object instanceof $root.osi3.MovingObject.VehicleClassification.LightState)
                        return object;
                    let message = new $root.osi3.MovingObject.VehicleClassification.LightState();
                    switch (object.indicatorState) {
                    default:
                        if (typeof object.indicatorState === "number") {
                            message.indicatorState = object.indicatorState;
                            break;
                        }
                        break;
                    case "INDICATOR_STATE_UNKNOWN":
                    case 0:
                        message.indicatorState = 0;
                        break;
                    case "INDICATOR_STATE_OTHER":
                    case 1:
                        message.indicatorState = 1;
                        break;
                    case "INDICATOR_STATE_OFF":
                    case 2:
                        message.indicatorState = 2;
                        break;
                    case "INDICATOR_STATE_LEFT":
                    case 3:
                        message.indicatorState = 3;
                        break;
                    case "INDICATOR_STATE_RIGHT":
                    case 4:
                        message.indicatorState = 4;
                        break;
                    case "INDICATOR_STATE_WARNING":
                    case 5:
                        message.indicatorState = 5;
                        break;
                    }
                    switch (object.frontFogLight) {
                    default:
                        if (typeof object.frontFogLight === "number") {
                            message.frontFogLight = object.frontFogLight;
                            break;
                        }
                        break;
                    case "GENERIC_LIGHT_STATE_UNKNOWN":
                    case 0:
                        message.frontFogLight = 0;
                        break;
                    case "GENERIC_LIGHT_STATE_OTHER":
                    case 1:
                        message.frontFogLight = 1;
                        break;
                    case "GENERIC_LIGHT_STATE_OFF":
                    case 2:
                        message.frontFogLight = 2;
                        break;
                    case "GENERIC_LIGHT_STATE_ON":
                    case 3:
                        message.frontFogLight = 3;
                        break;
                    case "GENERIC_LIGHT_STATE_FLASHING_BLUE":
                    case 4:
                        message.frontFogLight = 4;
                        break;
                    case "GENERIC_LIGHT_STATE_FLASHING_BLUE_AND_RED":
                    case 5:
                        message.frontFogLight = 5;
                        break;
                    case "GENERIC_LIGHT_STATE_FLASHING_AMBER":
                    case 6:
                        message.frontFogLight = 6;
                        break;
                    }
                    switch (object.rearFogLight) {
                    default:
                        if (typeof object.rearFogLight === "number") {
                            message.rearFogLight = object.rearFogLight;
                            break;
                        }
                        break;
                    case "GENERIC_LIGHT_STATE_UNKNOWN":
                    case 0:
                        message.rearFogLight = 0;
                        break;
                    case "GENERIC_LIGHT_STATE_OTHER":
                    case 1:
                        message.rearFogLight = 1;
                        break;
                    case "GENERIC_LIGHT_STATE_OFF":
                    case 2:
                        message.rearFogLight = 2;
                        break;
                    case "GENERIC_LIGHT_STATE_ON":
                    case 3:
                        message.rearFogLight = 3;
                        break;
                    case "GENERIC_LIGHT_STATE_FLASHING_BLUE":
                    case 4:
                        message.rearFogLight = 4;
                        break;
                    case "GENERIC_LIGHT_STATE_FLASHING_BLUE_AND_RED":
                    case 5:
                        message.rearFogLight = 5;
                        break;
                    case "GENERIC_LIGHT_STATE_FLASHING_AMBER":
                    case 6:
                        message.rearFogLight = 6;
                        break;
                    }
                    switch (object.headLight) {
                    default:
                        if (typeof object.headLight === "number") {
                            message.headLight = object.headLight;
                            break;
                        }
                        break;
                    case "GENERIC_LIGHT_STATE_UNKNOWN":
                    case 0:
                        message.headLight = 0;
                        break;
                    case "GENERIC_LIGHT_STATE_OTHER":
                    case 1:
                        message.headLight = 1;
                        break;
                    case "GENERIC_LIGHT_STATE_OFF":
                    case 2:
                        message.headLight = 2;
                        break;
                    case "GENERIC_LIGHT_STATE_ON":
                    case 3:
                        message.headLight = 3;
                        break;
                    case "GENERIC_LIGHT_STATE_FLASHING_BLUE":
                    case 4:
                        message.headLight = 4;
                        break;
                    case "GENERIC_LIGHT_STATE_FLASHING_BLUE_AND_RED":
                    case 5:
                        message.headLight = 5;
                        break;
                    case "GENERIC_LIGHT_STATE_FLASHING_AMBER":
                    case 6:
                        message.headLight = 6;
                        break;
                    }
                    switch (object.highBeam) {
                    default:
                        if (typeof object.highBeam === "number") {
                            message.highBeam = object.highBeam;
                            break;
                        }
                        break;
                    case "GENERIC_LIGHT_STATE_UNKNOWN":
                    case 0:
                        message.highBeam = 0;
                        break;
                    case "GENERIC_LIGHT_STATE_OTHER":
                    case 1:
                        message.highBeam = 1;
                        break;
                    case "GENERIC_LIGHT_STATE_OFF":
                    case 2:
                        message.highBeam = 2;
                        break;
                    case "GENERIC_LIGHT_STATE_ON":
                    case 3:
                        message.highBeam = 3;
                        break;
                    case "GENERIC_LIGHT_STATE_FLASHING_BLUE":
                    case 4:
                        message.highBeam = 4;
                        break;
                    case "GENERIC_LIGHT_STATE_FLASHING_BLUE_AND_RED":
                    case 5:
                        message.highBeam = 5;
                        break;
                    case "GENERIC_LIGHT_STATE_FLASHING_AMBER":
                    case 6:
                        message.highBeam = 6;
                        break;
                    }
                    switch (object.reversingLight) {
                    default:
                        if (typeof object.reversingLight === "number") {
                            message.reversingLight = object.reversingLight;
                            break;
                        }
                        break;
                    case "GENERIC_LIGHT_STATE_UNKNOWN":
                    case 0:
                        message.reversingLight = 0;
                        break;
                    case "GENERIC_LIGHT_STATE_OTHER":
                    case 1:
                        message.reversingLight = 1;
                        break;
                    case "GENERIC_LIGHT_STATE_OFF":
                    case 2:
                        message.reversingLight = 2;
                        break;
                    case "GENERIC_LIGHT_STATE_ON":
                    case 3:
                        message.reversingLight = 3;
                        break;
                    case "GENERIC_LIGHT_STATE_FLASHING_BLUE":
                    case 4:
                        message.reversingLight = 4;
                        break;
                    case "GENERIC_LIGHT_STATE_FLASHING_BLUE_AND_RED":
                    case 5:
                        message.reversingLight = 5;
                        break;
                    case "GENERIC_LIGHT_STATE_FLASHING_AMBER":
                    case 6:
                        message.reversingLight = 6;
                        break;
                    }
                    switch (object.brakeLightState) {
                    default:
                        if (typeof object.brakeLightState === "number") {
                            message.brakeLightState = object.brakeLightState;
                            break;
                        }
                        break;
                    case "BRAKE_LIGHT_STATE_UNKNOWN":
                    case 0:
                        message.brakeLightState = 0;
                        break;
                    case "BRAKE_LIGHT_STATE_OTHER":
                    case 1:
                        message.brakeLightState = 1;
                        break;
                    case "BRAKE_LIGHT_STATE_OFF":
                    case 2:
                        message.brakeLightState = 2;
                        break;
                    case "BRAKE_LIGHT_STATE_NORMAL":
                    case 3:
                        message.brakeLightState = 3;
                        break;
                    case "BRAKE_LIGHT_STATE_STRONG":
                    case 4:
                        message.brakeLightState = 4;
                        break;
                    }
                    switch (object.licensePlateIlluminationRear) {
                    default:
                        if (typeof object.licensePlateIlluminationRear === "number") {
                            message.licensePlateIlluminationRear = object.licensePlateIlluminationRear;
                            break;
                        }
                        break;
                    case "GENERIC_LIGHT_STATE_UNKNOWN":
                    case 0:
                        message.licensePlateIlluminationRear = 0;
                        break;
                    case "GENERIC_LIGHT_STATE_OTHER":
                    case 1:
                        message.licensePlateIlluminationRear = 1;
                        break;
                    case "GENERIC_LIGHT_STATE_OFF":
                    case 2:
                        message.licensePlateIlluminationRear = 2;
                        break;
                    case "GENERIC_LIGHT_STATE_ON":
                    case 3:
                        message.licensePlateIlluminationRear = 3;
                        break;
                    case "GENERIC_LIGHT_STATE_FLASHING_BLUE":
                    case 4:
                        message.licensePlateIlluminationRear = 4;
                        break;
                    case "GENERIC_LIGHT_STATE_FLASHING_BLUE_AND_RED":
                    case 5:
                        message.licensePlateIlluminationRear = 5;
                        break;
                    case "GENERIC_LIGHT_STATE_FLASHING_AMBER":
                    case 6:
                        message.licensePlateIlluminationRear = 6;
                        break;
                    }
                    switch (object.emergencyVehicleIllumination) {
                    default:
                        if (typeof object.emergencyVehicleIllumination === "number") {
                            message.emergencyVehicleIllumination = object.emergencyVehicleIllumination;
                            break;
                        }
                        break;
                    case "GENERIC_LIGHT_STATE_UNKNOWN":
                    case 0:
                        message.emergencyVehicleIllumination = 0;
                        break;
                    case "GENERIC_LIGHT_STATE_OTHER":
                    case 1:
                        message.emergencyVehicleIllumination = 1;
                        break;
                    case "GENERIC_LIGHT_STATE_OFF":
                    case 2:
                        message.emergencyVehicleIllumination = 2;
                        break;
                    case "GENERIC_LIGHT_STATE_ON":
                    case 3:
                        message.emergencyVehicleIllumination = 3;
                        break;
                    case "GENERIC_LIGHT_STATE_FLASHING_BLUE":
                    case 4:
                        message.emergencyVehicleIllumination = 4;
                        break;
                    case "GENERIC_LIGHT_STATE_FLASHING_BLUE_AND_RED":
                    case 5:
                        message.emergencyVehicleIllumination = 5;
                        break;
                    case "GENERIC_LIGHT_STATE_FLASHING_AMBER":
                    case 6:
                        message.emergencyVehicleIllumination = 6;
                        break;
                    }
                    switch (object.serviceVehicleIllumination) {
                    default:
                        if (typeof object.serviceVehicleIllumination === "number") {
                            message.serviceVehicleIllumination = object.serviceVehicleIllumination;
                            break;
                        }
                        break;
                    case "GENERIC_LIGHT_STATE_UNKNOWN":
                    case 0:
                        message.serviceVehicleIllumination = 0;
                        break;
                    case "GENERIC_LIGHT_STATE_OTHER":
                    case 1:
                        message.serviceVehicleIllumination = 1;
                        break;
                    case "GENERIC_LIGHT_STATE_OFF":
                    case 2:
                        message.serviceVehicleIllumination = 2;
                        break;
                    case "GENERIC_LIGHT_STATE_ON":
                    case 3:
                        message.serviceVehicleIllumination = 3;
                        break;
                    case "GENERIC_LIGHT_STATE_FLASHING_BLUE":
                    case 4:
                        message.serviceVehicleIllumination = 4;
                        break;
                    case "GENERIC_LIGHT_STATE_FLASHING_BLUE_AND_RED":
                    case 5:
                        message.serviceVehicleIllumination = 5;
                        break;
                    case "GENERIC_LIGHT_STATE_FLASHING_AMBER":
                    case 6:
                        message.serviceVehicleIllumination = 6;
                        break;
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a LightState message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof osi3.MovingObject.VehicleClassification.LightState
                 * @static
                 * @param {osi3.MovingObject.VehicleClassification.LightState} message LightState
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                LightState.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.indicatorState = options.enums === String ? "INDICATOR_STATE_UNKNOWN" : 0;
                        object.frontFogLight = options.enums === String ? "GENERIC_LIGHT_STATE_UNKNOWN" : 0;
                        object.rearFogLight = options.enums === String ? "GENERIC_LIGHT_STATE_UNKNOWN" : 0;
                        object.headLight = options.enums === String ? "GENERIC_LIGHT_STATE_UNKNOWN" : 0;
                        object.highBeam = options.enums === String ? "GENERIC_LIGHT_STATE_UNKNOWN" : 0;
                        object.reversingLight = options.enums === String ? "GENERIC_LIGHT_STATE_UNKNOWN" : 0;
                        object.brakeLightState = options.enums === String ? "BRAKE_LIGHT_STATE_UNKNOWN" : 0;
                        object.licensePlateIlluminationRear = options.enums === String ? "GENERIC_LIGHT_STATE_UNKNOWN" : 0;
                        object.emergencyVehicleIllumination = options.enums === String ? "GENERIC_LIGHT_STATE_UNKNOWN" : 0;
                        object.serviceVehicleIllumination = options.enums === String ? "GENERIC_LIGHT_STATE_UNKNOWN" : 0;
                    }
                    if (message.indicatorState != null && message.hasOwnProperty("indicatorState"))
                        object.indicatorState = options.enums === String ? $root.osi3.MovingObject.VehicleClassification.LightState.IndicatorState[message.indicatorState] === undefined ? message.indicatorState : $root.osi3.MovingObject.VehicleClassification.LightState.IndicatorState[message.indicatorState] : message.indicatorState;
                    if (message.frontFogLight != null && message.hasOwnProperty("frontFogLight"))
                        object.frontFogLight = options.enums === String ? $root.osi3.MovingObject.VehicleClassification.LightState.GenericLightState[message.frontFogLight] === undefined ? message.frontFogLight : $root.osi3.MovingObject.VehicleClassification.LightState.GenericLightState[message.frontFogLight] : message.frontFogLight;
                    if (message.rearFogLight != null && message.hasOwnProperty("rearFogLight"))
                        object.rearFogLight = options.enums === String ? $root.osi3.MovingObject.VehicleClassification.LightState.GenericLightState[message.rearFogLight] === undefined ? message.rearFogLight : $root.osi3.MovingObject.VehicleClassification.LightState.GenericLightState[message.rearFogLight] : message.rearFogLight;
                    if (message.headLight != null && message.hasOwnProperty("headLight"))
                        object.headLight = options.enums === String ? $root.osi3.MovingObject.VehicleClassification.LightState.GenericLightState[message.headLight] === undefined ? message.headLight : $root.osi3.MovingObject.VehicleClassification.LightState.GenericLightState[message.headLight] : message.headLight;
                    if (message.highBeam != null && message.hasOwnProperty("highBeam"))
                        object.highBeam = options.enums === String ? $root.osi3.MovingObject.VehicleClassification.LightState.GenericLightState[message.highBeam] === undefined ? message.highBeam : $root.osi3.MovingObject.VehicleClassification.LightState.GenericLightState[message.highBeam] : message.highBeam;
                    if (message.reversingLight != null && message.hasOwnProperty("reversingLight"))
                        object.reversingLight = options.enums === String ? $root.osi3.MovingObject.VehicleClassification.LightState.GenericLightState[message.reversingLight] === undefined ? message.reversingLight : $root.osi3.MovingObject.VehicleClassification.LightState.GenericLightState[message.reversingLight] : message.reversingLight;
                    if (message.brakeLightState != null && message.hasOwnProperty("brakeLightState"))
                        object.brakeLightState = options.enums === String ? $root.osi3.MovingObject.VehicleClassification.LightState.BrakeLightState[message.brakeLightState] === undefined ? message.brakeLightState : $root.osi3.MovingObject.VehicleClassification.LightState.BrakeLightState[message.brakeLightState] : message.brakeLightState;
                    if (message.licensePlateIlluminationRear != null && message.hasOwnProperty("licensePlateIlluminationRear"))
                        object.licensePlateIlluminationRear = options.enums === String ? $root.osi3.MovingObject.VehicleClassification.LightState.GenericLightState[message.licensePlateIlluminationRear] === undefined ? message.licensePlateIlluminationRear : $root.osi3.MovingObject.VehicleClassification.LightState.GenericLightState[message.licensePlateIlluminationRear] : message.licensePlateIlluminationRear;
                    if (message.emergencyVehicleIllumination != null && message.hasOwnProperty("emergencyVehicleIllumination"))
                        object.emergencyVehicleIllumination = options.enums === String ? $root.osi3.MovingObject.VehicleClassification.LightState.GenericLightState[message.emergencyVehicleIllumination] === undefined ? message.emergencyVehicleIllumination : $root.osi3.MovingObject.VehicleClassification.LightState.GenericLightState[message.emergencyVehicleIllumination] : message.emergencyVehicleIllumination;
                    if (message.serviceVehicleIllumination != null && message.hasOwnProperty("serviceVehicleIllumination"))
                        object.serviceVehicleIllumination = options.enums === String ? $root.osi3.MovingObject.VehicleClassification.LightState.GenericLightState[message.serviceVehicleIllumination] === undefined ? message.serviceVehicleIllumination : $root.osi3.MovingObject.VehicleClassification.LightState.GenericLightState[message.serviceVehicleIllumination] : message.serviceVehicleIllumination;
                    return object;
                };

                /**
                 * Converts this LightState to JSON.
                 * @function toJSON
                 * @memberof osi3.MovingObject.VehicleClassification.LightState
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                LightState.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for LightState
                 * @function getTypeUrl
                 * @memberof osi3.MovingObject.VehicleClassification.LightState
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                LightState.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/osi3.MovingObject.VehicleClassification.LightState";
                };

                /**
                 * IndicatorState enum.
                 * @name osi3.MovingObject.VehicleClassification.LightState.IndicatorState
                 * @enum {number}
                 * @property {number} INDICATOR_STATE_UNKNOWN=0 INDICATOR_STATE_UNKNOWN value
                 * @property {number} INDICATOR_STATE_OTHER=1 INDICATOR_STATE_OTHER value
                 * @property {number} INDICATOR_STATE_OFF=2 INDICATOR_STATE_OFF value
                 * @property {number} INDICATOR_STATE_LEFT=3 INDICATOR_STATE_LEFT value
                 * @property {number} INDICATOR_STATE_RIGHT=4 INDICATOR_STATE_RIGHT value
                 * @property {number} INDICATOR_STATE_WARNING=5 INDICATOR_STATE_WARNING value
                 */
                LightState.IndicatorState = (function() {
                    const valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "INDICATOR_STATE_UNKNOWN"] = 0;
                    values[valuesById[1] = "INDICATOR_STATE_OTHER"] = 1;
                    values[valuesById[2] = "INDICATOR_STATE_OFF"] = 2;
                    values[valuesById[3] = "INDICATOR_STATE_LEFT"] = 3;
                    values[valuesById[4] = "INDICATOR_STATE_RIGHT"] = 4;
                    values[valuesById[5] = "INDICATOR_STATE_WARNING"] = 5;
                    return values;
                })();

                /**
                 * GenericLightState enum.
                 * @name osi3.MovingObject.VehicleClassification.LightState.GenericLightState
                 * @enum {number}
                 * @property {number} GENERIC_LIGHT_STATE_UNKNOWN=0 GENERIC_LIGHT_STATE_UNKNOWN value
                 * @property {number} GENERIC_LIGHT_STATE_OTHER=1 GENERIC_LIGHT_STATE_OTHER value
                 * @property {number} GENERIC_LIGHT_STATE_OFF=2 GENERIC_LIGHT_STATE_OFF value
                 * @property {number} GENERIC_LIGHT_STATE_ON=3 GENERIC_LIGHT_STATE_ON value
                 * @property {number} GENERIC_LIGHT_STATE_FLASHING_BLUE=4 GENERIC_LIGHT_STATE_FLASHING_BLUE value
                 * @property {number} GENERIC_LIGHT_STATE_FLASHING_BLUE_AND_RED=5 GENERIC_LIGHT_STATE_FLASHING_BLUE_AND_RED value
                 * @property {number} GENERIC_LIGHT_STATE_FLASHING_AMBER=6 GENERIC_LIGHT_STATE_FLASHING_AMBER value
                 */
                LightState.GenericLightState = (function() {
                    const valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "GENERIC_LIGHT_STATE_UNKNOWN"] = 0;
                    values[valuesById[1] = "GENERIC_LIGHT_STATE_OTHER"] = 1;
                    values[valuesById[2] = "GENERIC_LIGHT_STATE_OFF"] = 2;
                    values[valuesById[3] = "GENERIC_LIGHT_STATE_ON"] = 3;
                    values[valuesById[4] = "GENERIC_LIGHT_STATE_FLASHING_BLUE"] = 4;
                    values[valuesById[5] = "GENERIC_LIGHT_STATE_FLASHING_BLUE_AND_RED"] = 5;
                    values[valuesById[6] = "GENERIC_LIGHT_STATE_FLASHING_AMBER"] = 6;
                    return values;
                })();

                /**
                 * BrakeLightState enum.
                 * @name osi3.MovingObject.VehicleClassification.LightState.BrakeLightState
                 * @enum {number}
                 * @property {number} BRAKE_LIGHT_STATE_UNKNOWN=0 BRAKE_LIGHT_STATE_UNKNOWN value
                 * @property {number} BRAKE_LIGHT_STATE_OTHER=1 BRAKE_LIGHT_STATE_OTHER value
                 * @property {number} BRAKE_LIGHT_STATE_OFF=2 BRAKE_LIGHT_STATE_OFF value
                 * @property {number} BRAKE_LIGHT_STATE_NORMAL=3 BRAKE_LIGHT_STATE_NORMAL value
                 * @property {number} BRAKE_LIGHT_STATE_STRONG=4 BRAKE_LIGHT_STATE_STRONG value
                 */
                LightState.BrakeLightState = (function() {
                    const valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "BRAKE_LIGHT_STATE_UNKNOWN"] = 0;
                    values[valuesById[1] = "BRAKE_LIGHT_STATE_OTHER"] = 1;
                    values[valuesById[2] = "BRAKE_LIGHT_STATE_OFF"] = 2;
                    values[valuesById[3] = "BRAKE_LIGHT_STATE_NORMAL"] = 3;
                    values[valuesById[4] = "BRAKE_LIGHT_STATE_STRONG"] = 4;
                    return values;
                })();

                return LightState;
            })();

            /**
             * Role enum.
             * @name osi3.MovingObject.VehicleClassification.Role
             * @enum {number}
             * @property {number} ROLE_UNKNOWN=0 ROLE_UNKNOWN value
             * @property {number} ROLE_OTHER=1 ROLE_OTHER value
             * @property {number} ROLE_CIVIL=2 ROLE_CIVIL value
             * @property {number} ROLE_AMBULANCE=3 ROLE_AMBULANCE value
             * @property {number} ROLE_FIRE=4 ROLE_FIRE value
             * @property {number} ROLE_POLICE=5 ROLE_POLICE value
             * @property {number} ROLE_PUBLIC_TRANSPORT=6 ROLE_PUBLIC_TRANSPORT value
             * @property {number} ROLE_ROAD_ASSISTANCE=7 ROLE_ROAD_ASSISTANCE value
             * @property {number} ROLE_GARBAGE_COLLECTION=8 ROLE_GARBAGE_COLLECTION value
             * @property {number} ROLE_ROAD_CONSTRUCTION=9 ROLE_ROAD_CONSTRUCTION value
             * @property {number} ROLE_MILITARY=10 ROLE_MILITARY value
             */
            VehicleClassification.Role = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "ROLE_UNKNOWN"] = 0;
                values[valuesById[1] = "ROLE_OTHER"] = 1;
                values[valuesById[2] = "ROLE_CIVIL"] = 2;
                values[valuesById[3] = "ROLE_AMBULANCE"] = 3;
                values[valuesById[4] = "ROLE_FIRE"] = 4;
                values[valuesById[5] = "ROLE_POLICE"] = 5;
                values[valuesById[6] = "ROLE_PUBLIC_TRANSPORT"] = 6;
                values[valuesById[7] = "ROLE_ROAD_ASSISTANCE"] = 7;
                values[valuesById[8] = "ROLE_GARBAGE_COLLECTION"] = 8;
                values[valuesById[9] = "ROLE_ROAD_CONSTRUCTION"] = 9;
                values[valuesById[10] = "ROLE_MILITARY"] = 10;
                return values;
            })();

            return VehicleClassification;
        })();

        MovingObject.PedestrianAttributes = (function() {

            /**
             * Properties of a PedestrianAttributes.
             * @memberof osi3.MovingObject
             * @interface IPedestrianAttributes
             * @property {osi3.IVector3d|null} [bbcenterToRoot] PedestrianAttributes bbcenterToRoot
             * @property {Array.<osi3.MovingObject.PedestrianAttributes.IBone>|null} [skeletonBone] PedestrianAttributes skeletonBone
             */

            /**
             * Constructs a new PedestrianAttributes.
             * @memberof osi3.MovingObject
             * @classdesc Represents a PedestrianAttributes.
             * @implements IPedestrianAttributes
             * @constructor
             * @param {osi3.MovingObject.IPedestrianAttributes=} [properties] Properties to set
             */
            function PedestrianAttributes(properties) {
                this.skeletonBone = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PedestrianAttributes bbcenterToRoot.
             * @member {osi3.IVector3d|null|undefined} bbcenterToRoot
             * @memberof osi3.MovingObject.PedestrianAttributes
             * @instance
             */
            PedestrianAttributes.prototype.bbcenterToRoot = null;

            /**
             * PedestrianAttributes skeletonBone.
             * @member {Array.<osi3.MovingObject.PedestrianAttributes.IBone>} skeletonBone
             * @memberof osi3.MovingObject.PedestrianAttributes
             * @instance
             */
            PedestrianAttributes.prototype.skeletonBone = $util.emptyArray;

            /**
             * Creates a new PedestrianAttributes instance using the specified properties.
             * @function create
             * @memberof osi3.MovingObject.PedestrianAttributes
             * @static
             * @param {osi3.MovingObject.IPedestrianAttributes=} [properties] Properties to set
             * @returns {osi3.MovingObject.PedestrianAttributes} PedestrianAttributes instance
             */
            PedestrianAttributes.create = function create(properties) {
                return new PedestrianAttributes(properties);
            };

            /**
             * Encodes the specified PedestrianAttributes message. Does not implicitly {@link osi3.MovingObject.PedestrianAttributes.verify|verify} messages.
             * @function encode
             * @memberof osi3.MovingObject.PedestrianAttributes
             * @static
             * @param {osi3.MovingObject.IPedestrianAttributes} message PedestrianAttributes message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PedestrianAttributes.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.bbcenterToRoot != null && Object.hasOwnProperty.call(message, "bbcenterToRoot"))
                    $root.osi3.Vector3d.encode(message.bbcenterToRoot, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.skeletonBone != null && message.skeletonBone.length)
                    for (let i = 0; i < message.skeletonBone.length; ++i)
                        $root.osi3.MovingObject.PedestrianAttributes.Bone.encode(message.skeletonBone[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified PedestrianAttributes message, length delimited. Does not implicitly {@link osi3.MovingObject.PedestrianAttributes.verify|verify} messages.
             * @function encodeDelimited
             * @memberof osi3.MovingObject.PedestrianAttributes
             * @static
             * @param {osi3.MovingObject.IPedestrianAttributes} message PedestrianAttributes message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PedestrianAttributes.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PedestrianAttributes message from the specified reader or buffer.
             * @function decode
             * @memberof osi3.MovingObject.PedestrianAttributes
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {osi3.MovingObject.PedestrianAttributes} PedestrianAttributes
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PedestrianAttributes.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.osi3.MovingObject.PedestrianAttributes();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.bbcenterToRoot = $root.osi3.Vector3d.decode(reader, reader.uint32());
                            break;
                        }
                    case 2: {
                            if (!(message.skeletonBone && message.skeletonBone.length))
                                message.skeletonBone = [];
                            message.skeletonBone.push($root.osi3.MovingObject.PedestrianAttributes.Bone.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PedestrianAttributes message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof osi3.MovingObject.PedestrianAttributes
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {osi3.MovingObject.PedestrianAttributes} PedestrianAttributes
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PedestrianAttributes.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PedestrianAttributes message.
             * @function verify
             * @memberof osi3.MovingObject.PedestrianAttributes
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PedestrianAttributes.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.bbcenterToRoot != null && message.hasOwnProperty("bbcenterToRoot")) {
                    let error = $root.osi3.Vector3d.verify(message.bbcenterToRoot);
                    if (error)
                        return "bbcenterToRoot." + error;
                }
                if (message.skeletonBone != null && message.hasOwnProperty("skeletonBone")) {
                    if (!Array.isArray(message.skeletonBone))
                        return "skeletonBone: array expected";
                    for (let i = 0; i < message.skeletonBone.length; ++i) {
                        let error = $root.osi3.MovingObject.PedestrianAttributes.Bone.verify(message.skeletonBone[i]);
                        if (error)
                            return "skeletonBone." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a PedestrianAttributes message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof osi3.MovingObject.PedestrianAttributes
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {osi3.MovingObject.PedestrianAttributes} PedestrianAttributes
             */
            PedestrianAttributes.fromObject = function fromObject(object) {
                if (object instanceof $root.osi3.MovingObject.PedestrianAttributes)
                    return object;
                let message = new $root.osi3.MovingObject.PedestrianAttributes();
                if (object.bbcenterToRoot != null) {
                    if (typeof object.bbcenterToRoot !== "object")
                        throw TypeError(".osi3.MovingObject.PedestrianAttributes.bbcenterToRoot: object expected");
                    message.bbcenterToRoot = $root.osi3.Vector3d.fromObject(object.bbcenterToRoot);
                }
                if (object.skeletonBone) {
                    if (!Array.isArray(object.skeletonBone))
                        throw TypeError(".osi3.MovingObject.PedestrianAttributes.skeletonBone: array expected");
                    message.skeletonBone = [];
                    for (let i = 0; i < object.skeletonBone.length; ++i) {
                        if (typeof object.skeletonBone[i] !== "object")
                            throw TypeError(".osi3.MovingObject.PedestrianAttributes.skeletonBone: object expected");
                        message.skeletonBone[i] = $root.osi3.MovingObject.PedestrianAttributes.Bone.fromObject(object.skeletonBone[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a PedestrianAttributes message. Also converts values to other types if specified.
             * @function toObject
             * @memberof osi3.MovingObject.PedestrianAttributes
             * @static
             * @param {osi3.MovingObject.PedestrianAttributes} message PedestrianAttributes
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PedestrianAttributes.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.skeletonBone = [];
                if (options.defaults)
                    object.bbcenterToRoot = null;
                if (message.bbcenterToRoot != null && message.hasOwnProperty("bbcenterToRoot"))
                    object.bbcenterToRoot = $root.osi3.Vector3d.toObject(message.bbcenterToRoot, options);
                if (message.skeletonBone && message.skeletonBone.length) {
                    object.skeletonBone = [];
                    for (let j = 0; j < message.skeletonBone.length; ++j)
                        object.skeletonBone[j] = $root.osi3.MovingObject.PedestrianAttributes.Bone.toObject(message.skeletonBone[j], options);
                }
                return object;
            };

            /**
             * Converts this PedestrianAttributes to JSON.
             * @function toJSON
             * @memberof osi3.MovingObject.PedestrianAttributes
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PedestrianAttributes.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for PedestrianAttributes
             * @function getTypeUrl
             * @memberof osi3.MovingObject.PedestrianAttributes
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            PedestrianAttributes.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/osi3.MovingObject.PedestrianAttributes";
            };

            PedestrianAttributes.Bone = (function() {

                /**
                 * Properties of a Bone.
                 * @memberof osi3.MovingObject.PedestrianAttributes
                 * @interface IBone
                 * @property {osi3.MovingObject.PedestrianAttributes.Bone.Type|null} [type] Bone type
                 * @property {osi3.IVector3d|null} [position] Bone position
                 * @property {osi3.IOrientation3d|null} [orientation] Bone orientation
                 * @property {number|null} [length] Bone length
                 * @property {boolean|null} [missing] Bone missing
                 * @property {osi3.IVector3d|null} [velocity] Bone velocity
                 * @property {osi3.IOrientation3d|null} [orientationRate] Bone orientationRate
                 */

                /**
                 * Constructs a new Bone.
                 * @memberof osi3.MovingObject.PedestrianAttributes
                 * @classdesc Represents a Bone.
                 * @implements IBone
                 * @constructor
                 * @param {osi3.MovingObject.PedestrianAttributes.IBone=} [properties] Properties to set
                 */
                function Bone(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Bone type.
                 * @member {osi3.MovingObject.PedestrianAttributes.Bone.Type} type
                 * @memberof osi3.MovingObject.PedestrianAttributes.Bone
                 * @instance
                 */
                Bone.prototype.type = 0;

                /**
                 * Bone position.
                 * @member {osi3.IVector3d|null|undefined} position
                 * @memberof osi3.MovingObject.PedestrianAttributes.Bone
                 * @instance
                 */
                Bone.prototype.position = null;

                /**
                 * Bone orientation.
                 * @member {osi3.IOrientation3d|null|undefined} orientation
                 * @memberof osi3.MovingObject.PedestrianAttributes.Bone
                 * @instance
                 */
                Bone.prototype.orientation = null;

                /**
                 * Bone length.
                 * @member {number} length
                 * @memberof osi3.MovingObject.PedestrianAttributes.Bone
                 * @instance
                 */
                Bone.prototype.length = 0;

                /**
                 * Bone missing.
                 * @member {boolean} missing
                 * @memberof osi3.MovingObject.PedestrianAttributes.Bone
                 * @instance
                 */
                Bone.prototype.missing = false;

                /**
                 * Bone velocity.
                 * @member {osi3.IVector3d|null|undefined} velocity
                 * @memberof osi3.MovingObject.PedestrianAttributes.Bone
                 * @instance
                 */
                Bone.prototype.velocity = null;

                /**
                 * Bone orientationRate.
                 * @member {osi3.IOrientation3d|null|undefined} orientationRate
                 * @memberof osi3.MovingObject.PedestrianAttributes.Bone
                 * @instance
                 */
                Bone.prototype.orientationRate = null;

                /**
                 * Creates a new Bone instance using the specified properties.
                 * @function create
                 * @memberof osi3.MovingObject.PedestrianAttributes.Bone
                 * @static
                 * @param {osi3.MovingObject.PedestrianAttributes.IBone=} [properties] Properties to set
                 * @returns {osi3.MovingObject.PedestrianAttributes.Bone} Bone instance
                 */
                Bone.create = function create(properties) {
                    return new Bone(properties);
                };

                /**
                 * Encodes the specified Bone message. Does not implicitly {@link osi3.MovingObject.PedestrianAttributes.Bone.verify|verify} messages.
                 * @function encode
                 * @memberof osi3.MovingObject.PedestrianAttributes.Bone
                 * @static
                 * @param {osi3.MovingObject.PedestrianAttributes.IBone} message Bone message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Bone.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                    if (message.position != null && Object.hasOwnProperty.call(message, "position"))
                        $root.osi3.Vector3d.encode(message.position, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.orientation != null && Object.hasOwnProperty.call(message, "orientation"))
                        $root.osi3.Orientation3d.encode(message.orientation, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.length != null && Object.hasOwnProperty.call(message, "length"))
                        writer.uint32(/* id 4, wireType 5 =*/37).float(message.length);
                    if (message.missing != null && Object.hasOwnProperty.call(message, "missing"))
                        writer.uint32(/* id 5, wireType 0 =*/40).bool(message.missing);
                    if (message.velocity != null && Object.hasOwnProperty.call(message, "velocity"))
                        $root.osi3.Vector3d.encode(message.velocity, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                    if (message.orientationRate != null && Object.hasOwnProperty.call(message, "orientationRate"))
                        $root.osi3.Orientation3d.encode(message.orientationRate, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified Bone message, length delimited. Does not implicitly {@link osi3.MovingObject.PedestrianAttributes.Bone.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof osi3.MovingObject.PedestrianAttributes.Bone
                 * @static
                 * @param {osi3.MovingObject.PedestrianAttributes.IBone} message Bone message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Bone.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Bone message from the specified reader or buffer.
                 * @function decode
                 * @memberof osi3.MovingObject.PedestrianAttributes.Bone
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {osi3.MovingObject.PedestrianAttributes.Bone} Bone
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Bone.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.osi3.MovingObject.PedestrianAttributes.Bone();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                message.type = reader.int32();
                                break;
                            }
                        case 2: {
                                message.position = $root.osi3.Vector3d.decode(reader, reader.uint32());
                                break;
                            }
                        case 3: {
                                message.orientation = $root.osi3.Orientation3d.decode(reader, reader.uint32());
                                break;
                            }
                        case 4: {
                                message.length = reader.float();
                                break;
                            }
                        case 5: {
                                message.missing = reader.bool();
                                break;
                            }
                        case 6: {
                                message.velocity = $root.osi3.Vector3d.decode(reader, reader.uint32());
                                break;
                            }
                        case 7: {
                                message.orientationRate = $root.osi3.Orientation3d.decode(reader, reader.uint32());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Bone message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof osi3.MovingObject.PedestrianAttributes.Bone
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {osi3.MovingObject.PedestrianAttributes.Bone} Bone
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Bone.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Bone message.
                 * @function verify
                 * @memberof osi3.MovingObject.PedestrianAttributes.Bone
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Bone.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.type != null && message.hasOwnProperty("type"))
                        switch (message.type) {
                        default:
                            return "type: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                        case 7:
                        case 8:
                        case 9:
                        case 10:
                        case 11:
                        case 12:
                        case 13:
                        case 14:
                        case 15:
                        case 16:
                        case 17:
                        case 18:
                        case 19:
                            break;
                        }
                    if (message.position != null && message.hasOwnProperty("position")) {
                        let error = $root.osi3.Vector3d.verify(message.position);
                        if (error)
                            return "position." + error;
                    }
                    if (message.orientation != null && message.hasOwnProperty("orientation")) {
                        let error = $root.osi3.Orientation3d.verify(message.orientation);
                        if (error)
                            return "orientation." + error;
                    }
                    if (message.length != null && message.hasOwnProperty("length"))
                        if (typeof message.length !== "number")
                            return "length: number expected";
                    if (message.missing != null && message.hasOwnProperty("missing"))
                        if (typeof message.missing !== "boolean")
                            return "missing: boolean expected";
                    if (message.velocity != null && message.hasOwnProperty("velocity")) {
                        let error = $root.osi3.Vector3d.verify(message.velocity);
                        if (error)
                            return "velocity." + error;
                    }
                    if (message.orientationRate != null && message.hasOwnProperty("orientationRate")) {
                        let error = $root.osi3.Orientation3d.verify(message.orientationRate);
                        if (error)
                            return "orientationRate." + error;
                    }
                    return null;
                };

                /**
                 * Creates a Bone message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof osi3.MovingObject.PedestrianAttributes.Bone
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {osi3.MovingObject.PedestrianAttributes.Bone} Bone
                 */
                Bone.fromObject = function fromObject(object) {
                    if (object instanceof $root.osi3.MovingObject.PedestrianAttributes.Bone)
                        return object;
                    let message = new $root.osi3.MovingObject.PedestrianAttributes.Bone();
                    switch (object.type) {
                    default:
                        if (typeof object.type === "number") {
                            message.type = object.type;
                            break;
                        }
                        break;
                    case "TYPE_ROOT":
                    case 0:
                        message.type = 0;
                        break;
                    case "TYPE_HIP":
                    case 1:
                        message.type = 1;
                        break;
                    case "TYPE_LOWER_SPINE":
                    case 2:
                        message.type = 2;
                        break;
                    case "TYPE_UPPER_SPINE":
                    case 3:
                        message.type = 3;
                        break;
                    case "TYPE_NECK":
                    case 4:
                        message.type = 4;
                        break;
                    case "TYPE_HEAD":
                    case 5:
                        message.type = 5;
                        break;
                    case "TYPE_SHOULDER_L":
                    case 6:
                        message.type = 6;
                        break;
                    case "TYPE_SHOULDER_R":
                    case 7:
                        message.type = 7;
                        break;
                    case "TYPE_UPPER_ARM_L":
                    case 8:
                        message.type = 8;
                        break;
                    case "TYPE_UPPER_ARM_R":
                    case 9:
                        message.type = 9;
                        break;
                    case "TYPE_LOWER_ARM_L":
                    case 10:
                        message.type = 10;
                        break;
                    case "TYPE_LOWER_ARM_R":
                    case 11:
                        message.type = 11;
                        break;
                    case "TYPE_FULL_HAND_L":
                    case 12:
                        message.type = 12;
                        break;
                    case "TYPE_FULL_HAND_R":
                    case 13:
                        message.type = 13;
                        break;
                    case "TYPE_UPPER_LEG_L":
                    case 14:
                        message.type = 14;
                        break;
                    case "TYPE_UPPER_LEG_R":
                    case 15:
                        message.type = 15;
                        break;
                    case "TYPE_LOWER_LEG_L":
                    case 16:
                        message.type = 16;
                        break;
                    case "TYPE_LOWER_LEG_R":
                    case 17:
                        message.type = 17;
                        break;
                    case "TYPE_FULL_FOOT_L":
                    case 18:
                        message.type = 18;
                        break;
                    case "TYPE_FULL_FOOT_R":
                    case 19:
                        message.type = 19;
                        break;
                    }
                    if (object.position != null) {
                        if (typeof object.position !== "object")
                            throw TypeError(".osi3.MovingObject.PedestrianAttributes.Bone.position: object expected");
                        message.position = $root.osi3.Vector3d.fromObject(object.position);
                    }
                    if (object.orientation != null) {
                        if (typeof object.orientation !== "object")
                            throw TypeError(".osi3.MovingObject.PedestrianAttributes.Bone.orientation: object expected");
                        message.orientation = $root.osi3.Orientation3d.fromObject(object.orientation);
                    }
                    if (object.length != null)
                        message.length = Number(object.length);
                    if (object.missing != null)
                        message.missing = Boolean(object.missing);
                    if (object.velocity != null) {
                        if (typeof object.velocity !== "object")
                            throw TypeError(".osi3.MovingObject.PedestrianAttributes.Bone.velocity: object expected");
                        message.velocity = $root.osi3.Vector3d.fromObject(object.velocity);
                    }
                    if (object.orientationRate != null) {
                        if (typeof object.orientationRate !== "object")
                            throw TypeError(".osi3.MovingObject.PedestrianAttributes.Bone.orientationRate: object expected");
                        message.orientationRate = $root.osi3.Orientation3d.fromObject(object.orientationRate);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Bone message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof osi3.MovingObject.PedestrianAttributes.Bone
                 * @static
                 * @param {osi3.MovingObject.PedestrianAttributes.Bone} message Bone
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Bone.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.type = options.enums === String ? "TYPE_ROOT" : 0;
                        object.position = null;
                        object.orientation = null;
                        object.length = 0;
                        object.missing = false;
                        object.velocity = null;
                        object.orientationRate = null;
                    }
                    if (message.type != null && message.hasOwnProperty("type"))
                        object.type = options.enums === String ? $root.osi3.MovingObject.PedestrianAttributes.Bone.Type[message.type] === undefined ? message.type : $root.osi3.MovingObject.PedestrianAttributes.Bone.Type[message.type] : message.type;
                    if (message.position != null && message.hasOwnProperty("position"))
                        object.position = $root.osi3.Vector3d.toObject(message.position, options);
                    if (message.orientation != null && message.hasOwnProperty("orientation"))
                        object.orientation = $root.osi3.Orientation3d.toObject(message.orientation, options);
                    if (message.length != null && message.hasOwnProperty("length"))
                        object.length = options.json && !isFinite(message.length) ? String(message.length) : message.length;
                    if (message.missing != null && message.hasOwnProperty("missing"))
                        object.missing = message.missing;
                    if (message.velocity != null && message.hasOwnProperty("velocity"))
                        object.velocity = $root.osi3.Vector3d.toObject(message.velocity, options);
                    if (message.orientationRate != null && message.hasOwnProperty("orientationRate"))
                        object.orientationRate = $root.osi3.Orientation3d.toObject(message.orientationRate, options);
                    return object;
                };

                /**
                 * Converts this Bone to JSON.
                 * @function toJSON
                 * @memberof osi3.MovingObject.PedestrianAttributes.Bone
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Bone.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for Bone
                 * @function getTypeUrl
                 * @memberof osi3.MovingObject.PedestrianAttributes.Bone
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                Bone.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/osi3.MovingObject.PedestrianAttributes.Bone";
                };

                /**
                 * Type enum.
                 * @name osi3.MovingObject.PedestrianAttributes.Bone.Type
                 * @enum {number}
                 * @property {number} TYPE_ROOT=0 TYPE_ROOT value
                 * @property {number} TYPE_HIP=1 TYPE_HIP value
                 * @property {number} TYPE_LOWER_SPINE=2 TYPE_LOWER_SPINE value
                 * @property {number} TYPE_UPPER_SPINE=3 TYPE_UPPER_SPINE value
                 * @property {number} TYPE_NECK=4 TYPE_NECK value
                 * @property {number} TYPE_HEAD=5 TYPE_HEAD value
                 * @property {number} TYPE_SHOULDER_L=6 TYPE_SHOULDER_L value
                 * @property {number} TYPE_SHOULDER_R=7 TYPE_SHOULDER_R value
                 * @property {number} TYPE_UPPER_ARM_L=8 TYPE_UPPER_ARM_L value
                 * @property {number} TYPE_UPPER_ARM_R=9 TYPE_UPPER_ARM_R value
                 * @property {number} TYPE_LOWER_ARM_L=10 TYPE_LOWER_ARM_L value
                 * @property {number} TYPE_LOWER_ARM_R=11 TYPE_LOWER_ARM_R value
                 * @property {number} TYPE_FULL_HAND_L=12 TYPE_FULL_HAND_L value
                 * @property {number} TYPE_FULL_HAND_R=13 TYPE_FULL_HAND_R value
                 * @property {number} TYPE_UPPER_LEG_L=14 TYPE_UPPER_LEG_L value
                 * @property {number} TYPE_UPPER_LEG_R=15 TYPE_UPPER_LEG_R value
                 * @property {number} TYPE_LOWER_LEG_L=16 TYPE_LOWER_LEG_L value
                 * @property {number} TYPE_LOWER_LEG_R=17 TYPE_LOWER_LEG_R value
                 * @property {number} TYPE_FULL_FOOT_L=18 TYPE_FULL_FOOT_L value
                 * @property {number} TYPE_FULL_FOOT_R=19 TYPE_FULL_FOOT_R value
                 */
                Bone.Type = (function() {
                    const valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "TYPE_ROOT"] = 0;
                    values[valuesById[1] = "TYPE_HIP"] = 1;
                    values[valuesById[2] = "TYPE_LOWER_SPINE"] = 2;
                    values[valuesById[3] = "TYPE_UPPER_SPINE"] = 3;
                    values[valuesById[4] = "TYPE_NECK"] = 4;
                    values[valuesById[5] = "TYPE_HEAD"] = 5;
                    values[valuesById[6] = "TYPE_SHOULDER_L"] = 6;
                    values[valuesById[7] = "TYPE_SHOULDER_R"] = 7;
                    values[valuesById[8] = "TYPE_UPPER_ARM_L"] = 8;
                    values[valuesById[9] = "TYPE_UPPER_ARM_R"] = 9;
                    values[valuesById[10] = "TYPE_LOWER_ARM_L"] = 10;
                    values[valuesById[11] = "TYPE_LOWER_ARM_R"] = 11;
                    values[valuesById[12] = "TYPE_FULL_HAND_L"] = 12;
                    values[valuesById[13] = "TYPE_FULL_HAND_R"] = 13;
                    values[valuesById[14] = "TYPE_UPPER_LEG_L"] = 14;
                    values[valuesById[15] = "TYPE_UPPER_LEG_R"] = 15;
                    values[valuesById[16] = "TYPE_LOWER_LEG_L"] = 16;
                    values[valuesById[17] = "TYPE_LOWER_LEG_R"] = 17;
                    values[valuesById[18] = "TYPE_FULL_FOOT_L"] = 18;
                    values[valuesById[19] = "TYPE_FULL_FOOT_R"] = 19;
                    return values;
                })();

                return Bone;
            })();

            return PedestrianAttributes;
        })();

        return MovingObject;
    })();

    osi3.ReferenceLine = (function() {

        /**
         * Properties of a ReferenceLine.
         * @memberof osi3
         * @interface IReferenceLine
         * @property {osi3.IIdentifier|null} [id] ReferenceLine id
         * @property {osi3.ReferenceLine.Type|null} [type] ReferenceLine type
         * @property {Array.<osi3.ReferenceLine.IReferenceLinePoint>|null} [polyLine] ReferenceLine polyLine
         */

        /**
         * Constructs a new ReferenceLine.
         * @memberof osi3
         * @classdesc Represents a ReferenceLine.
         * @implements IReferenceLine
         * @constructor
         * @param {osi3.IReferenceLine=} [properties] Properties to set
         */
        function ReferenceLine(properties) {
            this.polyLine = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ReferenceLine id.
         * @member {osi3.IIdentifier|null|undefined} id
         * @memberof osi3.ReferenceLine
         * @instance
         */
        ReferenceLine.prototype.id = null;

        /**
         * ReferenceLine type.
         * @member {osi3.ReferenceLine.Type} type
         * @memberof osi3.ReferenceLine
         * @instance
         */
        ReferenceLine.prototype.type = 0;

        /**
         * ReferenceLine polyLine.
         * @member {Array.<osi3.ReferenceLine.IReferenceLinePoint>} polyLine
         * @memberof osi3.ReferenceLine
         * @instance
         */
        ReferenceLine.prototype.polyLine = $util.emptyArray;

        /**
         * Creates a new ReferenceLine instance using the specified properties.
         * @function create
         * @memberof osi3.ReferenceLine
         * @static
         * @param {osi3.IReferenceLine=} [properties] Properties to set
         * @returns {osi3.ReferenceLine} ReferenceLine instance
         */
        ReferenceLine.create = function create(properties) {
            return new ReferenceLine(properties);
        };

        /**
         * Encodes the specified ReferenceLine message. Does not implicitly {@link osi3.ReferenceLine.verify|verify} messages.
         * @function encode
         * @memberof osi3.ReferenceLine
         * @static
         * @param {osi3.IReferenceLine} message ReferenceLine message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReferenceLine.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                $root.osi3.Identifier.encode(message.id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.polyLine != null && message.polyLine.length)
                for (let i = 0; i < message.polyLine.length; ++i)
                    $root.osi3.ReferenceLine.ReferenceLinePoint.encode(message.polyLine[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.type);
            return writer;
        };

        /**
         * Encodes the specified ReferenceLine message, length delimited. Does not implicitly {@link osi3.ReferenceLine.verify|verify} messages.
         * @function encodeDelimited
         * @memberof osi3.ReferenceLine
         * @static
         * @param {osi3.IReferenceLine} message ReferenceLine message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReferenceLine.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ReferenceLine message from the specified reader or buffer.
         * @function decode
         * @memberof osi3.ReferenceLine
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {osi3.ReferenceLine} ReferenceLine
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReferenceLine.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.osi3.ReferenceLine();
            while (reader.pos < end) {
                let tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.id = $root.osi3.Identifier.decode(reader, reader.uint32());
                        break;
                    }
                case 3: {
                        message.type = reader.int32();
                        break;
                    }
                case 2: {
                        if (!(message.polyLine && message.polyLine.length))
                            message.polyLine = [];
                        message.polyLine.push($root.osi3.ReferenceLine.ReferenceLinePoint.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ReferenceLine message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof osi3.ReferenceLine
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {osi3.ReferenceLine} ReferenceLine
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReferenceLine.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ReferenceLine message.
         * @function verify
         * @memberof osi3.ReferenceLine
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ReferenceLine.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id")) {
                let error = $root.osi3.Identifier.verify(message.id);
                if (error)
                    return "id." + error;
            }
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.polyLine != null && message.hasOwnProperty("polyLine")) {
                if (!Array.isArray(message.polyLine))
                    return "polyLine: array expected";
                for (let i = 0; i < message.polyLine.length; ++i) {
                    let error = $root.osi3.ReferenceLine.ReferenceLinePoint.verify(message.polyLine[i]);
                    if (error)
                        return "polyLine." + error;
                }
            }
            return null;
        };

        /**
         * Creates a ReferenceLine message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof osi3.ReferenceLine
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {osi3.ReferenceLine} ReferenceLine
         */
        ReferenceLine.fromObject = function fromObject(object) {
            if (object instanceof $root.osi3.ReferenceLine)
                return object;
            let message = new $root.osi3.ReferenceLine();
            if (object.id != null) {
                if (typeof object.id !== "object")
                    throw TypeError(".osi3.ReferenceLine.id: object expected");
                message.id = $root.osi3.Identifier.fromObject(object.id);
            }
            switch (object.type) {
            default:
                if (typeof object.type === "number") {
                    message.type = object.type;
                    break;
                }
                break;
            case "TYPE_POLYLINE":
            case 0:
                message.type = 0;
                break;
            case "TYPE_POLYLINE_WITH_T_AXIS":
            case 1:
                message.type = 1;
                break;
            }
            if (object.polyLine) {
                if (!Array.isArray(object.polyLine))
                    throw TypeError(".osi3.ReferenceLine.polyLine: array expected");
                message.polyLine = [];
                for (let i = 0; i < object.polyLine.length; ++i) {
                    if (typeof object.polyLine[i] !== "object")
                        throw TypeError(".osi3.ReferenceLine.polyLine: object expected");
                    message.polyLine[i] = $root.osi3.ReferenceLine.ReferenceLinePoint.fromObject(object.polyLine[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a ReferenceLine message. Also converts values to other types if specified.
         * @function toObject
         * @memberof osi3.ReferenceLine
         * @static
         * @param {osi3.ReferenceLine} message ReferenceLine
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ReferenceLine.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.polyLine = [];
            if (options.defaults) {
                object.id = null;
                object.type = options.enums === String ? "TYPE_POLYLINE" : 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = $root.osi3.Identifier.toObject(message.id, options);
            if (message.polyLine && message.polyLine.length) {
                object.polyLine = [];
                for (let j = 0; j < message.polyLine.length; ++j)
                    object.polyLine[j] = $root.osi3.ReferenceLine.ReferenceLinePoint.toObject(message.polyLine[j], options);
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.osi3.ReferenceLine.Type[message.type] === undefined ? message.type : $root.osi3.ReferenceLine.Type[message.type] : message.type;
            return object;
        };

        /**
         * Converts this ReferenceLine to JSON.
         * @function toJSON
         * @memberof osi3.ReferenceLine
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ReferenceLine.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ReferenceLine
         * @function getTypeUrl
         * @memberof osi3.ReferenceLine
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ReferenceLine.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/osi3.ReferenceLine";
        };

        /**
         * Type enum.
         * @name osi3.ReferenceLine.Type
         * @enum {number}
         * @property {number} TYPE_POLYLINE=0 TYPE_POLYLINE value
         * @property {number} TYPE_POLYLINE_WITH_T_AXIS=1 TYPE_POLYLINE_WITH_T_AXIS value
         */
        ReferenceLine.Type = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "TYPE_POLYLINE"] = 0;
            values[valuesById[1] = "TYPE_POLYLINE_WITH_T_AXIS"] = 1;
            return values;
        })();

        ReferenceLine.ReferenceLinePoint = (function() {

            /**
             * Properties of a ReferenceLinePoint.
             * @memberof osi3.ReferenceLine
             * @interface IReferenceLinePoint
             * @property {osi3.IVector3d|null} [worldPosition] ReferenceLinePoint worldPosition
             * @property {number|null} [sPosition] ReferenceLinePoint sPosition
             * @property {number|null} [tAxisYaw] ReferenceLinePoint tAxisYaw
             */

            /**
             * Constructs a new ReferenceLinePoint.
             * @memberof osi3.ReferenceLine
             * @classdesc Represents a ReferenceLinePoint.
             * @implements IReferenceLinePoint
             * @constructor
             * @param {osi3.ReferenceLine.IReferenceLinePoint=} [properties] Properties to set
             */
            function ReferenceLinePoint(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReferenceLinePoint worldPosition.
             * @member {osi3.IVector3d|null|undefined} worldPosition
             * @memberof osi3.ReferenceLine.ReferenceLinePoint
             * @instance
             */
            ReferenceLinePoint.prototype.worldPosition = null;

            /**
             * ReferenceLinePoint sPosition.
             * @member {number} sPosition
             * @memberof osi3.ReferenceLine.ReferenceLinePoint
             * @instance
             */
            ReferenceLinePoint.prototype.sPosition = 0;

            /**
             * ReferenceLinePoint tAxisYaw.
             * @member {number} tAxisYaw
             * @memberof osi3.ReferenceLine.ReferenceLinePoint
             * @instance
             */
            ReferenceLinePoint.prototype.tAxisYaw = 0;

            /**
             * Creates a new ReferenceLinePoint instance using the specified properties.
             * @function create
             * @memberof osi3.ReferenceLine.ReferenceLinePoint
             * @static
             * @param {osi3.ReferenceLine.IReferenceLinePoint=} [properties] Properties to set
             * @returns {osi3.ReferenceLine.ReferenceLinePoint} ReferenceLinePoint instance
             */
            ReferenceLinePoint.create = function create(properties) {
                return new ReferenceLinePoint(properties);
            };

            /**
             * Encodes the specified ReferenceLinePoint message. Does not implicitly {@link osi3.ReferenceLine.ReferenceLinePoint.verify|verify} messages.
             * @function encode
             * @memberof osi3.ReferenceLine.ReferenceLinePoint
             * @static
             * @param {osi3.ReferenceLine.IReferenceLinePoint} message ReferenceLinePoint message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReferenceLinePoint.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.worldPosition != null && Object.hasOwnProperty.call(message, "worldPosition"))
                    $root.osi3.Vector3d.encode(message.worldPosition, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.sPosition != null && Object.hasOwnProperty.call(message, "sPosition"))
                    writer.uint32(/* id 2, wireType 1 =*/17).double(message.sPosition);
                if (message.tAxisYaw != null && Object.hasOwnProperty.call(message, "tAxisYaw"))
                    writer.uint32(/* id 3, wireType 1 =*/25).double(message.tAxisYaw);
                return writer;
            };

            /**
             * Encodes the specified ReferenceLinePoint message, length delimited. Does not implicitly {@link osi3.ReferenceLine.ReferenceLinePoint.verify|verify} messages.
             * @function encodeDelimited
             * @memberof osi3.ReferenceLine.ReferenceLinePoint
             * @static
             * @param {osi3.ReferenceLine.IReferenceLinePoint} message ReferenceLinePoint message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReferenceLinePoint.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReferenceLinePoint message from the specified reader or buffer.
             * @function decode
             * @memberof osi3.ReferenceLine.ReferenceLinePoint
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {osi3.ReferenceLine.ReferenceLinePoint} ReferenceLinePoint
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReferenceLinePoint.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.osi3.ReferenceLine.ReferenceLinePoint();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.worldPosition = $root.osi3.Vector3d.decode(reader, reader.uint32());
                            break;
                        }
                    case 2: {
                            message.sPosition = reader.double();
                            break;
                        }
                    case 3: {
                            message.tAxisYaw = reader.double();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReferenceLinePoint message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof osi3.ReferenceLine.ReferenceLinePoint
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {osi3.ReferenceLine.ReferenceLinePoint} ReferenceLinePoint
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReferenceLinePoint.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReferenceLinePoint message.
             * @function verify
             * @memberof osi3.ReferenceLine.ReferenceLinePoint
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReferenceLinePoint.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.worldPosition != null && message.hasOwnProperty("worldPosition")) {
                    let error = $root.osi3.Vector3d.verify(message.worldPosition);
                    if (error)
                        return "worldPosition." + error;
                }
                if (message.sPosition != null && message.hasOwnProperty("sPosition"))
                    if (typeof message.sPosition !== "number")
                        return "sPosition: number expected";
                if (message.tAxisYaw != null && message.hasOwnProperty("tAxisYaw"))
                    if (typeof message.tAxisYaw !== "number")
                        return "tAxisYaw: number expected";
                return null;
            };

            /**
             * Creates a ReferenceLinePoint message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof osi3.ReferenceLine.ReferenceLinePoint
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {osi3.ReferenceLine.ReferenceLinePoint} ReferenceLinePoint
             */
            ReferenceLinePoint.fromObject = function fromObject(object) {
                if (object instanceof $root.osi3.ReferenceLine.ReferenceLinePoint)
                    return object;
                let message = new $root.osi3.ReferenceLine.ReferenceLinePoint();
                if (object.worldPosition != null) {
                    if (typeof object.worldPosition !== "object")
                        throw TypeError(".osi3.ReferenceLine.ReferenceLinePoint.worldPosition: object expected");
                    message.worldPosition = $root.osi3.Vector3d.fromObject(object.worldPosition);
                }
                if (object.sPosition != null)
                    message.sPosition = Number(object.sPosition);
                if (object.tAxisYaw != null)
                    message.tAxisYaw = Number(object.tAxisYaw);
                return message;
            };

            /**
             * Creates a plain object from a ReferenceLinePoint message. Also converts values to other types if specified.
             * @function toObject
             * @memberof osi3.ReferenceLine.ReferenceLinePoint
             * @static
             * @param {osi3.ReferenceLine.ReferenceLinePoint} message ReferenceLinePoint
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReferenceLinePoint.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.worldPosition = null;
                    object.sPosition = 0;
                    object.tAxisYaw = 0;
                }
                if (message.worldPosition != null && message.hasOwnProperty("worldPosition"))
                    object.worldPosition = $root.osi3.Vector3d.toObject(message.worldPosition, options);
                if (message.sPosition != null && message.hasOwnProperty("sPosition"))
                    object.sPosition = options.json && !isFinite(message.sPosition) ? String(message.sPosition) : message.sPosition;
                if (message.tAxisYaw != null && message.hasOwnProperty("tAxisYaw"))
                    object.tAxisYaw = options.json && !isFinite(message.tAxisYaw) ? String(message.tAxisYaw) : message.tAxisYaw;
                return object;
            };

            /**
             * Converts this ReferenceLinePoint to JSON.
             * @function toJSON
             * @memberof osi3.ReferenceLine.ReferenceLinePoint
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReferenceLinePoint.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ReferenceLinePoint
             * @function getTypeUrl
             * @memberof osi3.ReferenceLine.ReferenceLinePoint
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ReferenceLinePoint.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/osi3.ReferenceLine.ReferenceLinePoint";
            };

            return ReferenceLinePoint;
        })();

        return ReferenceLine;
    })();

    osi3.Occupant = (function() {

        /**
         * Properties of an Occupant.
         * @memberof osi3
         * @interface IOccupant
         * @property {osi3.IIdentifier|null} [id] Occupant id
         * @property {osi3.Occupant.IClassification|null} [classification] Occupant classification
         * @property {Array.<osi3.IExternalReference>|null} [sourceReference] Occupant sourceReference
         */

        /**
         * Constructs a new Occupant.
         * @memberof osi3
         * @classdesc Represents an Occupant.
         * @implements IOccupant
         * @constructor
         * @param {osi3.IOccupant=} [properties] Properties to set
         */
        function Occupant(properties) {
            this.sourceReference = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Occupant id.
         * @member {osi3.IIdentifier|null|undefined} id
         * @memberof osi3.Occupant
         * @instance
         */
        Occupant.prototype.id = null;

        /**
         * Occupant classification.
         * @member {osi3.Occupant.IClassification|null|undefined} classification
         * @memberof osi3.Occupant
         * @instance
         */
        Occupant.prototype.classification = null;

        /**
         * Occupant sourceReference.
         * @member {Array.<osi3.IExternalReference>} sourceReference
         * @memberof osi3.Occupant
         * @instance
         */
        Occupant.prototype.sourceReference = $util.emptyArray;

        /**
         * Creates a new Occupant instance using the specified properties.
         * @function create
         * @memberof osi3.Occupant
         * @static
         * @param {osi3.IOccupant=} [properties] Properties to set
         * @returns {osi3.Occupant} Occupant instance
         */
        Occupant.create = function create(properties) {
            return new Occupant(properties);
        };

        /**
         * Encodes the specified Occupant message. Does not implicitly {@link osi3.Occupant.verify|verify} messages.
         * @function encode
         * @memberof osi3.Occupant
         * @static
         * @param {osi3.IOccupant} message Occupant message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Occupant.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                $root.osi3.Identifier.encode(message.id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.classification != null && Object.hasOwnProperty.call(message, "classification"))
                $root.osi3.Occupant.Classification.encode(message.classification, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.sourceReference != null && message.sourceReference.length)
                for (let i = 0; i < message.sourceReference.length; ++i)
                    $root.osi3.ExternalReference.encode(message.sourceReference[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Occupant message, length delimited. Does not implicitly {@link osi3.Occupant.verify|verify} messages.
         * @function encodeDelimited
         * @memberof osi3.Occupant
         * @static
         * @param {osi3.IOccupant} message Occupant message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Occupant.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Occupant message from the specified reader or buffer.
         * @function decode
         * @memberof osi3.Occupant
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {osi3.Occupant} Occupant
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Occupant.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.osi3.Occupant();
            while (reader.pos < end) {
                let tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.id = $root.osi3.Identifier.decode(reader, reader.uint32());
                        break;
                    }
                case 2: {
                        message.classification = $root.osi3.Occupant.Classification.decode(reader, reader.uint32());
                        break;
                    }
                case 3: {
                        if (!(message.sourceReference && message.sourceReference.length))
                            message.sourceReference = [];
                        message.sourceReference.push($root.osi3.ExternalReference.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Occupant message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof osi3.Occupant
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {osi3.Occupant} Occupant
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Occupant.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Occupant message.
         * @function verify
         * @memberof osi3.Occupant
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Occupant.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id")) {
                let error = $root.osi3.Identifier.verify(message.id);
                if (error)
                    return "id." + error;
            }
            if (message.classification != null && message.hasOwnProperty("classification")) {
                let error = $root.osi3.Occupant.Classification.verify(message.classification);
                if (error)
                    return "classification." + error;
            }
            if (message.sourceReference != null && message.hasOwnProperty("sourceReference")) {
                if (!Array.isArray(message.sourceReference))
                    return "sourceReference: array expected";
                for (let i = 0; i < message.sourceReference.length; ++i) {
                    let error = $root.osi3.ExternalReference.verify(message.sourceReference[i]);
                    if (error)
                        return "sourceReference." + error;
                }
            }
            return null;
        };

        /**
         * Creates an Occupant message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof osi3.Occupant
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {osi3.Occupant} Occupant
         */
        Occupant.fromObject = function fromObject(object) {
            if (object instanceof $root.osi3.Occupant)
                return object;
            let message = new $root.osi3.Occupant();
            if (object.id != null) {
                if (typeof object.id !== "object")
                    throw TypeError(".osi3.Occupant.id: object expected");
                message.id = $root.osi3.Identifier.fromObject(object.id);
            }
            if (object.classification != null) {
                if (typeof object.classification !== "object")
                    throw TypeError(".osi3.Occupant.classification: object expected");
                message.classification = $root.osi3.Occupant.Classification.fromObject(object.classification);
            }
            if (object.sourceReference) {
                if (!Array.isArray(object.sourceReference))
                    throw TypeError(".osi3.Occupant.sourceReference: array expected");
                message.sourceReference = [];
                for (let i = 0; i < object.sourceReference.length; ++i) {
                    if (typeof object.sourceReference[i] !== "object")
                        throw TypeError(".osi3.Occupant.sourceReference: object expected");
                    message.sourceReference[i] = $root.osi3.ExternalReference.fromObject(object.sourceReference[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an Occupant message. Also converts values to other types if specified.
         * @function toObject
         * @memberof osi3.Occupant
         * @static
         * @param {osi3.Occupant} message Occupant
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Occupant.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.sourceReference = [];
            if (options.defaults) {
                object.id = null;
                object.classification = null;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = $root.osi3.Identifier.toObject(message.id, options);
            if (message.classification != null && message.hasOwnProperty("classification"))
                object.classification = $root.osi3.Occupant.Classification.toObject(message.classification, options);
            if (message.sourceReference && message.sourceReference.length) {
                object.sourceReference = [];
                for (let j = 0; j < message.sourceReference.length; ++j)
                    object.sourceReference[j] = $root.osi3.ExternalReference.toObject(message.sourceReference[j], options);
            }
            return object;
        };

        /**
         * Converts this Occupant to JSON.
         * @function toJSON
         * @memberof osi3.Occupant
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Occupant.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Occupant
         * @function getTypeUrl
         * @memberof osi3.Occupant
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Occupant.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/osi3.Occupant";
        };

        Occupant.Classification = (function() {

            /**
             * Properties of a Classification.
             * @memberof osi3.Occupant
             * @interface IClassification
             * @property {boolean|null} [isDriver] Classification isDriver
             * @property {osi3.Occupant.Classification.Seat|null} [seat] Classification seat
             * @property {osi3.Occupant.Classification.SteeringControl|null} [steeringControl] Classification steeringControl
             */

            /**
             * Constructs a new Classification.
             * @memberof osi3.Occupant
             * @classdesc Represents a Classification.
             * @implements IClassification
             * @constructor
             * @param {osi3.Occupant.IClassification=} [properties] Properties to set
             */
            function Classification(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Classification isDriver.
             * @member {boolean} isDriver
             * @memberof osi3.Occupant.Classification
             * @instance
             */
            Classification.prototype.isDriver = false;

            /**
             * Classification seat.
             * @member {osi3.Occupant.Classification.Seat} seat
             * @memberof osi3.Occupant.Classification
             * @instance
             */
            Classification.prototype.seat = 0;

            /**
             * Classification steeringControl.
             * @member {osi3.Occupant.Classification.SteeringControl} steeringControl
             * @memberof osi3.Occupant.Classification
             * @instance
             */
            Classification.prototype.steeringControl = 0;

            /**
             * Creates a new Classification instance using the specified properties.
             * @function create
             * @memberof osi3.Occupant.Classification
             * @static
             * @param {osi3.Occupant.IClassification=} [properties] Properties to set
             * @returns {osi3.Occupant.Classification} Classification instance
             */
            Classification.create = function create(properties) {
                return new Classification(properties);
            };

            /**
             * Encodes the specified Classification message. Does not implicitly {@link osi3.Occupant.Classification.verify|verify} messages.
             * @function encode
             * @memberof osi3.Occupant.Classification
             * @static
             * @param {osi3.Occupant.IClassification} message Classification message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Classification.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.isDriver != null && Object.hasOwnProperty.call(message, "isDriver"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.isDriver);
                if (message.seat != null && Object.hasOwnProperty.call(message, "seat"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.seat);
                if (message.steeringControl != null && Object.hasOwnProperty.call(message, "steeringControl"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.steeringControl);
                return writer;
            };

            /**
             * Encodes the specified Classification message, length delimited. Does not implicitly {@link osi3.Occupant.Classification.verify|verify} messages.
             * @function encodeDelimited
             * @memberof osi3.Occupant.Classification
             * @static
             * @param {osi3.Occupant.IClassification} message Classification message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Classification.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Classification message from the specified reader or buffer.
             * @function decode
             * @memberof osi3.Occupant.Classification
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {osi3.Occupant.Classification} Classification
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Classification.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.osi3.Occupant.Classification();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 2: {
                            message.isDriver = reader.bool();
                            break;
                        }
                    case 3: {
                            message.seat = reader.int32();
                            break;
                        }
                    case 4: {
                            message.steeringControl = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Classification message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof osi3.Occupant.Classification
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {osi3.Occupant.Classification} Classification
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Classification.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Classification message.
             * @function verify
             * @memberof osi3.Occupant.Classification
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Classification.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.isDriver != null && message.hasOwnProperty("isDriver"))
                    if (typeof message.isDriver !== "boolean")
                        return "isDriver: boolean expected";
                if (message.seat != null && message.hasOwnProperty("seat"))
                    switch (message.seat) {
                    default:
                        return "seat: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                    case 9:
                    case 10:
                        break;
                    }
                if (message.steeringControl != null && message.hasOwnProperty("steeringControl"))
                    switch (message.steeringControl) {
                    default:
                        return "steeringControl: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                        break;
                    }
                return null;
            };

            /**
             * Creates a Classification message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof osi3.Occupant.Classification
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {osi3.Occupant.Classification} Classification
             */
            Classification.fromObject = function fromObject(object) {
                if (object instanceof $root.osi3.Occupant.Classification)
                    return object;
                let message = new $root.osi3.Occupant.Classification();
                if (object.isDriver != null)
                    message.isDriver = Boolean(object.isDriver);
                switch (object.seat) {
                default:
                    if (typeof object.seat === "number") {
                        message.seat = object.seat;
                        break;
                    }
                    break;
                case "SEAT_UNKNOWN":
                case 0:
                    message.seat = 0;
                    break;
                case "SEAT_OTHER":
                case 1:
                    message.seat = 1;
                    break;
                case "SEAT_FRONT_LEFT":
                case 2:
                    message.seat = 2;
                    break;
                case "SEAT_FRONT_RIGHT":
                case 3:
                    message.seat = 3;
                    break;
                case "SEAT_FRONT_MIDDLE":
                case 4:
                    message.seat = 4;
                    break;
                case "SEAT_BACK_LEFT":
                case 5:
                    message.seat = 5;
                    break;
                case "SEAT_BACK_RIGHT":
                case 6:
                    message.seat = 6;
                    break;
                case "SEAT_BACK_MIDDLE":
                case 7:
                    message.seat = 7;
                    break;
                case "SEAT_THIRD_ROW_LEFT":
                case 8:
                    message.seat = 8;
                    break;
                case "SEAT_THIRD_ROW_RIGHT":
                case 9:
                    message.seat = 9;
                    break;
                case "SEAT_THIRD_ROW_MIDDLE":
                case 10:
                    message.seat = 10;
                    break;
                }
                switch (object.steeringControl) {
                default:
                    if (typeof object.steeringControl === "number") {
                        message.steeringControl = object.steeringControl;
                        break;
                    }
                    break;
                case "STEERING_CONTROL_UNKNOWN":
                case 0:
                    message.steeringControl = 0;
                    break;
                case "STEERING_CONTROL_OTHER":
                case 1:
                    message.steeringControl = 1;
                    break;
                case "STEERING_CONTROL_NO_HAND":
                case 2:
                    message.steeringControl = 2;
                    break;
                case "STEERING_CONTROL_ONE_HAND":
                case 3:
                    message.steeringControl = 3;
                    break;
                case "STEERING_CONTROL_BOTH_HANDS":
                case 4:
                    message.steeringControl = 4;
                    break;
                case "STEERING_CONTROL_LEFT_HAND":
                case 5:
                    message.steeringControl = 5;
                    break;
                case "STEERING_CONTROL_RIGHT_HAND":
                case 6:
                    message.steeringControl = 6;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from a Classification message. Also converts values to other types if specified.
             * @function toObject
             * @memberof osi3.Occupant.Classification
             * @static
             * @param {osi3.Occupant.Classification} message Classification
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Classification.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.isDriver = false;
                    object.seat = options.enums === String ? "SEAT_UNKNOWN" : 0;
                    object.steeringControl = options.enums === String ? "STEERING_CONTROL_UNKNOWN" : 0;
                }
                if (message.isDriver != null && message.hasOwnProperty("isDriver"))
                    object.isDriver = message.isDriver;
                if (message.seat != null && message.hasOwnProperty("seat"))
                    object.seat = options.enums === String ? $root.osi3.Occupant.Classification.Seat[message.seat] === undefined ? message.seat : $root.osi3.Occupant.Classification.Seat[message.seat] : message.seat;
                if (message.steeringControl != null && message.hasOwnProperty("steeringControl"))
                    object.steeringControl = options.enums === String ? $root.osi3.Occupant.Classification.SteeringControl[message.steeringControl] === undefined ? message.steeringControl : $root.osi3.Occupant.Classification.SteeringControl[message.steeringControl] : message.steeringControl;
                return object;
            };

            /**
             * Converts this Classification to JSON.
             * @function toJSON
             * @memberof osi3.Occupant.Classification
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Classification.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Classification
             * @function getTypeUrl
             * @memberof osi3.Occupant.Classification
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Classification.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/osi3.Occupant.Classification";
            };

            /**
             * Seat enum.
             * @name osi3.Occupant.Classification.Seat
             * @enum {number}
             * @property {number} SEAT_UNKNOWN=0 SEAT_UNKNOWN value
             * @property {number} SEAT_OTHER=1 SEAT_OTHER value
             * @property {number} SEAT_FRONT_LEFT=2 SEAT_FRONT_LEFT value
             * @property {number} SEAT_FRONT_RIGHT=3 SEAT_FRONT_RIGHT value
             * @property {number} SEAT_FRONT_MIDDLE=4 SEAT_FRONT_MIDDLE value
             * @property {number} SEAT_BACK_LEFT=5 SEAT_BACK_LEFT value
             * @property {number} SEAT_BACK_RIGHT=6 SEAT_BACK_RIGHT value
             * @property {number} SEAT_BACK_MIDDLE=7 SEAT_BACK_MIDDLE value
             * @property {number} SEAT_THIRD_ROW_LEFT=8 SEAT_THIRD_ROW_LEFT value
             * @property {number} SEAT_THIRD_ROW_RIGHT=9 SEAT_THIRD_ROW_RIGHT value
             * @property {number} SEAT_THIRD_ROW_MIDDLE=10 SEAT_THIRD_ROW_MIDDLE value
             */
            Classification.Seat = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "SEAT_UNKNOWN"] = 0;
                values[valuesById[1] = "SEAT_OTHER"] = 1;
                values[valuesById[2] = "SEAT_FRONT_LEFT"] = 2;
                values[valuesById[3] = "SEAT_FRONT_RIGHT"] = 3;
                values[valuesById[4] = "SEAT_FRONT_MIDDLE"] = 4;
                values[valuesById[5] = "SEAT_BACK_LEFT"] = 5;
                values[valuesById[6] = "SEAT_BACK_RIGHT"] = 6;
                values[valuesById[7] = "SEAT_BACK_MIDDLE"] = 7;
                values[valuesById[8] = "SEAT_THIRD_ROW_LEFT"] = 8;
                values[valuesById[9] = "SEAT_THIRD_ROW_RIGHT"] = 9;
                values[valuesById[10] = "SEAT_THIRD_ROW_MIDDLE"] = 10;
                return values;
            })();

            /**
             * SteeringControl enum.
             * @name osi3.Occupant.Classification.SteeringControl
             * @enum {number}
             * @property {number} STEERING_CONTROL_UNKNOWN=0 STEERING_CONTROL_UNKNOWN value
             * @property {number} STEERING_CONTROL_OTHER=1 STEERING_CONTROL_OTHER value
             * @property {number} STEERING_CONTROL_NO_HAND=2 STEERING_CONTROL_NO_HAND value
             * @property {number} STEERING_CONTROL_ONE_HAND=3 STEERING_CONTROL_ONE_HAND value
             * @property {number} STEERING_CONTROL_BOTH_HANDS=4 STEERING_CONTROL_BOTH_HANDS value
             * @property {number} STEERING_CONTROL_LEFT_HAND=5 STEERING_CONTROL_LEFT_HAND value
             * @property {number} STEERING_CONTROL_RIGHT_HAND=6 STEERING_CONTROL_RIGHT_HAND value
             */
            Classification.SteeringControl = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "STEERING_CONTROL_UNKNOWN"] = 0;
                values[valuesById[1] = "STEERING_CONTROL_OTHER"] = 1;
                values[valuesById[2] = "STEERING_CONTROL_NO_HAND"] = 2;
                values[valuesById[3] = "STEERING_CONTROL_ONE_HAND"] = 3;
                values[valuesById[4] = "STEERING_CONTROL_BOTH_HANDS"] = 4;
                values[valuesById[5] = "STEERING_CONTROL_LEFT_HAND"] = 5;
                values[valuesById[6] = "STEERING_CONTROL_RIGHT_HAND"] = 6;
                return values;
            })();

            return Classification;
        })();

        return Occupant;
    })();

    return osi3;
})();

export const google = $root.google = (() => {

    /**
     * Namespace google.
     * @exports google
     * @namespace
     */
    const google = {};

    google.protobuf = (function() {

        /**
         * Namespace protobuf.
         * @memberof google
         * @namespace
         */
        const protobuf = {};

        protobuf.FileDescriptorSet = (function() {

            /**
             * Properties of a FileDescriptorSet.
             * @memberof google.protobuf
             * @interface IFileDescriptorSet
             * @property {Array.<google.protobuf.IFileDescriptorProto>|null} [file] FileDescriptorSet file
             */

            /**
             * Constructs a new FileDescriptorSet.
             * @memberof google.protobuf
             * @classdesc Represents a FileDescriptorSet.
             * @implements IFileDescriptorSet
             * @constructor
             * @param {google.protobuf.IFileDescriptorSet=} [properties] Properties to set
             */
            function FileDescriptorSet(properties) {
                this.file = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FileDescriptorSet file.
             * @member {Array.<google.protobuf.IFileDescriptorProto>} file
             * @memberof google.protobuf.FileDescriptorSet
             * @instance
             */
            FileDescriptorSet.prototype.file = $util.emptyArray;

            /**
             * Creates a new FileDescriptorSet instance using the specified properties.
             * @function create
             * @memberof google.protobuf.FileDescriptorSet
             * @static
             * @param {google.protobuf.IFileDescriptorSet=} [properties] Properties to set
             * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet instance
             */
            FileDescriptorSet.create = function create(properties) {
                return new FileDescriptorSet(properties);
            };

            /**
             * Encodes the specified FileDescriptorSet message. Does not implicitly {@link google.protobuf.FileDescriptorSet.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.FileDescriptorSet
             * @static
             * @param {google.protobuf.IFileDescriptorSet} message FileDescriptorSet message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FileDescriptorSet.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.file != null && message.file.length)
                    for (let i = 0; i < message.file.length; ++i)
                        $root.google.protobuf.FileDescriptorProto.encode(message.file[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified FileDescriptorSet message, length delimited. Does not implicitly {@link google.protobuf.FileDescriptorSet.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.FileDescriptorSet
             * @static
             * @param {google.protobuf.IFileDescriptorSet} message FileDescriptorSet message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FileDescriptorSet.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FileDescriptorSet message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.FileDescriptorSet
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FileDescriptorSet.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FileDescriptorSet();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.file && message.file.length))
                                message.file = [];
                            message.file.push($root.google.protobuf.FileDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FileDescriptorSet message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.FileDescriptorSet
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FileDescriptorSet.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FileDescriptorSet message.
             * @function verify
             * @memberof google.protobuf.FileDescriptorSet
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FileDescriptorSet.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.file != null && message.hasOwnProperty("file")) {
                    if (!Array.isArray(message.file))
                        return "file: array expected";
                    for (let i = 0; i < message.file.length; ++i) {
                        let error = $root.google.protobuf.FileDescriptorProto.verify(message.file[i]);
                        if (error)
                            return "file." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a FileDescriptorSet message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.FileDescriptorSet
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet
             */
            FileDescriptorSet.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.FileDescriptorSet)
                    return object;
                let message = new $root.google.protobuf.FileDescriptorSet();
                if (object.file) {
                    if (!Array.isArray(object.file))
                        throw TypeError(".google.protobuf.FileDescriptorSet.file: array expected");
                    message.file = [];
                    for (let i = 0; i < object.file.length; ++i) {
                        if (typeof object.file[i] !== "object")
                            throw TypeError(".google.protobuf.FileDescriptorSet.file: object expected");
                        message.file[i] = $root.google.protobuf.FileDescriptorProto.fromObject(object.file[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a FileDescriptorSet message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.FileDescriptorSet
             * @static
             * @param {google.protobuf.FileDescriptorSet} message FileDescriptorSet
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FileDescriptorSet.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.file = [];
                if (message.file && message.file.length) {
                    object.file = [];
                    for (let j = 0; j < message.file.length; ++j)
                        object.file[j] = $root.google.protobuf.FileDescriptorProto.toObject(message.file[j], options);
                }
                return object;
            };

            /**
             * Converts this FileDescriptorSet to JSON.
             * @function toJSON
             * @memberof google.protobuf.FileDescriptorSet
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FileDescriptorSet.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for FileDescriptorSet
             * @function getTypeUrl
             * @memberof google.protobuf.FileDescriptorSet
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            FileDescriptorSet.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/google.protobuf.FileDescriptorSet";
            };

            return FileDescriptorSet;
        })();

        /**
         * Edition enum.
         * @name google.protobuf.Edition
         * @enum {number}
         * @property {number} EDITION_UNKNOWN=0 EDITION_UNKNOWN value
         * @property {number} EDITION_LEGACY=900 EDITION_LEGACY value
         * @property {number} EDITION_PROTO2=998 EDITION_PROTO2 value
         * @property {number} EDITION_PROTO3=999 EDITION_PROTO3 value
         * @property {number} EDITION_2023=1000 EDITION_2023 value
         * @property {number} EDITION_2024=1001 EDITION_2024 value
         * @property {number} EDITION_1_TEST_ONLY=1 EDITION_1_TEST_ONLY value
         * @property {number} EDITION_2_TEST_ONLY=2 EDITION_2_TEST_ONLY value
         * @property {number} EDITION_99997_TEST_ONLY=99997 EDITION_99997_TEST_ONLY value
         * @property {number} EDITION_99998_TEST_ONLY=99998 EDITION_99998_TEST_ONLY value
         * @property {number} EDITION_99999_TEST_ONLY=99999 EDITION_99999_TEST_ONLY value
         * @property {number} EDITION_MAX=2147483647 EDITION_MAX value
         */
        protobuf.Edition = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "EDITION_UNKNOWN"] = 0;
            values[valuesById[900] = "EDITION_LEGACY"] = 900;
            values[valuesById[998] = "EDITION_PROTO2"] = 998;
            values[valuesById[999] = "EDITION_PROTO3"] = 999;
            values[valuesById[1000] = "EDITION_2023"] = 1000;
            values[valuesById[1001] = "EDITION_2024"] = 1001;
            values[valuesById[1] = "EDITION_1_TEST_ONLY"] = 1;
            values[valuesById[2] = "EDITION_2_TEST_ONLY"] = 2;
            values[valuesById[99997] = "EDITION_99997_TEST_ONLY"] = 99997;
            values[valuesById[99998] = "EDITION_99998_TEST_ONLY"] = 99998;
            values[valuesById[99999] = "EDITION_99999_TEST_ONLY"] = 99999;
            values[valuesById[2147483647] = "EDITION_MAX"] = 2147483647;
            return values;
        })();

        protobuf.FileDescriptorProto = (function() {

            /**
             * Properties of a FileDescriptorProto.
             * @memberof google.protobuf
             * @interface IFileDescriptorProto
             * @property {string|null} [name] FileDescriptorProto name
             * @property {string|null} ["package"] FileDescriptorProto package
             * @property {Array.<string>|null} [dependency] FileDescriptorProto dependency
             * @property {Array.<number>|null} [publicDependency] FileDescriptorProto publicDependency
             * @property {Array.<number>|null} [weakDependency] FileDescriptorProto weakDependency
             * @property {Array.<string>|null} [optionDependency] FileDescriptorProto optionDependency
             * @property {Array.<google.protobuf.IDescriptorProto>|null} [messageType] FileDescriptorProto messageType
             * @property {Array.<google.protobuf.IEnumDescriptorProto>|null} [enumType] FileDescriptorProto enumType
             * @property {Array.<google.protobuf.IServiceDescriptorProto>|null} [service] FileDescriptorProto service
             * @property {Array.<google.protobuf.IFieldDescriptorProto>|null} [extension] FileDescriptorProto extension
             * @property {google.protobuf.IFileOptions|null} [options] FileDescriptorProto options
             * @property {google.protobuf.ISourceCodeInfo|null} [sourceCodeInfo] FileDescriptorProto sourceCodeInfo
             * @property {string|null} [syntax] FileDescriptorProto syntax
             * @property {google.protobuf.Edition|null} [edition] FileDescriptorProto edition
             */

            /**
             * Constructs a new FileDescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents a FileDescriptorProto.
             * @implements IFileDescriptorProto
             * @constructor
             * @param {google.protobuf.IFileDescriptorProto=} [properties] Properties to set
             */
            function FileDescriptorProto(properties) {
                this.dependency = [];
                this.publicDependency = [];
                this.weakDependency = [];
                this.optionDependency = [];
                this.messageType = [];
                this.enumType = [];
                this.service = [];
                this.extension = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FileDescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.name = "";

            /**
             * FileDescriptorProto package.
             * @member {string} package
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype["package"] = "";

            /**
             * FileDescriptorProto dependency.
             * @member {Array.<string>} dependency
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.dependency = $util.emptyArray;

            /**
             * FileDescriptorProto publicDependency.
             * @member {Array.<number>} publicDependency
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.publicDependency = $util.emptyArray;

            /**
             * FileDescriptorProto weakDependency.
             * @member {Array.<number>} weakDependency
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.weakDependency = $util.emptyArray;

            /**
             * FileDescriptorProto optionDependency.
             * @member {Array.<string>} optionDependency
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.optionDependency = $util.emptyArray;

            /**
             * FileDescriptorProto messageType.
             * @member {Array.<google.protobuf.IDescriptorProto>} messageType
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.messageType = $util.emptyArray;

            /**
             * FileDescriptorProto enumType.
             * @member {Array.<google.protobuf.IEnumDescriptorProto>} enumType
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.enumType = $util.emptyArray;

            /**
             * FileDescriptorProto service.
             * @member {Array.<google.protobuf.IServiceDescriptorProto>} service
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.service = $util.emptyArray;

            /**
             * FileDescriptorProto extension.
             * @member {Array.<google.protobuf.IFieldDescriptorProto>} extension
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.extension = $util.emptyArray;

            /**
             * FileDescriptorProto options.
             * @member {google.protobuf.IFileOptions|null|undefined} options
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.options = null;

            /**
             * FileDescriptorProto sourceCodeInfo.
             * @member {google.protobuf.ISourceCodeInfo|null|undefined} sourceCodeInfo
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.sourceCodeInfo = null;

            /**
             * FileDescriptorProto syntax.
             * @member {string} syntax
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.syntax = "";

            /**
             * FileDescriptorProto edition.
             * @member {google.protobuf.Edition} edition
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.edition = 0;

            /**
             * Creates a new FileDescriptorProto instance using the specified properties.
             * @function create
             * @memberof google.protobuf.FileDescriptorProto
             * @static
             * @param {google.protobuf.IFileDescriptorProto=} [properties] Properties to set
             * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto instance
             */
            FileDescriptorProto.create = function create(properties) {
                return new FileDescriptorProto(properties);
            };

            /**
             * Encodes the specified FileDescriptorProto message. Does not implicitly {@link google.protobuf.FileDescriptorProto.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.FileDescriptorProto
             * @static
             * @param {google.protobuf.IFileDescriptorProto} message FileDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FileDescriptorProto.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message["package"] != null && Object.hasOwnProperty.call(message, "package"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message["package"]);
                if (message.dependency != null && message.dependency.length)
                    for (let i = 0; i < message.dependency.length; ++i)
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.dependency[i]);
                if (message.messageType != null && message.messageType.length)
                    for (let i = 0; i < message.messageType.length; ++i)
                        $root.google.protobuf.DescriptorProto.encode(message.messageType[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.enumType != null && message.enumType.length)
                    for (let i = 0; i < message.enumType.length; ++i)
                        $root.google.protobuf.EnumDescriptorProto.encode(message.enumType[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.service != null && message.service.length)
                    for (let i = 0; i < message.service.length; ++i)
                        $root.google.protobuf.ServiceDescriptorProto.encode(message.service[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.extension != null && message.extension.length)
                    for (let i = 0; i < message.extension.length; ++i)
                        $root.google.protobuf.FieldDescriptorProto.encode(message.extension[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                    $root.google.protobuf.FileOptions.encode(message.options, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.sourceCodeInfo != null && Object.hasOwnProperty.call(message, "sourceCodeInfo"))
                    $root.google.protobuf.SourceCodeInfo.encode(message.sourceCodeInfo, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                if (message.publicDependency != null && message.publicDependency.length)
                    for (let i = 0; i < message.publicDependency.length; ++i)
                        writer.uint32(/* id 10, wireType 0 =*/80).int32(message.publicDependency[i]);
                if (message.weakDependency != null && message.weakDependency.length)
                    for (let i = 0; i < message.weakDependency.length; ++i)
                        writer.uint32(/* id 11, wireType 0 =*/88).int32(message.weakDependency[i]);
                if (message.syntax != null && Object.hasOwnProperty.call(message, "syntax"))
                    writer.uint32(/* id 12, wireType 2 =*/98).string(message.syntax);
                if (message.edition != null && Object.hasOwnProperty.call(message, "edition"))
                    writer.uint32(/* id 14, wireType 0 =*/112).int32(message.edition);
                if (message.optionDependency != null && message.optionDependency.length)
                    for (let i = 0; i < message.optionDependency.length; ++i)
                        writer.uint32(/* id 15, wireType 2 =*/122).string(message.optionDependency[i]);
                return writer;
            };

            /**
             * Encodes the specified FileDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.FileDescriptorProto.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.FileDescriptorProto
             * @static
             * @param {google.protobuf.IFileDescriptorProto} message FileDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FileDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FileDescriptorProto message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.FileDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FileDescriptorProto.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FileDescriptorProto();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.name = reader.string();
                            break;
                        }
                    case 2: {
                            message["package"] = reader.string();
                            break;
                        }
                    case 3: {
                            if (!(message.dependency && message.dependency.length))
                                message.dependency = [];
                            message.dependency.push(reader.string());
                            break;
                        }
                    case 10: {
                            if (!(message.publicDependency && message.publicDependency.length))
                                message.publicDependency = [];
                            if ((tag & 7) === 2) {
                                let end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.publicDependency.push(reader.int32());
                            } else
                                message.publicDependency.push(reader.int32());
                            break;
                        }
                    case 11: {
                            if (!(message.weakDependency && message.weakDependency.length))
                                message.weakDependency = [];
                            if ((tag & 7) === 2) {
                                let end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.weakDependency.push(reader.int32());
                            } else
                                message.weakDependency.push(reader.int32());
                            break;
                        }
                    case 15: {
                            if (!(message.optionDependency && message.optionDependency.length))
                                message.optionDependency = [];
                            message.optionDependency.push(reader.string());
                            break;
                        }
                    case 4: {
                            if (!(message.messageType && message.messageType.length))
                                message.messageType = [];
                            message.messageType.push($root.google.protobuf.DescriptorProto.decode(reader, reader.uint32()));
                            break;
                        }
                    case 5: {
                            if (!(message.enumType && message.enumType.length))
                                message.enumType = [];
                            message.enumType.push($root.google.protobuf.EnumDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        }
                    case 6: {
                            if (!(message.service && message.service.length))
                                message.service = [];
                            message.service.push($root.google.protobuf.ServiceDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        }
                    case 7: {
                            if (!(message.extension && message.extension.length))
                                message.extension = [];
                            message.extension.push($root.google.protobuf.FieldDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        }
                    case 8: {
                            message.options = $root.google.protobuf.FileOptions.decode(reader, reader.uint32());
                            break;
                        }
                    case 9: {
                            message.sourceCodeInfo = $root.google.protobuf.SourceCodeInfo.decode(reader, reader.uint32());
                            break;
                        }
                    case 12: {
                            message.syntax = reader.string();
                            break;
                        }
                    case 14: {
                            message.edition = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FileDescriptorProto message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.FileDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FileDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FileDescriptorProto message.
             * @function verify
             * @memberof google.protobuf.FileDescriptorProto
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FileDescriptorProto.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message["package"] != null && message.hasOwnProperty("package"))
                    if (!$util.isString(message["package"]))
                        return "package: string expected";
                if (message.dependency != null && message.hasOwnProperty("dependency")) {
                    if (!Array.isArray(message.dependency))
                        return "dependency: array expected";
                    for (let i = 0; i < message.dependency.length; ++i)
                        if (!$util.isString(message.dependency[i]))
                            return "dependency: string[] expected";
                }
                if (message.publicDependency != null && message.hasOwnProperty("publicDependency")) {
                    if (!Array.isArray(message.publicDependency))
                        return "publicDependency: array expected";
                    for (let i = 0; i < message.publicDependency.length; ++i)
                        if (!$util.isInteger(message.publicDependency[i]))
                            return "publicDependency: integer[] expected";
                }
                if (message.weakDependency != null && message.hasOwnProperty("weakDependency")) {
                    if (!Array.isArray(message.weakDependency))
                        return "weakDependency: array expected";
                    for (let i = 0; i < message.weakDependency.length; ++i)
                        if (!$util.isInteger(message.weakDependency[i]))
                            return "weakDependency: integer[] expected";
                }
                if (message.optionDependency != null && message.hasOwnProperty("optionDependency")) {
                    if (!Array.isArray(message.optionDependency))
                        return "optionDependency: array expected";
                    for (let i = 0; i < message.optionDependency.length; ++i)
                        if (!$util.isString(message.optionDependency[i]))
                            return "optionDependency: string[] expected";
                }
                if (message.messageType != null && message.hasOwnProperty("messageType")) {
                    if (!Array.isArray(message.messageType))
                        return "messageType: array expected";
                    for (let i = 0; i < message.messageType.length; ++i) {
                        let error = $root.google.protobuf.DescriptorProto.verify(message.messageType[i]);
                        if (error)
                            return "messageType." + error;
                    }
                }
                if (message.enumType != null && message.hasOwnProperty("enumType")) {
                    if (!Array.isArray(message.enumType))
                        return "enumType: array expected";
                    for (let i = 0; i < message.enumType.length; ++i) {
                        let error = $root.google.protobuf.EnumDescriptorProto.verify(message.enumType[i]);
                        if (error)
                            return "enumType." + error;
                    }
                }
                if (message.service != null && message.hasOwnProperty("service")) {
                    if (!Array.isArray(message.service))
                        return "service: array expected";
                    for (let i = 0; i < message.service.length; ++i) {
                        let error = $root.google.protobuf.ServiceDescriptorProto.verify(message.service[i]);
                        if (error)
                            return "service." + error;
                    }
                }
                if (message.extension != null && message.hasOwnProperty("extension")) {
                    if (!Array.isArray(message.extension))
                        return "extension: array expected";
                    for (let i = 0; i < message.extension.length; ++i) {
                        let error = $root.google.protobuf.FieldDescriptorProto.verify(message.extension[i]);
                        if (error)
                            return "extension." + error;
                    }
                }
                if (message.options != null && message.hasOwnProperty("options")) {
                    let error = $root.google.protobuf.FileOptions.verify(message.options);
                    if (error)
                        return "options." + error;
                }
                if (message.sourceCodeInfo != null && message.hasOwnProperty("sourceCodeInfo")) {
                    let error = $root.google.protobuf.SourceCodeInfo.verify(message.sourceCodeInfo);
                    if (error)
                        return "sourceCodeInfo." + error;
                }
                if (message.syntax != null && message.hasOwnProperty("syntax"))
                    if (!$util.isString(message.syntax))
                        return "syntax: string expected";
                if (message.edition != null && message.hasOwnProperty("edition"))
                    switch (message.edition) {
                    default:
                        return "edition: enum value expected";
                    case 0:
                    case 900:
                    case 998:
                    case 999:
                    case 1000:
                    case 1001:
                    case 1:
                    case 2:
                    case 99997:
                    case 99998:
                    case 99999:
                    case 2147483647:
                        break;
                    }
                return null;
            };

            /**
             * Creates a FileDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.FileDescriptorProto
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto
             */
            FileDescriptorProto.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.FileDescriptorProto)
                    return object;
                let message = new $root.google.protobuf.FileDescriptorProto();
                if (object.name != null)
                    message.name = String(object.name);
                if (object["package"] != null)
                    message["package"] = String(object["package"]);
                if (object.dependency) {
                    if (!Array.isArray(object.dependency))
                        throw TypeError(".google.protobuf.FileDescriptorProto.dependency: array expected");
                    message.dependency = [];
                    for (let i = 0; i < object.dependency.length; ++i)
                        message.dependency[i] = String(object.dependency[i]);
                }
                if (object.publicDependency) {
                    if (!Array.isArray(object.publicDependency))
                        throw TypeError(".google.protobuf.FileDescriptorProto.publicDependency: array expected");
                    message.publicDependency = [];
                    for (let i = 0; i < object.publicDependency.length; ++i)
                        message.publicDependency[i] = object.publicDependency[i] | 0;
                }
                if (object.weakDependency) {
                    if (!Array.isArray(object.weakDependency))
                        throw TypeError(".google.protobuf.FileDescriptorProto.weakDependency: array expected");
                    message.weakDependency = [];
                    for (let i = 0; i < object.weakDependency.length; ++i)
                        message.weakDependency[i] = object.weakDependency[i] | 0;
                }
                if (object.optionDependency) {
                    if (!Array.isArray(object.optionDependency))
                        throw TypeError(".google.protobuf.FileDescriptorProto.optionDependency: array expected");
                    message.optionDependency = [];
                    for (let i = 0; i < object.optionDependency.length; ++i)
                        message.optionDependency[i] = String(object.optionDependency[i]);
                }
                if (object.messageType) {
                    if (!Array.isArray(object.messageType))
                        throw TypeError(".google.protobuf.FileDescriptorProto.messageType: array expected");
                    message.messageType = [];
                    for (let i = 0; i < object.messageType.length; ++i) {
                        if (typeof object.messageType[i] !== "object")
                            throw TypeError(".google.protobuf.FileDescriptorProto.messageType: object expected");
                        message.messageType[i] = $root.google.protobuf.DescriptorProto.fromObject(object.messageType[i]);
                    }
                }
                if (object.enumType) {
                    if (!Array.isArray(object.enumType))
                        throw TypeError(".google.protobuf.FileDescriptorProto.enumType: array expected");
                    message.enumType = [];
                    for (let i = 0; i < object.enumType.length; ++i) {
                        if (typeof object.enumType[i] !== "object")
                            throw TypeError(".google.protobuf.FileDescriptorProto.enumType: object expected");
                        message.enumType[i] = $root.google.protobuf.EnumDescriptorProto.fromObject(object.enumType[i]);
                    }
                }
                if (object.service) {
                    if (!Array.isArray(object.service))
                        throw TypeError(".google.protobuf.FileDescriptorProto.service: array expected");
                    message.service = [];
                    for (let i = 0; i < object.service.length; ++i) {
                        if (typeof object.service[i] !== "object")
                            throw TypeError(".google.protobuf.FileDescriptorProto.service: object expected");
                        message.service[i] = $root.google.protobuf.ServiceDescriptorProto.fromObject(object.service[i]);
                    }
                }
                if (object.extension) {
                    if (!Array.isArray(object.extension))
                        throw TypeError(".google.protobuf.FileDescriptorProto.extension: array expected");
                    message.extension = [];
                    for (let i = 0; i < object.extension.length; ++i) {
                        if (typeof object.extension[i] !== "object")
                            throw TypeError(".google.protobuf.FileDescriptorProto.extension: object expected");
                        message.extension[i] = $root.google.protobuf.FieldDescriptorProto.fromObject(object.extension[i]);
                    }
                }
                if (object.options != null) {
                    if (typeof object.options !== "object")
                        throw TypeError(".google.protobuf.FileDescriptorProto.options: object expected");
                    message.options = $root.google.protobuf.FileOptions.fromObject(object.options);
                }
                if (object.sourceCodeInfo != null) {
                    if (typeof object.sourceCodeInfo !== "object")
                        throw TypeError(".google.protobuf.FileDescriptorProto.sourceCodeInfo: object expected");
                    message.sourceCodeInfo = $root.google.protobuf.SourceCodeInfo.fromObject(object.sourceCodeInfo);
                }
                if (object.syntax != null)
                    message.syntax = String(object.syntax);
                switch (object.edition) {
                default:
                    if (typeof object.edition === "number") {
                        message.edition = object.edition;
                        break;
                    }
                    break;
                case "EDITION_UNKNOWN":
                case 0:
                    message.edition = 0;
                    break;
                case "EDITION_LEGACY":
                case 900:
                    message.edition = 900;
                    break;
                case "EDITION_PROTO2":
                case 998:
                    message.edition = 998;
                    break;
                case "EDITION_PROTO3":
                case 999:
                    message.edition = 999;
                    break;
                case "EDITION_2023":
                case 1000:
                    message.edition = 1000;
                    break;
                case "EDITION_2024":
                case 1001:
                    message.edition = 1001;
                    break;
                case "EDITION_1_TEST_ONLY":
                case 1:
                    message.edition = 1;
                    break;
                case "EDITION_2_TEST_ONLY":
                case 2:
                    message.edition = 2;
                    break;
                case "EDITION_99997_TEST_ONLY":
                case 99997:
                    message.edition = 99997;
                    break;
                case "EDITION_99998_TEST_ONLY":
                case 99998:
                    message.edition = 99998;
                    break;
                case "EDITION_99999_TEST_ONLY":
                case 99999:
                    message.edition = 99999;
                    break;
                case "EDITION_MAX":
                case 2147483647:
                    message.edition = 2147483647;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from a FileDescriptorProto message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.FileDescriptorProto
             * @static
             * @param {google.protobuf.FileDescriptorProto} message FileDescriptorProto
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FileDescriptorProto.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults) {
                    object.dependency = [];
                    object.messageType = [];
                    object.enumType = [];
                    object.service = [];
                    object.extension = [];
                    object.publicDependency = [];
                    object.weakDependency = [];
                    object.optionDependency = [];
                }
                if (options.defaults) {
                    object.name = "";
                    object["package"] = "";
                    object.options = null;
                    object.sourceCodeInfo = null;
                    object.syntax = "";
                    object.edition = options.enums === String ? "EDITION_UNKNOWN" : 0;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message["package"] != null && message.hasOwnProperty("package"))
                    object["package"] = message["package"];
                if (message.dependency && message.dependency.length) {
                    object.dependency = [];
                    for (let j = 0; j < message.dependency.length; ++j)
                        object.dependency[j] = message.dependency[j];
                }
                if (message.messageType && message.messageType.length) {
                    object.messageType = [];
                    for (let j = 0; j < message.messageType.length; ++j)
                        object.messageType[j] = $root.google.protobuf.DescriptorProto.toObject(message.messageType[j], options);
                }
                if (message.enumType && message.enumType.length) {
                    object.enumType = [];
                    for (let j = 0; j < message.enumType.length; ++j)
                        object.enumType[j] = $root.google.protobuf.EnumDescriptorProto.toObject(message.enumType[j], options);
                }
                if (message.service && message.service.length) {
                    object.service = [];
                    for (let j = 0; j < message.service.length; ++j)
                        object.service[j] = $root.google.protobuf.ServiceDescriptorProto.toObject(message.service[j], options);
                }
                if (message.extension && message.extension.length) {
                    object.extension = [];
                    for (let j = 0; j < message.extension.length; ++j)
                        object.extension[j] = $root.google.protobuf.FieldDescriptorProto.toObject(message.extension[j], options);
                }
                if (message.options != null && message.hasOwnProperty("options"))
                    object.options = $root.google.protobuf.FileOptions.toObject(message.options, options);
                if (message.sourceCodeInfo != null && message.hasOwnProperty("sourceCodeInfo"))
                    object.sourceCodeInfo = $root.google.protobuf.SourceCodeInfo.toObject(message.sourceCodeInfo, options);
                if (message.publicDependency && message.publicDependency.length) {
                    object.publicDependency = [];
                    for (let j = 0; j < message.publicDependency.length; ++j)
                        object.publicDependency[j] = message.publicDependency[j];
                }
                if (message.weakDependency && message.weakDependency.length) {
                    object.weakDependency = [];
                    for (let j = 0; j < message.weakDependency.length; ++j)
                        object.weakDependency[j] = message.weakDependency[j];
                }
                if (message.syntax != null && message.hasOwnProperty("syntax"))
                    object.syntax = message.syntax;
                if (message.edition != null && message.hasOwnProperty("edition"))
                    object.edition = options.enums === String ? $root.google.protobuf.Edition[message.edition] === undefined ? message.edition : $root.google.protobuf.Edition[message.edition] : message.edition;
                if (message.optionDependency && message.optionDependency.length) {
                    object.optionDependency = [];
                    for (let j = 0; j < message.optionDependency.length; ++j)
                        object.optionDependency[j] = message.optionDependency[j];
                }
                return object;
            };

            /**
             * Converts this FileDescriptorProto to JSON.
             * @function toJSON
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FileDescriptorProto.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for FileDescriptorProto
             * @function getTypeUrl
             * @memberof google.protobuf.FileDescriptorProto
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            FileDescriptorProto.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/google.protobuf.FileDescriptorProto";
            };

            return FileDescriptorProto;
        })();

        protobuf.DescriptorProto = (function() {

            /**
             * Properties of a DescriptorProto.
             * @memberof google.protobuf
             * @interface IDescriptorProto
             * @property {string|null} [name] DescriptorProto name
             * @property {Array.<google.protobuf.IFieldDescriptorProto>|null} [field] DescriptorProto field
             * @property {Array.<google.protobuf.IFieldDescriptorProto>|null} [extension] DescriptorProto extension
             * @property {Array.<google.protobuf.IDescriptorProto>|null} [nestedType] DescriptorProto nestedType
             * @property {Array.<google.protobuf.IEnumDescriptorProto>|null} [enumType] DescriptorProto enumType
             * @property {Array.<google.protobuf.DescriptorProto.IExtensionRange>|null} [extensionRange] DescriptorProto extensionRange
             * @property {Array.<google.protobuf.IOneofDescriptorProto>|null} [oneofDecl] DescriptorProto oneofDecl
             * @property {google.protobuf.IMessageOptions|null} [options] DescriptorProto options
             * @property {Array.<google.protobuf.DescriptorProto.IReservedRange>|null} [reservedRange] DescriptorProto reservedRange
             * @property {Array.<string>|null} [reservedName] DescriptorProto reservedName
             * @property {google.protobuf.SymbolVisibility|null} [visibility] DescriptorProto visibility
             */

            /**
             * Constructs a new DescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents a DescriptorProto.
             * @implements IDescriptorProto
             * @constructor
             * @param {google.protobuf.IDescriptorProto=} [properties] Properties to set
             */
            function DescriptorProto(properties) {
                this.field = [];
                this.extension = [];
                this.nestedType = [];
                this.enumType = [];
                this.extensionRange = [];
                this.oneofDecl = [];
                this.reservedRange = [];
                this.reservedName = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.name = "";

            /**
             * DescriptorProto field.
             * @member {Array.<google.protobuf.IFieldDescriptorProto>} field
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.field = $util.emptyArray;

            /**
             * DescriptorProto extension.
             * @member {Array.<google.protobuf.IFieldDescriptorProto>} extension
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.extension = $util.emptyArray;

            /**
             * DescriptorProto nestedType.
             * @member {Array.<google.protobuf.IDescriptorProto>} nestedType
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.nestedType = $util.emptyArray;

            /**
             * DescriptorProto enumType.
             * @member {Array.<google.protobuf.IEnumDescriptorProto>} enumType
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.enumType = $util.emptyArray;

            /**
             * DescriptorProto extensionRange.
             * @member {Array.<google.protobuf.DescriptorProto.IExtensionRange>} extensionRange
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.extensionRange = $util.emptyArray;

            /**
             * DescriptorProto oneofDecl.
             * @member {Array.<google.protobuf.IOneofDescriptorProto>} oneofDecl
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.oneofDecl = $util.emptyArray;

            /**
             * DescriptorProto options.
             * @member {google.protobuf.IMessageOptions|null|undefined} options
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.options = null;

            /**
             * DescriptorProto reservedRange.
             * @member {Array.<google.protobuf.DescriptorProto.IReservedRange>} reservedRange
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.reservedRange = $util.emptyArray;

            /**
             * DescriptorProto reservedName.
             * @member {Array.<string>} reservedName
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.reservedName = $util.emptyArray;

            /**
             * DescriptorProto visibility.
             * @member {google.protobuf.SymbolVisibility} visibility
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.visibility = 0;

            /**
             * Creates a new DescriptorProto instance using the specified properties.
             * @function create
             * @memberof google.protobuf.DescriptorProto
             * @static
             * @param {google.protobuf.IDescriptorProto=} [properties] Properties to set
             * @returns {google.protobuf.DescriptorProto} DescriptorProto instance
             */
            DescriptorProto.create = function create(properties) {
                return new DescriptorProto(properties);
            };

            /**
             * Encodes the specified DescriptorProto message. Does not implicitly {@link google.protobuf.DescriptorProto.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.DescriptorProto
             * @static
             * @param {google.protobuf.IDescriptorProto} message DescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DescriptorProto.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.field != null && message.field.length)
                    for (let i = 0; i < message.field.length; ++i)
                        $root.google.protobuf.FieldDescriptorProto.encode(message.field[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.nestedType != null && message.nestedType.length)
                    for (let i = 0; i < message.nestedType.length; ++i)
                        $root.google.protobuf.DescriptorProto.encode(message.nestedType[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.enumType != null && message.enumType.length)
                    for (let i = 0; i < message.enumType.length; ++i)
                        $root.google.protobuf.EnumDescriptorProto.encode(message.enumType[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.extensionRange != null && message.extensionRange.length)
                    for (let i = 0; i < message.extensionRange.length; ++i)
                        $root.google.protobuf.DescriptorProto.ExtensionRange.encode(message.extensionRange[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.extension != null && message.extension.length)
                    for (let i = 0; i < message.extension.length; ++i)
                        $root.google.protobuf.FieldDescriptorProto.encode(message.extension[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                    $root.google.protobuf.MessageOptions.encode(message.options, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.oneofDecl != null && message.oneofDecl.length)
                    for (let i = 0; i < message.oneofDecl.length; ++i)
                        $root.google.protobuf.OneofDescriptorProto.encode(message.oneofDecl[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.reservedRange != null && message.reservedRange.length)
                    for (let i = 0; i < message.reservedRange.length; ++i)
                        $root.google.protobuf.DescriptorProto.ReservedRange.encode(message.reservedRange[i], writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                if (message.reservedName != null && message.reservedName.length)
                    for (let i = 0; i < message.reservedName.length; ++i)
                        writer.uint32(/* id 10, wireType 2 =*/82).string(message.reservedName[i]);
                if (message.visibility != null && Object.hasOwnProperty.call(message, "visibility"))
                    writer.uint32(/* id 11, wireType 0 =*/88).int32(message.visibility);
                return writer;
            };

            /**
             * Encodes the specified DescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.DescriptorProto.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.DescriptorProto
             * @static
             * @param {google.protobuf.IDescriptorProto} message DescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DescriptorProto message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.DescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.DescriptorProto} DescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DescriptorProto.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.DescriptorProto();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.name = reader.string();
                            break;
                        }
                    case 2: {
                            if (!(message.field && message.field.length))
                                message.field = [];
                            message.field.push($root.google.protobuf.FieldDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        }
                    case 6: {
                            if (!(message.extension && message.extension.length))
                                message.extension = [];
                            message.extension.push($root.google.protobuf.FieldDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        }
                    case 3: {
                            if (!(message.nestedType && message.nestedType.length))
                                message.nestedType = [];
                            message.nestedType.push($root.google.protobuf.DescriptorProto.decode(reader, reader.uint32()));
                            break;
                        }
                    case 4: {
                            if (!(message.enumType && message.enumType.length))
                                message.enumType = [];
                            message.enumType.push($root.google.protobuf.EnumDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        }
                    case 5: {
                            if (!(message.extensionRange && message.extensionRange.length))
                                message.extensionRange = [];
                            message.extensionRange.push($root.google.protobuf.DescriptorProto.ExtensionRange.decode(reader, reader.uint32()));
                            break;
                        }
                    case 8: {
                            if (!(message.oneofDecl && message.oneofDecl.length))
                                message.oneofDecl = [];
                            message.oneofDecl.push($root.google.protobuf.OneofDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        }
                    case 7: {
                            message.options = $root.google.protobuf.MessageOptions.decode(reader, reader.uint32());
                            break;
                        }
                    case 9: {
                            if (!(message.reservedRange && message.reservedRange.length))
                                message.reservedRange = [];
                            message.reservedRange.push($root.google.protobuf.DescriptorProto.ReservedRange.decode(reader, reader.uint32()));
                            break;
                        }
                    case 10: {
                            if (!(message.reservedName && message.reservedName.length))
                                message.reservedName = [];
                            message.reservedName.push(reader.string());
                            break;
                        }
                    case 11: {
                            message.visibility = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DescriptorProto message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.DescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.DescriptorProto} DescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DescriptorProto message.
             * @function verify
             * @memberof google.protobuf.DescriptorProto
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DescriptorProto.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.field != null && message.hasOwnProperty("field")) {
                    if (!Array.isArray(message.field))
                        return "field: array expected";
                    for (let i = 0; i < message.field.length; ++i) {
                        let error = $root.google.protobuf.FieldDescriptorProto.verify(message.field[i]);
                        if (error)
                            return "field." + error;
                    }
                }
                if (message.extension != null && message.hasOwnProperty("extension")) {
                    if (!Array.isArray(message.extension))
                        return "extension: array expected";
                    for (let i = 0; i < message.extension.length; ++i) {
                        let error = $root.google.protobuf.FieldDescriptorProto.verify(message.extension[i]);
                        if (error)
                            return "extension." + error;
                    }
                }
                if (message.nestedType != null && message.hasOwnProperty("nestedType")) {
                    if (!Array.isArray(message.nestedType))
                        return "nestedType: array expected";
                    for (let i = 0; i < message.nestedType.length; ++i) {
                        let error = $root.google.protobuf.DescriptorProto.verify(message.nestedType[i]);
                        if (error)
                            return "nestedType." + error;
                    }
                }
                if (message.enumType != null && message.hasOwnProperty("enumType")) {
                    if (!Array.isArray(message.enumType))
                        return "enumType: array expected";
                    for (let i = 0; i < message.enumType.length; ++i) {
                        let error = $root.google.protobuf.EnumDescriptorProto.verify(message.enumType[i]);
                        if (error)
                            return "enumType." + error;
                    }
                }
                if (message.extensionRange != null && message.hasOwnProperty("extensionRange")) {
                    if (!Array.isArray(message.extensionRange))
                        return "extensionRange: array expected";
                    for (let i = 0; i < message.extensionRange.length; ++i) {
                        let error = $root.google.protobuf.DescriptorProto.ExtensionRange.verify(message.extensionRange[i]);
                        if (error)
                            return "extensionRange." + error;
                    }
                }
                if (message.oneofDecl != null && message.hasOwnProperty("oneofDecl")) {
                    if (!Array.isArray(message.oneofDecl))
                        return "oneofDecl: array expected";
                    for (let i = 0; i < message.oneofDecl.length; ++i) {
                        let error = $root.google.protobuf.OneofDescriptorProto.verify(message.oneofDecl[i]);
                        if (error)
                            return "oneofDecl." + error;
                    }
                }
                if (message.options != null && message.hasOwnProperty("options")) {
                    let error = $root.google.protobuf.MessageOptions.verify(message.options);
                    if (error)
                        return "options." + error;
                }
                if (message.reservedRange != null && message.hasOwnProperty("reservedRange")) {
                    if (!Array.isArray(message.reservedRange))
                        return "reservedRange: array expected";
                    for (let i = 0; i < message.reservedRange.length; ++i) {
                        let error = $root.google.protobuf.DescriptorProto.ReservedRange.verify(message.reservedRange[i]);
                        if (error)
                            return "reservedRange." + error;
                    }
                }
                if (message.reservedName != null && message.hasOwnProperty("reservedName")) {
                    if (!Array.isArray(message.reservedName))
                        return "reservedName: array expected";
                    for (let i = 0; i < message.reservedName.length; ++i)
                        if (!$util.isString(message.reservedName[i]))
                            return "reservedName: string[] expected";
                }
                if (message.visibility != null && message.hasOwnProperty("visibility"))
                    switch (message.visibility) {
                    default:
                        return "visibility: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                return null;
            };

            /**
             * Creates a DescriptorProto message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.DescriptorProto
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.DescriptorProto} DescriptorProto
             */
            DescriptorProto.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.DescriptorProto)
                    return object;
                let message = new $root.google.protobuf.DescriptorProto();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.field) {
                    if (!Array.isArray(object.field))
                        throw TypeError(".google.protobuf.DescriptorProto.field: array expected");
                    message.field = [];
                    for (let i = 0; i < object.field.length; ++i) {
                        if (typeof object.field[i] !== "object")
                            throw TypeError(".google.protobuf.DescriptorProto.field: object expected");
                        message.field[i] = $root.google.protobuf.FieldDescriptorProto.fromObject(object.field[i]);
                    }
                }
                if (object.extension) {
                    if (!Array.isArray(object.extension))
                        throw TypeError(".google.protobuf.DescriptorProto.extension: array expected");
                    message.extension = [];
                    for (let i = 0; i < object.extension.length; ++i) {
                        if (typeof object.extension[i] !== "object")
                            throw TypeError(".google.protobuf.DescriptorProto.extension: object expected");
                        message.extension[i] = $root.google.protobuf.FieldDescriptorProto.fromObject(object.extension[i]);
                    }
                }
                if (object.nestedType) {
                    if (!Array.isArray(object.nestedType))
                        throw TypeError(".google.protobuf.DescriptorProto.nestedType: array expected");
                    message.nestedType = [];
                    for (let i = 0; i < object.nestedType.length; ++i) {
                        if (typeof object.nestedType[i] !== "object")
                            throw TypeError(".google.protobuf.DescriptorProto.nestedType: object expected");
                        message.nestedType[i] = $root.google.protobuf.DescriptorProto.fromObject(object.nestedType[i]);
                    }
                }
                if (object.enumType) {
                    if (!Array.isArray(object.enumType))
                        throw TypeError(".google.protobuf.DescriptorProto.enumType: array expected");
                    message.enumType = [];
                    for (let i = 0; i < object.enumType.length; ++i) {
                        if (typeof object.enumType[i] !== "object")
                            throw TypeError(".google.protobuf.DescriptorProto.enumType: object expected");
                        message.enumType[i] = $root.google.protobuf.EnumDescriptorProto.fromObject(object.enumType[i]);
                    }
                }
                if (object.extensionRange) {
                    if (!Array.isArray(object.extensionRange))
                        throw TypeError(".google.protobuf.DescriptorProto.extensionRange: array expected");
                    message.extensionRange = [];
                    for (let i = 0; i < object.extensionRange.length; ++i) {
                        if (typeof object.extensionRange[i] !== "object")
                            throw TypeError(".google.protobuf.DescriptorProto.extensionRange: object expected");
                        message.extensionRange[i] = $root.google.protobuf.DescriptorProto.ExtensionRange.fromObject(object.extensionRange[i]);
                    }
                }
                if (object.oneofDecl) {
                    if (!Array.isArray(object.oneofDecl))
                        throw TypeError(".google.protobuf.DescriptorProto.oneofDecl: array expected");
                    message.oneofDecl = [];
                    for (let i = 0; i < object.oneofDecl.length; ++i) {
                        if (typeof object.oneofDecl[i] !== "object")
                            throw TypeError(".google.protobuf.DescriptorProto.oneofDecl: object expected");
                        message.oneofDecl[i] = $root.google.protobuf.OneofDescriptorProto.fromObject(object.oneofDecl[i]);
                    }
                }
                if (object.options != null) {
                    if (typeof object.options !== "object")
                        throw TypeError(".google.protobuf.DescriptorProto.options: object expected");
                    message.options = $root.google.protobuf.MessageOptions.fromObject(object.options);
                }
                if (object.reservedRange) {
                    if (!Array.isArray(object.reservedRange))
                        throw TypeError(".google.protobuf.DescriptorProto.reservedRange: array expected");
                    message.reservedRange = [];
                    for (let i = 0; i < object.reservedRange.length; ++i) {
                        if (typeof object.reservedRange[i] !== "object")
                            throw TypeError(".google.protobuf.DescriptorProto.reservedRange: object expected");
                        message.reservedRange[i] = $root.google.protobuf.DescriptorProto.ReservedRange.fromObject(object.reservedRange[i]);
                    }
                }
                if (object.reservedName) {
                    if (!Array.isArray(object.reservedName))
                        throw TypeError(".google.protobuf.DescriptorProto.reservedName: array expected");
                    message.reservedName = [];
                    for (let i = 0; i < object.reservedName.length; ++i)
                        message.reservedName[i] = String(object.reservedName[i]);
                }
                switch (object.visibility) {
                default:
                    if (typeof object.visibility === "number") {
                        message.visibility = object.visibility;
                        break;
                    }
                    break;
                case "VISIBILITY_UNSET":
                case 0:
                    message.visibility = 0;
                    break;
                case "VISIBILITY_LOCAL":
                case 1:
                    message.visibility = 1;
                    break;
                case "VISIBILITY_EXPORT":
                case 2:
                    message.visibility = 2;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from a DescriptorProto message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.DescriptorProto
             * @static
             * @param {google.protobuf.DescriptorProto} message DescriptorProto
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DescriptorProto.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults) {
                    object.field = [];
                    object.nestedType = [];
                    object.enumType = [];
                    object.extensionRange = [];
                    object.extension = [];
                    object.oneofDecl = [];
                    object.reservedRange = [];
                    object.reservedName = [];
                }
                if (options.defaults) {
                    object.name = "";
                    object.options = null;
                    object.visibility = options.enums === String ? "VISIBILITY_UNSET" : 0;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.field && message.field.length) {
                    object.field = [];
                    for (let j = 0; j < message.field.length; ++j)
                        object.field[j] = $root.google.protobuf.FieldDescriptorProto.toObject(message.field[j], options);
                }
                if (message.nestedType && message.nestedType.length) {
                    object.nestedType = [];
                    for (let j = 0; j < message.nestedType.length; ++j)
                        object.nestedType[j] = $root.google.protobuf.DescriptorProto.toObject(message.nestedType[j], options);
                }
                if (message.enumType && message.enumType.length) {
                    object.enumType = [];
                    for (let j = 0; j < message.enumType.length; ++j)
                        object.enumType[j] = $root.google.protobuf.EnumDescriptorProto.toObject(message.enumType[j], options);
                }
                if (message.extensionRange && message.extensionRange.length) {
                    object.extensionRange = [];
                    for (let j = 0; j < message.extensionRange.length; ++j)
                        object.extensionRange[j] = $root.google.protobuf.DescriptorProto.ExtensionRange.toObject(message.extensionRange[j], options);
                }
                if (message.extension && message.extension.length) {
                    object.extension = [];
                    for (let j = 0; j < message.extension.length; ++j)
                        object.extension[j] = $root.google.protobuf.FieldDescriptorProto.toObject(message.extension[j], options);
                }
                if (message.options != null && message.hasOwnProperty("options"))
                    object.options = $root.google.protobuf.MessageOptions.toObject(message.options, options);
                if (message.oneofDecl && message.oneofDecl.length) {
                    object.oneofDecl = [];
                    for (let j = 0; j < message.oneofDecl.length; ++j)
                        object.oneofDecl[j] = $root.google.protobuf.OneofDescriptorProto.toObject(message.oneofDecl[j], options);
                }
                if (message.reservedRange && message.reservedRange.length) {
                    object.reservedRange = [];
                    for (let j = 0; j < message.reservedRange.length; ++j)
                        object.reservedRange[j] = $root.google.protobuf.DescriptorProto.ReservedRange.toObject(message.reservedRange[j], options);
                }
                if (message.reservedName && message.reservedName.length) {
                    object.reservedName = [];
                    for (let j = 0; j < message.reservedName.length; ++j)
                        object.reservedName[j] = message.reservedName[j];
                }
                if (message.visibility != null && message.hasOwnProperty("visibility"))
                    object.visibility = options.enums === String ? $root.google.protobuf.SymbolVisibility[message.visibility] === undefined ? message.visibility : $root.google.protobuf.SymbolVisibility[message.visibility] : message.visibility;
                return object;
            };

            /**
             * Converts this DescriptorProto to JSON.
             * @function toJSON
             * @memberof google.protobuf.DescriptorProto
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DescriptorProto.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for DescriptorProto
             * @function getTypeUrl
             * @memberof google.protobuf.DescriptorProto
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            DescriptorProto.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/google.protobuf.DescriptorProto";
            };

            DescriptorProto.ExtensionRange = (function() {

                /**
                 * Properties of an ExtensionRange.
                 * @memberof google.protobuf.DescriptorProto
                 * @interface IExtensionRange
                 * @property {number|null} [start] ExtensionRange start
                 * @property {number|null} [end] ExtensionRange end
                 * @property {google.protobuf.IExtensionRangeOptions|null} [options] ExtensionRange options
                 */

                /**
                 * Constructs a new ExtensionRange.
                 * @memberof google.protobuf.DescriptorProto
                 * @classdesc Represents an ExtensionRange.
                 * @implements IExtensionRange
                 * @constructor
                 * @param {google.protobuf.DescriptorProto.IExtensionRange=} [properties] Properties to set
                 */
                function ExtensionRange(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ExtensionRange start.
                 * @member {number} start
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @instance
                 */
                ExtensionRange.prototype.start = 0;

                /**
                 * ExtensionRange end.
                 * @member {number} end
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @instance
                 */
                ExtensionRange.prototype.end = 0;

                /**
                 * ExtensionRange options.
                 * @member {google.protobuf.IExtensionRangeOptions|null|undefined} options
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @instance
                 */
                ExtensionRange.prototype.options = null;

                /**
                 * Creates a new ExtensionRange instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @static
                 * @param {google.protobuf.DescriptorProto.IExtensionRange=} [properties] Properties to set
                 * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange instance
                 */
                ExtensionRange.create = function create(properties) {
                    return new ExtensionRange(properties);
                };

                /**
                 * Encodes the specified ExtensionRange message. Does not implicitly {@link google.protobuf.DescriptorProto.ExtensionRange.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @static
                 * @param {google.protobuf.DescriptorProto.IExtensionRange} message ExtensionRange message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ExtensionRange.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.start != null && Object.hasOwnProperty.call(message, "start"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.start);
                    if (message.end != null && Object.hasOwnProperty.call(message, "end"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.end);
                    if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                        $root.google.protobuf.ExtensionRangeOptions.encode(message.options, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified ExtensionRange message, length delimited. Does not implicitly {@link google.protobuf.DescriptorProto.ExtensionRange.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @static
                 * @param {google.protobuf.DescriptorProto.IExtensionRange} message ExtensionRange message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ExtensionRange.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an ExtensionRange message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ExtensionRange.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.DescriptorProto.ExtensionRange();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                message.start = reader.int32();
                                break;
                            }
                        case 2: {
                                message.end = reader.int32();
                                break;
                            }
                        case 3: {
                                message.options = $root.google.protobuf.ExtensionRangeOptions.decode(reader, reader.uint32());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an ExtensionRange message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ExtensionRange.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an ExtensionRange message.
                 * @function verify
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ExtensionRange.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.start != null && message.hasOwnProperty("start"))
                        if (!$util.isInteger(message.start))
                            return "start: integer expected";
                    if (message.end != null && message.hasOwnProperty("end"))
                        if (!$util.isInteger(message.end))
                            return "end: integer expected";
                    if (message.options != null && message.hasOwnProperty("options")) {
                        let error = $root.google.protobuf.ExtensionRangeOptions.verify(message.options);
                        if (error)
                            return "options." + error;
                    }
                    return null;
                };

                /**
                 * Creates an ExtensionRange message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange
                 */
                ExtensionRange.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.DescriptorProto.ExtensionRange)
                        return object;
                    let message = new $root.google.protobuf.DescriptorProto.ExtensionRange();
                    if (object.start != null)
                        message.start = object.start | 0;
                    if (object.end != null)
                        message.end = object.end | 0;
                    if (object.options != null) {
                        if (typeof object.options !== "object")
                            throw TypeError(".google.protobuf.DescriptorProto.ExtensionRange.options: object expected");
                        message.options = $root.google.protobuf.ExtensionRangeOptions.fromObject(object.options);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from an ExtensionRange message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @static
                 * @param {google.protobuf.DescriptorProto.ExtensionRange} message ExtensionRange
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ExtensionRange.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.start = 0;
                        object.end = 0;
                        object.options = null;
                    }
                    if (message.start != null && message.hasOwnProperty("start"))
                        object.start = message.start;
                    if (message.end != null && message.hasOwnProperty("end"))
                        object.end = message.end;
                    if (message.options != null && message.hasOwnProperty("options"))
                        object.options = $root.google.protobuf.ExtensionRangeOptions.toObject(message.options, options);
                    return object;
                };

                /**
                 * Converts this ExtensionRange to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ExtensionRange.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for ExtensionRange
                 * @function getTypeUrl
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                ExtensionRange.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/google.protobuf.DescriptorProto.ExtensionRange";
                };

                return ExtensionRange;
            })();

            DescriptorProto.ReservedRange = (function() {

                /**
                 * Properties of a ReservedRange.
                 * @memberof google.protobuf.DescriptorProto
                 * @interface IReservedRange
                 * @property {number|null} [start] ReservedRange start
                 * @property {number|null} [end] ReservedRange end
                 */

                /**
                 * Constructs a new ReservedRange.
                 * @memberof google.protobuf.DescriptorProto
                 * @classdesc Represents a ReservedRange.
                 * @implements IReservedRange
                 * @constructor
                 * @param {google.protobuf.DescriptorProto.IReservedRange=} [properties] Properties to set
                 */
                function ReservedRange(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ReservedRange start.
                 * @member {number} start
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @instance
                 */
                ReservedRange.prototype.start = 0;

                /**
                 * ReservedRange end.
                 * @member {number} end
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @instance
                 */
                ReservedRange.prototype.end = 0;

                /**
                 * Creates a new ReservedRange instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @static
                 * @param {google.protobuf.DescriptorProto.IReservedRange=} [properties] Properties to set
                 * @returns {google.protobuf.DescriptorProto.ReservedRange} ReservedRange instance
                 */
                ReservedRange.create = function create(properties) {
                    return new ReservedRange(properties);
                };

                /**
                 * Encodes the specified ReservedRange message. Does not implicitly {@link google.protobuf.DescriptorProto.ReservedRange.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @static
                 * @param {google.protobuf.DescriptorProto.IReservedRange} message ReservedRange message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ReservedRange.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.start != null && Object.hasOwnProperty.call(message, "start"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.start);
                    if (message.end != null && Object.hasOwnProperty.call(message, "end"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.end);
                    return writer;
                };

                /**
                 * Encodes the specified ReservedRange message, length delimited. Does not implicitly {@link google.protobuf.DescriptorProto.ReservedRange.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @static
                 * @param {google.protobuf.DescriptorProto.IReservedRange} message ReservedRange message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ReservedRange.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a ReservedRange message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.DescriptorProto.ReservedRange} ReservedRange
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ReservedRange.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.DescriptorProto.ReservedRange();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                message.start = reader.int32();
                                break;
                            }
                        case 2: {
                                message.end = reader.int32();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a ReservedRange message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.DescriptorProto.ReservedRange} ReservedRange
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ReservedRange.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a ReservedRange message.
                 * @function verify
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ReservedRange.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.start != null && message.hasOwnProperty("start"))
                        if (!$util.isInteger(message.start))
                            return "start: integer expected";
                    if (message.end != null && message.hasOwnProperty("end"))
                        if (!$util.isInteger(message.end))
                            return "end: integer expected";
                    return null;
                };

                /**
                 * Creates a ReservedRange message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.DescriptorProto.ReservedRange} ReservedRange
                 */
                ReservedRange.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.DescriptorProto.ReservedRange)
                        return object;
                    let message = new $root.google.protobuf.DescriptorProto.ReservedRange();
                    if (object.start != null)
                        message.start = object.start | 0;
                    if (object.end != null)
                        message.end = object.end | 0;
                    return message;
                };

                /**
                 * Creates a plain object from a ReservedRange message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @static
                 * @param {google.protobuf.DescriptorProto.ReservedRange} message ReservedRange
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ReservedRange.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.start = 0;
                        object.end = 0;
                    }
                    if (message.start != null && message.hasOwnProperty("start"))
                        object.start = message.start;
                    if (message.end != null && message.hasOwnProperty("end"))
                        object.end = message.end;
                    return object;
                };

                /**
                 * Converts this ReservedRange to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ReservedRange.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for ReservedRange
                 * @function getTypeUrl
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                ReservedRange.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/google.protobuf.DescriptorProto.ReservedRange";
                };

                return ReservedRange;
            })();

            return DescriptorProto;
        })();

        protobuf.ExtensionRangeOptions = (function() {

            /**
             * Properties of an ExtensionRangeOptions.
             * @memberof google.protobuf
             * @interface IExtensionRangeOptions
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] ExtensionRangeOptions uninterpretedOption
             * @property {Array.<google.protobuf.ExtensionRangeOptions.IDeclaration>|null} [declaration] ExtensionRangeOptions declaration
             * @property {google.protobuf.IFeatureSet|null} [features] ExtensionRangeOptions features
             * @property {google.protobuf.ExtensionRangeOptions.VerificationState|null} [verification] ExtensionRangeOptions verification
             */

            /**
             * Constructs a new ExtensionRangeOptions.
             * @memberof google.protobuf
             * @classdesc Represents an ExtensionRangeOptions.
             * @implements IExtensionRangeOptions
             * @constructor
             * @param {google.protobuf.IExtensionRangeOptions=} [properties] Properties to set
             */
            function ExtensionRangeOptions(properties) {
                this.uninterpretedOption = [];
                this.declaration = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ExtensionRangeOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.ExtensionRangeOptions
             * @instance
             */
            ExtensionRangeOptions.prototype.uninterpretedOption = $util.emptyArray;

            /**
             * ExtensionRangeOptions declaration.
             * @member {Array.<google.protobuf.ExtensionRangeOptions.IDeclaration>} declaration
             * @memberof google.protobuf.ExtensionRangeOptions
             * @instance
             */
            ExtensionRangeOptions.prototype.declaration = $util.emptyArray;

            /**
             * ExtensionRangeOptions features.
             * @member {google.protobuf.IFeatureSet|null|undefined} features
             * @memberof google.protobuf.ExtensionRangeOptions
             * @instance
             */
            ExtensionRangeOptions.prototype.features = null;

            /**
             * ExtensionRangeOptions verification.
             * @member {google.protobuf.ExtensionRangeOptions.VerificationState} verification
             * @memberof google.protobuf.ExtensionRangeOptions
             * @instance
             */
            ExtensionRangeOptions.prototype.verification = 1;

            /**
             * Creates a new ExtensionRangeOptions instance using the specified properties.
             * @function create
             * @memberof google.protobuf.ExtensionRangeOptions
             * @static
             * @param {google.protobuf.IExtensionRangeOptions=} [properties] Properties to set
             * @returns {google.protobuf.ExtensionRangeOptions} ExtensionRangeOptions instance
             */
            ExtensionRangeOptions.create = function create(properties) {
                return new ExtensionRangeOptions(properties);
            };

            /**
             * Encodes the specified ExtensionRangeOptions message. Does not implicitly {@link google.protobuf.ExtensionRangeOptions.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.ExtensionRangeOptions
             * @static
             * @param {google.protobuf.IExtensionRangeOptions} message ExtensionRangeOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExtensionRangeOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.declaration != null && message.declaration.length)
                    for (let i = 0; i < message.declaration.length; ++i)
                        $root.google.protobuf.ExtensionRangeOptions.Declaration.encode(message.declaration[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.verification != null && Object.hasOwnProperty.call(message, "verification"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.verification);
                if (message.features != null && Object.hasOwnProperty.call(message, "features"))
                    $root.google.protobuf.FeatureSet.encode(message.features, writer.uint32(/* id 50, wireType 2 =*/402).fork()).ldelim();
                if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                    for (let i = 0; i < message.uninterpretedOption.length; ++i)
                        $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ExtensionRangeOptions message, length delimited. Does not implicitly {@link google.protobuf.ExtensionRangeOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.ExtensionRangeOptions
             * @static
             * @param {google.protobuf.IExtensionRangeOptions} message ExtensionRangeOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExtensionRangeOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ExtensionRangeOptions message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.ExtensionRangeOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.ExtensionRangeOptions} ExtensionRangeOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExtensionRangeOptions.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.ExtensionRangeOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 999: {
                            if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                                message.uninterpretedOption = [];
                            message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                            break;
                        }
                    case 2: {
                            if (!(message.declaration && message.declaration.length))
                                message.declaration = [];
                            message.declaration.push($root.google.protobuf.ExtensionRangeOptions.Declaration.decode(reader, reader.uint32()));
                            break;
                        }
                    case 50: {
                            message.features = $root.google.protobuf.FeatureSet.decode(reader, reader.uint32());
                            break;
                        }
                    case 3: {
                            message.verification = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ExtensionRangeOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.ExtensionRangeOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.ExtensionRangeOptions} ExtensionRangeOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExtensionRangeOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ExtensionRangeOptions message.
             * @function verify
             * @memberof google.protobuf.ExtensionRangeOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ExtensionRangeOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                    if (!Array.isArray(message.uninterpretedOption))
                        return "uninterpretedOption: array expected";
                    for (let i = 0; i < message.uninterpretedOption.length; ++i) {
                        let error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                        if (error)
                            return "uninterpretedOption." + error;
                    }
                }
                if (message.declaration != null && message.hasOwnProperty("declaration")) {
                    if (!Array.isArray(message.declaration))
                        return "declaration: array expected";
                    for (let i = 0; i < message.declaration.length; ++i) {
                        let error = $root.google.protobuf.ExtensionRangeOptions.Declaration.verify(message.declaration[i]);
                        if (error)
                            return "declaration." + error;
                    }
                }
                if (message.features != null && message.hasOwnProperty("features")) {
                    let error = $root.google.protobuf.FeatureSet.verify(message.features);
                    if (error)
                        return "features." + error;
                }
                if (message.verification != null && message.hasOwnProperty("verification"))
                    switch (message.verification) {
                    default:
                        return "verification: enum value expected";
                    case 0:
                    case 1:
                        break;
                    }
                return null;
            };

            /**
             * Creates an ExtensionRangeOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.ExtensionRangeOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.ExtensionRangeOptions} ExtensionRangeOptions
             */
            ExtensionRangeOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.ExtensionRangeOptions)
                    return object;
                let message = new $root.google.protobuf.ExtensionRangeOptions();
                if (object.uninterpretedOption) {
                    if (!Array.isArray(object.uninterpretedOption))
                        throw TypeError(".google.protobuf.ExtensionRangeOptions.uninterpretedOption: array expected");
                    message.uninterpretedOption = [];
                    for (let i = 0; i < object.uninterpretedOption.length; ++i) {
                        if (typeof object.uninterpretedOption[i] !== "object")
                            throw TypeError(".google.protobuf.ExtensionRangeOptions.uninterpretedOption: object expected");
                        message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
                    }
                }
                if (object.declaration) {
                    if (!Array.isArray(object.declaration))
                        throw TypeError(".google.protobuf.ExtensionRangeOptions.declaration: array expected");
                    message.declaration = [];
                    for (let i = 0; i < object.declaration.length; ++i) {
                        if (typeof object.declaration[i] !== "object")
                            throw TypeError(".google.protobuf.ExtensionRangeOptions.declaration: object expected");
                        message.declaration[i] = $root.google.protobuf.ExtensionRangeOptions.Declaration.fromObject(object.declaration[i]);
                    }
                }
                if (object.features != null) {
                    if (typeof object.features !== "object")
                        throw TypeError(".google.protobuf.ExtensionRangeOptions.features: object expected");
                    message.features = $root.google.protobuf.FeatureSet.fromObject(object.features);
                }
                switch (object.verification) {
                case "DECLARATION":
                case 0:
                    message.verification = 0;
                    break;
                default:
                    if (typeof object.verification === "number") {
                        message.verification = object.verification;
                        break;
                    }
                    break;
                case "UNVERIFIED":
                case 1:
                    message.verification = 1;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from an ExtensionRangeOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.ExtensionRangeOptions
             * @static
             * @param {google.protobuf.ExtensionRangeOptions} message ExtensionRangeOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ExtensionRangeOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults) {
                    object.declaration = [];
                    object.uninterpretedOption = [];
                }
                if (options.defaults) {
                    object.verification = options.enums === String ? "UNVERIFIED" : 1;
                    object.features = null;
                }
                if (message.declaration && message.declaration.length) {
                    object.declaration = [];
                    for (let j = 0; j < message.declaration.length; ++j)
                        object.declaration[j] = $root.google.protobuf.ExtensionRangeOptions.Declaration.toObject(message.declaration[j], options);
                }
                if (message.verification != null && message.hasOwnProperty("verification"))
                    object.verification = options.enums === String ? $root.google.protobuf.ExtensionRangeOptions.VerificationState[message.verification] === undefined ? message.verification : $root.google.protobuf.ExtensionRangeOptions.VerificationState[message.verification] : message.verification;
                if (message.features != null && message.hasOwnProperty("features"))
                    object.features = $root.google.protobuf.FeatureSet.toObject(message.features, options);
                if (message.uninterpretedOption && message.uninterpretedOption.length) {
                    object.uninterpretedOption = [];
                    for (let j = 0; j < message.uninterpretedOption.length; ++j)
                        object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
                }
                return object;
            };

            /**
             * Converts this ExtensionRangeOptions to JSON.
             * @function toJSON
             * @memberof google.protobuf.ExtensionRangeOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ExtensionRangeOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ExtensionRangeOptions
             * @function getTypeUrl
             * @memberof google.protobuf.ExtensionRangeOptions
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ExtensionRangeOptions.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/google.protobuf.ExtensionRangeOptions";
            };

            ExtensionRangeOptions.Declaration = (function() {

                /**
                 * Properties of a Declaration.
                 * @memberof google.protobuf.ExtensionRangeOptions
                 * @interface IDeclaration
                 * @property {number|null} [number] Declaration number
                 * @property {string|null} [fullName] Declaration fullName
                 * @property {string|null} [type] Declaration type
                 * @property {boolean|null} [reserved] Declaration reserved
                 * @property {boolean|null} [repeated] Declaration repeated
                 */

                /**
                 * Constructs a new Declaration.
                 * @memberof google.protobuf.ExtensionRangeOptions
                 * @classdesc Represents a Declaration.
                 * @implements IDeclaration
                 * @constructor
                 * @param {google.protobuf.ExtensionRangeOptions.IDeclaration=} [properties] Properties to set
                 */
                function Declaration(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Declaration number.
                 * @member {number} number
                 * @memberof google.protobuf.ExtensionRangeOptions.Declaration
                 * @instance
                 */
                Declaration.prototype.number = 0;

                /**
                 * Declaration fullName.
                 * @member {string} fullName
                 * @memberof google.protobuf.ExtensionRangeOptions.Declaration
                 * @instance
                 */
                Declaration.prototype.fullName = "";

                /**
                 * Declaration type.
                 * @member {string} type
                 * @memberof google.protobuf.ExtensionRangeOptions.Declaration
                 * @instance
                 */
                Declaration.prototype.type = "";

                /**
                 * Declaration reserved.
                 * @member {boolean} reserved
                 * @memberof google.protobuf.ExtensionRangeOptions.Declaration
                 * @instance
                 */
                Declaration.prototype.reserved = false;

                /**
                 * Declaration repeated.
                 * @member {boolean} repeated
                 * @memberof google.protobuf.ExtensionRangeOptions.Declaration
                 * @instance
                 */
                Declaration.prototype.repeated = false;

                /**
                 * Creates a new Declaration instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.ExtensionRangeOptions.Declaration
                 * @static
                 * @param {google.protobuf.ExtensionRangeOptions.IDeclaration=} [properties] Properties to set
                 * @returns {google.protobuf.ExtensionRangeOptions.Declaration} Declaration instance
                 */
                Declaration.create = function create(properties) {
                    return new Declaration(properties);
                };

                /**
                 * Encodes the specified Declaration message. Does not implicitly {@link google.protobuf.ExtensionRangeOptions.Declaration.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.ExtensionRangeOptions.Declaration
                 * @static
                 * @param {google.protobuf.ExtensionRangeOptions.IDeclaration} message Declaration message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Declaration.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.number != null && Object.hasOwnProperty.call(message, "number"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.number);
                    if (message.fullName != null && Object.hasOwnProperty.call(message, "fullName"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.fullName);
                    if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.type);
                    if (message.reserved != null && Object.hasOwnProperty.call(message, "reserved"))
                        writer.uint32(/* id 5, wireType 0 =*/40).bool(message.reserved);
                    if (message.repeated != null && Object.hasOwnProperty.call(message, "repeated"))
                        writer.uint32(/* id 6, wireType 0 =*/48).bool(message.repeated);
                    return writer;
                };

                /**
                 * Encodes the specified Declaration message, length delimited. Does not implicitly {@link google.protobuf.ExtensionRangeOptions.Declaration.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.ExtensionRangeOptions.Declaration
                 * @static
                 * @param {google.protobuf.ExtensionRangeOptions.IDeclaration} message Declaration message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Declaration.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Declaration message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.ExtensionRangeOptions.Declaration
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.ExtensionRangeOptions.Declaration} Declaration
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Declaration.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.ExtensionRangeOptions.Declaration();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                message.number = reader.int32();
                                break;
                            }
                        case 2: {
                                message.fullName = reader.string();
                                break;
                            }
                        case 3: {
                                message.type = reader.string();
                                break;
                            }
                        case 5: {
                                message.reserved = reader.bool();
                                break;
                            }
                        case 6: {
                                message.repeated = reader.bool();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Declaration message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.ExtensionRangeOptions.Declaration
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.ExtensionRangeOptions.Declaration} Declaration
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Declaration.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Declaration message.
                 * @function verify
                 * @memberof google.protobuf.ExtensionRangeOptions.Declaration
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Declaration.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.number != null && message.hasOwnProperty("number"))
                        if (!$util.isInteger(message.number))
                            return "number: integer expected";
                    if (message.fullName != null && message.hasOwnProperty("fullName"))
                        if (!$util.isString(message.fullName))
                            return "fullName: string expected";
                    if (message.type != null && message.hasOwnProperty("type"))
                        if (!$util.isString(message.type))
                            return "type: string expected";
                    if (message.reserved != null && message.hasOwnProperty("reserved"))
                        if (typeof message.reserved !== "boolean")
                            return "reserved: boolean expected";
                    if (message.repeated != null && message.hasOwnProperty("repeated"))
                        if (typeof message.repeated !== "boolean")
                            return "repeated: boolean expected";
                    return null;
                };

                /**
                 * Creates a Declaration message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.ExtensionRangeOptions.Declaration
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.ExtensionRangeOptions.Declaration} Declaration
                 */
                Declaration.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.ExtensionRangeOptions.Declaration)
                        return object;
                    let message = new $root.google.protobuf.ExtensionRangeOptions.Declaration();
                    if (object.number != null)
                        message.number = object.number | 0;
                    if (object.fullName != null)
                        message.fullName = String(object.fullName);
                    if (object.type != null)
                        message.type = String(object.type);
                    if (object.reserved != null)
                        message.reserved = Boolean(object.reserved);
                    if (object.repeated != null)
                        message.repeated = Boolean(object.repeated);
                    return message;
                };

                /**
                 * Creates a plain object from a Declaration message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.ExtensionRangeOptions.Declaration
                 * @static
                 * @param {google.protobuf.ExtensionRangeOptions.Declaration} message Declaration
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Declaration.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.number = 0;
                        object.fullName = "";
                        object.type = "";
                        object.reserved = false;
                        object.repeated = false;
                    }
                    if (message.number != null && message.hasOwnProperty("number"))
                        object.number = message.number;
                    if (message.fullName != null && message.hasOwnProperty("fullName"))
                        object.fullName = message.fullName;
                    if (message.type != null && message.hasOwnProperty("type"))
                        object.type = message.type;
                    if (message.reserved != null && message.hasOwnProperty("reserved"))
                        object.reserved = message.reserved;
                    if (message.repeated != null && message.hasOwnProperty("repeated"))
                        object.repeated = message.repeated;
                    return object;
                };

                /**
                 * Converts this Declaration to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.ExtensionRangeOptions.Declaration
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Declaration.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for Declaration
                 * @function getTypeUrl
                 * @memberof google.protobuf.ExtensionRangeOptions.Declaration
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                Declaration.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/google.protobuf.ExtensionRangeOptions.Declaration";
                };

                return Declaration;
            })();

            /**
             * VerificationState enum.
             * @name google.protobuf.ExtensionRangeOptions.VerificationState
             * @enum {number}
             * @property {number} DECLARATION=0 DECLARATION value
             * @property {number} UNVERIFIED=1 UNVERIFIED value
             */
            ExtensionRangeOptions.VerificationState = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "DECLARATION"] = 0;
                values[valuesById[1] = "UNVERIFIED"] = 1;
                return values;
            })();

            return ExtensionRangeOptions;
        })();

        protobuf.FieldDescriptorProto = (function() {

            /**
             * Properties of a FieldDescriptorProto.
             * @memberof google.protobuf
             * @interface IFieldDescriptorProto
             * @property {string|null} [name] FieldDescriptorProto name
             * @property {number|null} [number] FieldDescriptorProto number
             * @property {google.protobuf.FieldDescriptorProto.Label|null} [label] FieldDescriptorProto label
             * @property {google.protobuf.FieldDescriptorProto.Type|null} [type] FieldDescriptorProto type
             * @property {string|null} [typeName] FieldDescriptorProto typeName
             * @property {string|null} [extendee] FieldDescriptorProto extendee
             * @property {string|null} [defaultValue] FieldDescriptorProto defaultValue
             * @property {number|null} [oneofIndex] FieldDescriptorProto oneofIndex
             * @property {string|null} [jsonName] FieldDescriptorProto jsonName
             * @property {google.protobuf.IFieldOptions|null} [options] FieldDescriptorProto options
             * @property {boolean|null} [proto3Optional] FieldDescriptorProto proto3Optional
             */

            /**
             * Constructs a new FieldDescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents a FieldDescriptorProto.
             * @implements IFieldDescriptorProto
             * @constructor
             * @param {google.protobuf.IFieldDescriptorProto=} [properties] Properties to set
             */
            function FieldDescriptorProto(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FieldDescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.name = "";

            /**
             * FieldDescriptorProto number.
             * @member {number} number
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.number = 0;

            /**
             * FieldDescriptorProto label.
             * @member {google.protobuf.FieldDescriptorProto.Label} label
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.label = 1;

            /**
             * FieldDescriptorProto type.
             * @member {google.protobuf.FieldDescriptorProto.Type} type
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.type = 1;

            /**
             * FieldDescriptorProto typeName.
             * @member {string} typeName
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.typeName = "";

            /**
             * FieldDescriptorProto extendee.
             * @member {string} extendee
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.extendee = "";

            /**
             * FieldDescriptorProto defaultValue.
             * @member {string} defaultValue
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.defaultValue = "";

            /**
             * FieldDescriptorProto oneofIndex.
             * @member {number} oneofIndex
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.oneofIndex = 0;

            /**
             * FieldDescriptorProto jsonName.
             * @member {string} jsonName
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.jsonName = "";

            /**
             * FieldDescriptorProto options.
             * @member {google.protobuf.IFieldOptions|null|undefined} options
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.options = null;

            /**
             * FieldDescriptorProto proto3Optional.
             * @member {boolean} proto3Optional
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.proto3Optional = false;

            /**
             * Creates a new FieldDescriptorProto instance using the specified properties.
             * @function create
             * @memberof google.protobuf.FieldDescriptorProto
             * @static
             * @param {google.protobuf.IFieldDescriptorProto=} [properties] Properties to set
             * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto instance
             */
            FieldDescriptorProto.create = function create(properties) {
                return new FieldDescriptorProto(properties);
            };

            /**
             * Encodes the specified FieldDescriptorProto message. Does not implicitly {@link google.protobuf.FieldDescriptorProto.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.FieldDescriptorProto
             * @static
             * @param {google.protobuf.IFieldDescriptorProto} message FieldDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FieldDescriptorProto.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.extendee != null && Object.hasOwnProperty.call(message, "extendee"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.extendee);
                if (message.number != null && Object.hasOwnProperty.call(message, "number"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.number);
                if (message.label != null && Object.hasOwnProperty.call(message, "label"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.label);
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.type);
                if (message.typeName != null && Object.hasOwnProperty.call(message, "typeName"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.typeName);
                if (message.defaultValue != null && Object.hasOwnProperty.call(message, "defaultValue"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.defaultValue);
                if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                    $root.google.protobuf.FieldOptions.encode(message.options, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.oneofIndex != null && Object.hasOwnProperty.call(message, "oneofIndex"))
                    writer.uint32(/* id 9, wireType 0 =*/72).int32(message.oneofIndex);
                if (message.jsonName != null && Object.hasOwnProperty.call(message, "jsonName"))
                    writer.uint32(/* id 10, wireType 2 =*/82).string(message.jsonName);
                if (message.proto3Optional != null && Object.hasOwnProperty.call(message, "proto3Optional"))
                    writer.uint32(/* id 17, wireType 0 =*/136).bool(message.proto3Optional);
                return writer;
            };

            /**
             * Encodes the specified FieldDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.FieldDescriptorProto.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.FieldDescriptorProto
             * @static
             * @param {google.protobuf.IFieldDescriptorProto} message FieldDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FieldDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FieldDescriptorProto message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.FieldDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FieldDescriptorProto.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FieldDescriptorProto();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.name = reader.string();
                            break;
                        }
                    case 3: {
                            message.number = reader.int32();
                            break;
                        }
                    case 4: {
                            message.label = reader.int32();
                            break;
                        }
                    case 5: {
                            message.type = reader.int32();
                            break;
                        }
                    case 6: {
                            message.typeName = reader.string();
                            break;
                        }
                    case 2: {
                            message.extendee = reader.string();
                            break;
                        }
                    case 7: {
                            message.defaultValue = reader.string();
                            break;
                        }
                    case 9: {
                            message.oneofIndex = reader.int32();
                            break;
                        }
                    case 10: {
                            message.jsonName = reader.string();
                            break;
                        }
                    case 8: {
                            message.options = $root.google.protobuf.FieldOptions.decode(reader, reader.uint32());
                            break;
                        }
                    case 17: {
                            message.proto3Optional = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FieldDescriptorProto message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.FieldDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FieldDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FieldDescriptorProto message.
             * @function verify
             * @memberof google.protobuf.FieldDescriptorProto
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FieldDescriptorProto.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.number != null && message.hasOwnProperty("number"))
                    if (!$util.isInteger(message.number))
                        return "number: integer expected";
                if (message.label != null && message.hasOwnProperty("label"))
                    switch (message.label) {
                    default:
                        return "label: enum value expected";
                    case 1:
                    case 3:
                    case 2:
                        break;
                    }
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                    case 9:
                    case 10:
                    case 11:
                    case 12:
                    case 13:
                    case 14:
                    case 15:
                    case 16:
                    case 17:
                    case 18:
                        break;
                    }
                if (message.typeName != null && message.hasOwnProperty("typeName"))
                    if (!$util.isString(message.typeName))
                        return "typeName: string expected";
                if (message.extendee != null && message.hasOwnProperty("extendee"))
                    if (!$util.isString(message.extendee))
                        return "extendee: string expected";
                if (message.defaultValue != null && message.hasOwnProperty("defaultValue"))
                    if (!$util.isString(message.defaultValue))
                        return "defaultValue: string expected";
                if (message.oneofIndex != null && message.hasOwnProperty("oneofIndex"))
                    if (!$util.isInteger(message.oneofIndex))
                        return "oneofIndex: integer expected";
                if (message.jsonName != null && message.hasOwnProperty("jsonName"))
                    if (!$util.isString(message.jsonName))
                        return "jsonName: string expected";
                if (message.options != null && message.hasOwnProperty("options")) {
                    let error = $root.google.protobuf.FieldOptions.verify(message.options);
                    if (error)
                        return "options." + error;
                }
                if (message.proto3Optional != null && message.hasOwnProperty("proto3Optional"))
                    if (typeof message.proto3Optional !== "boolean")
                        return "proto3Optional: boolean expected";
                return null;
            };

            /**
             * Creates a FieldDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.FieldDescriptorProto
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto
             */
            FieldDescriptorProto.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.FieldDescriptorProto)
                    return object;
                let message = new $root.google.protobuf.FieldDescriptorProto();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.number != null)
                    message.number = object.number | 0;
                switch (object.label) {
                default:
                    if (typeof object.label === "number") {
                        message.label = object.label;
                        break;
                    }
                    break;
                case "LABEL_OPTIONAL":
                case 1:
                    message.label = 1;
                    break;
                case "LABEL_REPEATED":
                case 3:
                    message.label = 3;
                    break;
                case "LABEL_REQUIRED":
                case 2:
                    message.label = 2;
                    break;
                }
                switch (object.type) {
                default:
                    if (typeof object.type === "number") {
                        message.type = object.type;
                        break;
                    }
                    break;
                case "TYPE_DOUBLE":
                case 1:
                    message.type = 1;
                    break;
                case "TYPE_FLOAT":
                case 2:
                    message.type = 2;
                    break;
                case "TYPE_INT64":
                case 3:
                    message.type = 3;
                    break;
                case "TYPE_UINT64":
                case 4:
                    message.type = 4;
                    break;
                case "TYPE_INT32":
                case 5:
                    message.type = 5;
                    break;
                case "TYPE_FIXED64":
                case 6:
                    message.type = 6;
                    break;
                case "TYPE_FIXED32":
                case 7:
                    message.type = 7;
                    break;
                case "TYPE_BOOL":
                case 8:
                    message.type = 8;
                    break;
                case "TYPE_STRING":
                case 9:
                    message.type = 9;
                    break;
                case "TYPE_GROUP":
                case 10:
                    message.type = 10;
                    break;
                case "TYPE_MESSAGE":
                case 11:
                    message.type = 11;
                    break;
                case "TYPE_BYTES":
                case 12:
                    message.type = 12;
                    break;
                case "TYPE_UINT32":
                case 13:
                    message.type = 13;
                    break;
                case "TYPE_ENUM":
                case 14:
                    message.type = 14;
                    break;
                case "TYPE_SFIXED32":
                case 15:
                    message.type = 15;
                    break;
                case "TYPE_SFIXED64":
                case 16:
                    message.type = 16;
                    break;
                case "TYPE_SINT32":
                case 17:
                    message.type = 17;
                    break;
                case "TYPE_SINT64":
                case 18:
                    message.type = 18;
                    break;
                }
                if (object.typeName != null)
                    message.typeName = String(object.typeName);
                if (object.extendee != null)
                    message.extendee = String(object.extendee);
                if (object.defaultValue != null)
                    message.defaultValue = String(object.defaultValue);
                if (object.oneofIndex != null)
                    message.oneofIndex = object.oneofIndex | 0;
                if (object.jsonName != null)
                    message.jsonName = String(object.jsonName);
                if (object.options != null) {
                    if (typeof object.options !== "object")
                        throw TypeError(".google.protobuf.FieldDescriptorProto.options: object expected");
                    message.options = $root.google.protobuf.FieldOptions.fromObject(object.options);
                }
                if (object.proto3Optional != null)
                    message.proto3Optional = Boolean(object.proto3Optional);
                return message;
            };

            /**
             * Creates a plain object from a FieldDescriptorProto message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.FieldDescriptorProto
             * @static
             * @param {google.protobuf.FieldDescriptorProto} message FieldDescriptorProto
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FieldDescriptorProto.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.name = "";
                    object.extendee = "";
                    object.number = 0;
                    object.label = options.enums === String ? "LABEL_OPTIONAL" : 1;
                    object.type = options.enums === String ? "TYPE_DOUBLE" : 1;
                    object.typeName = "";
                    object.defaultValue = "";
                    object.options = null;
                    object.oneofIndex = 0;
                    object.jsonName = "";
                    object.proto3Optional = false;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.extendee != null && message.hasOwnProperty("extendee"))
                    object.extendee = message.extendee;
                if (message.number != null && message.hasOwnProperty("number"))
                    object.number = message.number;
                if (message.label != null && message.hasOwnProperty("label"))
                    object.label = options.enums === String ? $root.google.protobuf.FieldDescriptorProto.Label[message.label] === undefined ? message.label : $root.google.protobuf.FieldDescriptorProto.Label[message.label] : message.label;
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.google.protobuf.FieldDescriptorProto.Type[message.type] === undefined ? message.type : $root.google.protobuf.FieldDescriptorProto.Type[message.type] : message.type;
                if (message.typeName != null && message.hasOwnProperty("typeName"))
                    object.typeName = message.typeName;
                if (message.defaultValue != null && message.hasOwnProperty("defaultValue"))
                    object.defaultValue = message.defaultValue;
                if (message.options != null && message.hasOwnProperty("options"))
                    object.options = $root.google.protobuf.FieldOptions.toObject(message.options, options);
                if (message.oneofIndex != null && message.hasOwnProperty("oneofIndex"))
                    object.oneofIndex = message.oneofIndex;
                if (message.jsonName != null && message.hasOwnProperty("jsonName"))
                    object.jsonName = message.jsonName;
                if (message.proto3Optional != null && message.hasOwnProperty("proto3Optional"))
                    object.proto3Optional = message.proto3Optional;
                return object;
            };

            /**
             * Converts this FieldDescriptorProto to JSON.
             * @function toJSON
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FieldDescriptorProto.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for FieldDescriptorProto
             * @function getTypeUrl
             * @memberof google.protobuf.FieldDescriptorProto
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            FieldDescriptorProto.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/google.protobuf.FieldDescriptorProto";
            };

            /**
             * Type enum.
             * @name google.protobuf.FieldDescriptorProto.Type
             * @enum {number}
             * @property {number} TYPE_DOUBLE=1 TYPE_DOUBLE value
             * @property {number} TYPE_FLOAT=2 TYPE_FLOAT value
             * @property {number} TYPE_INT64=3 TYPE_INT64 value
             * @property {number} TYPE_UINT64=4 TYPE_UINT64 value
             * @property {number} TYPE_INT32=5 TYPE_INT32 value
             * @property {number} TYPE_FIXED64=6 TYPE_FIXED64 value
             * @property {number} TYPE_FIXED32=7 TYPE_FIXED32 value
             * @property {number} TYPE_BOOL=8 TYPE_BOOL value
             * @property {number} TYPE_STRING=9 TYPE_STRING value
             * @property {number} TYPE_GROUP=10 TYPE_GROUP value
             * @property {number} TYPE_MESSAGE=11 TYPE_MESSAGE value
             * @property {number} TYPE_BYTES=12 TYPE_BYTES value
             * @property {number} TYPE_UINT32=13 TYPE_UINT32 value
             * @property {number} TYPE_ENUM=14 TYPE_ENUM value
             * @property {number} TYPE_SFIXED32=15 TYPE_SFIXED32 value
             * @property {number} TYPE_SFIXED64=16 TYPE_SFIXED64 value
             * @property {number} TYPE_SINT32=17 TYPE_SINT32 value
             * @property {number} TYPE_SINT64=18 TYPE_SINT64 value
             */
            FieldDescriptorProto.Type = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[1] = "TYPE_DOUBLE"] = 1;
                values[valuesById[2] = "TYPE_FLOAT"] = 2;
                values[valuesById[3] = "TYPE_INT64"] = 3;
                values[valuesById[4] = "TYPE_UINT64"] = 4;
                values[valuesById[5] = "TYPE_INT32"] = 5;
                values[valuesById[6] = "TYPE_FIXED64"] = 6;
                values[valuesById[7] = "TYPE_FIXED32"] = 7;
                values[valuesById[8] = "TYPE_BOOL"] = 8;
                values[valuesById[9] = "TYPE_STRING"] = 9;
                values[valuesById[10] = "TYPE_GROUP"] = 10;
                values[valuesById[11] = "TYPE_MESSAGE"] = 11;
                values[valuesById[12] = "TYPE_BYTES"] = 12;
                values[valuesById[13] = "TYPE_UINT32"] = 13;
                values[valuesById[14] = "TYPE_ENUM"] = 14;
                values[valuesById[15] = "TYPE_SFIXED32"] = 15;
                values[valuesById[16] = "TYPE_SFIXED64"] = 16;
                values[valuesById[17] = "TYPE_SINT32"] = 17;
                values[valuesById[18] = "TYPE_SINT64"] = 18;
                return values;
            })();

            /**
             * Label enum.
             * @name google.protobuf.FieldDescriptorProto.Label
             * @enum {number}
             * @property {number} LABEL_OPTIONAL=1 LABEL_OPTIONAL value
             * @property {number} LABEL_REPEATED=3 LABEL_REPEATED value
             * @property {number} LABEL_REQUIRED=2 LABEL_REQUIRED value
             */
            FieldDescriptorProto.Label = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[1] = "LABEL_OPTIONAL"] = 1;
                values[valuesById[3] = "LABEL_REPEATED"] = 3;
                values[valuesById[2] = "LABEL_REQUIRED"] = 2;
                return values;
            })();

            return FieldDescriptorProto;
        })();

        protobuf.OneofDescriptorProto = (function() {

            /**
             * Properties of an OneofDescriptorProto.
             * @memberof google.protobuf
             * @interface IOneofDescriptorProto
             * @property {string|null} [name] OneofDescriptorProto name
             * @property {google.protobuf.IOneofOptions|null} [options] OneofDescriptorProto options
             */

            /**
             * Constructs a new OneofDescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents an OneofDescriptorProto.
             * @implements IOneofDescriptorProto
             * @constructor
             * @param {google.protobuf.IOneofDescriptorProto=} [properties] Properties to set
             */
            function OneofDescriptorProto(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * OneofDescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.OneofDescriptorProto
             * @instance
             */
            OneofDescriptorProto.prototype.name = "";

            /**
             * OneofDescriptorProto options.
             * @member {google.protobuf.IOneofOptions|null|undefined} options
             * @memberof google.protobuf.OneofDescriptorProto
             * @instance
             */
            OneofDescriptorProto.prototype.options = null;

            /**
             * Creates a new OneofDescriptorProto instance using the specified properties.
             * @function create
             * @memberof google.protobuf.OneofDescriptorProto
             * @static
             * @param {google.protobuf.IOneofDescriptorProto=} [properties] Properties to set
             * @returns {google.protobuf.OneofDescriptorProto} OneofDescriptorProto instance
             */
            OneofDescriptorProto.create = function create(properties) {
                return new OneofDescriptorProto(properties);
            };

            /**
             * Encodes the specified OneofDescriptorProto message. Does not implicitly {@link google.protobuf.OneofDescriptorProto.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.OneofDescriptorProto
             * @static
             * @param {google.protobuf.IOneofDescriptorProto} message OneofDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OneofDescriptorProto.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                    $root.google.protobuf.OneofOptions.encode(message.options, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified OneofDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.OneofDescriptorProto.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.OneofDescriptorProto
             * @static
             * @param {google.protobuf.IOneofDescriptorProto} message OneofDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OneofDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an OneofDescriptorProto message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.OneofDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.OneofDescriptorProto} OneofDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OneofDescriptorProto.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.OneofDescriptorProto();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.name = reader.string();
                            break;
                        }
                    case 2: {
                            message.options = $root.google.protobuf.OneofOptions.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an OneofDescriptorProto message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.OneofDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.OneofDescriptorProto} OneofDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OneofDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an OneofDescriptorProto message.
             * @function verify
             * @memberof google.protobuf.OneofDescriptorProto
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            OneofDescriptorProto.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.options != null && message.hasOwnProperty("options")) {
                    let error = $root.google.protobuf.OneofOptions.verify(message.options);
                    if (error)
                        return "options." + error;
                }
                return null;
            };

            /**
             * Creates an OneofDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.OneofDescriptorProto
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.OneofDescriptorProto} OneofDescriptorProto
             */
            OneofDescriptorProto.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.OneofDescriptorProto)
                    return object;
                let message = new $root.google.protobuf.OneofDescriptorProto();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.options != null) {
                    if (typeof object.options !== "object")
                        throw TypeError(".google.protobuf.OneofDescriptorProto.options: object expected");
                    message.options = $root.google.protobuf.OneofOptions.fromObject(object.options);
                }
                return message;
            };

            /**
             * Creates a plain object from an OneofDescriptorProto message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.OneofDescriptorProto
             * @static
             * @param {google.protobuf.OneofDescriptorProto} message OneofDescriptorProto
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            OneofDescriptorProto.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.name = "";
                    object.options = null;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.options != null && message.hasOwnProperty("options"))
                    object.options = $root.google.protobuf.OneofOptions.toObject(message.options, options);
                return object;
            };

            /**
             * Converts this OneofDescriptorProto to JSON.
             * @function toJSON
             * @memberof google.protobuf.OneofDescriptorProto
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            OneofDescriptorProto.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for OneofDescriptorProto
             * @function getTypeUrl
             * @memberof google.protobuf.OneofDescriptorProto
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            OneofDescriptorProto.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/google.protobuf.OneofDescriptorProto";
            };

            return OneofDescriptorProto;
        })();

        protobuf.EnumDescriptorProto = (function() {

            /**
             * Properties of an EnumDescriptorProto.
             * @memberof google.protobuf
             * @interface IEnumDescriptorProto
             * @property {string|null} [name] EnumDescriptorProto name
             * @property {Array.<google.protobuf.IEnumValueDescriptorProto>|null} [value] EnumDescriptorProto value
             * @property {google.protobuf.IEnumOptions|null} [options] EnumDescriptorProto options
             * @property {Array.<google.protobuf.EnumDescriptorProto.IEnumReservedRange>|null} [reservedRange] EnumDescriptorProto reservedRange
             * @property {Array.<string>|null} [reservedName] EnumDescriptorProto reservedName
             * @property {google.protobuf.SymbolVisibility|null} [visibility] EnumDescriptorProto visibility
             */

            /**
             * Constructs a new EnumDescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents an EnumDescriptorProto.
             * @implements IEnumDescriptorProto
             * @constructor
             * @param {google.protobuf.IEnumDescriptorProto=} [properties] Properties to set
             */
            function EnumDescriptorProto(properties) {
                this.value = [];
                this.reservedRange = [];
                this.reservedName = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * EnumDescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.EnumDescriptorProto
             * @instance
             */
            EnumDescriptorProto.prototype.name = "";

            /**
             * EnumDescriptorProto value.
             * @member {Array.<google.protobuf.IEnumValueDescriptorProto>} value
             * @memberof google.protobuf.EnumDescriptorProto
             * @instance
             */
            EnumDescriptorProto.prototype.value = $util.emptyArray;

            /**
             * EnumDescriptorProto options.
             * @member {google.protobuf.IEnumOptions|null|undefined} options
             * @memberof google.protobuf.EnumDescriptorProto
             * @instance
             */
            EnumDescriptorProto.prototype.options = null;

            /**
             * EnumDescriptorProto reservedRange.
             * @member {Array.<google.protobuf.EnumDescriptorProto.IEnumReservedRange>} reservedRange
             * @memberof google.protobuf.EnumDescriptorProto
             * @instance
             */
            EnumDescriptorProto.prototype.reservedRange = $util.emptyArray;

            /**
             * EnumDescriptorProto reservedName.
             * @member {Array.<string>} reservedName
             * @memberof google.protobuf.EnumDescriptorProto
             * @instance
             */
            EnumDescriptorProto.prototype.reservedName = $util.emptyArray;

            /**
             * EnumDescriptorProto visibility.
             * @member {google.protobuf.SymbolVisibility} visibility
             * @memberof google.protobuf.EnumDescriptorProto
             * @instance
             */
            EnumDescriptorProto.prototype.visibility = 0;

            /**
             * Creates a new EnumDescriptorProto instance using the specified properties.
             * @function create
             * @memberof google.protobuf.EnumDescriptorProto
             * @static
             * @param {google.protobuf.IEnumDescriptorProto=} [properties] Properties to set
             * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto instance
             */
            EnumDescriptorProto.create = function create(properties) {
                return new EnumDescriptorProto(properties);
            };

            /**
             * Encodes the specified EnumDescriptorProto message. Does not implicitly {@link google.protobuf.EnumDescriptorProto.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.EnumDescriptorProto
             * @static
             * @param {google.protobuf.IEnumDescriptorProto} message EnumDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnumDescriptorProto.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.value != null && message.value.length)
                    for (let i = 0; i < message.value.length; ++i)
                        $root.google.protobuf.EnumValueDescriptorProto.encode(message.value[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                    $root.google.protobuf.EnumOptions.encode(message.options, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.reservedRange != null && message.reservedRange.length)
                    for (let i = 0; i < message.reservedRange.length; ++i)
                        $root.google.protobuf.EnumDescriptorProto.EnumReservedRange.encode(message.reservedRange[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.reservedName != null && message.reservedName.length)
                    for (let i = 0; i < message.reservedName.length; ++i)
                        writer.uint32(/* id 5, wireType 2 =*/42).string(message.reservedName[i]);
                if (message.visibility != null && Object.hasOwnProperty.call(message, "visibility"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int32(message.visibility);
                return writer;
            };

            /**
             * Encodes the specified EnumDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.EnumDescriptorProto.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.EnumDescriptorProto
             * @static
             * @param {google.protobuf.IEnumDescriptorProto} message EnumDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnumDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an EnumDescriptorProto message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.EnumDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnumDescriptorProto.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumDescriptorProto();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.name = reader.string();
                            break;
                        }
                    case 2: {
                            if (!(message.value && message.value.length))
                                message.value = [];
                            message.value.push($root.google.protobuf.EnumValueDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        }
                    case 3: {
                            message.options = $root.google.protobuf.EnumOptions.decode(reader, reader.uint32());
                            break;
                        }
                    case 4: {
                            if (!(message.reservedRange && message.reservedRange.length))
                                message.reservedRange = [];
                            message.reservedRange.push($root.google.protobuf.EnumDescriptorProto.EnumReservedRange.decode(reader, reader.uint32()));
                            break;
                        }
                    case 5: {
                            if (!(message.reservedName && message.reservedName.length))
                                message.reservedName = [];
                            message.reservedName.push(reader.string());
                            break;
                        }
                    case 6: {
                            message.visibility = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an EnumDescriptorProto message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.EnumDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnumDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an EnumDescriptorProto message.
             * @function verify
             * @memberof google.protobuf.EnumDescriptorProto
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            EnumDescriptorProto.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.value != null && message.hasOwnProperty("value")) {
                    if (!Array.isArray(message.value))
                        return "value: array expected";
                    for (let i = 0; i < message.value.length; ++i) {
                        let error = $root.google.protobuf.EnumValueDescriptorProto.verify(message.value[i]);
                        if (error)
                            return "value." + error;
                    }
                }
                if (message.options != null && message.hasOwnProperty("options")) {
                    let error = $root.google.protobuf.EnumOptions.verify(message.options);
                    if (error)
                        return "options." + error;
                }
                if (message.reservedRange != null && message.hasOwnProperty("reservedRange")) {
                    if (!Array.isArray(message.reservedRange))
                        return "reservedRange: array expected";
                    for (let i = 0; i < message.reservedRange.length; ++i) {
                        let error = $root.google.protobuf.EnumDescriptorProto.EnumReservedRange.verify(message.reservedRange[i]);
                        if (error)
                            return "reservedRange." + error;
                    }
                }
                if (message.reservedName != null && message.hasOwnProperty("reservedName")) {
                    if (!Array.isArray(message.reservedName))
                        return "reservedName: array expected";
                    for (let i = 0; i < message.reservedName.length; ++i)
                        if (!$util.isString(message.reservedName[i]))
                            return "reservedName: string[] expected";
                }
                if (message.visibility != null && message.hasOwnProperty("visibility"))
                    switch (message.visibility) {
                    default:
                        return "visibility: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                return null;
            };

            /**
             * Creates an EnumDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.EnumDescriptorProto
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto
             */
            EnumDescriptorProto.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.EnumDescriptorProto)
                    return object;
                let message = new $root.google.protobuf.EnumDescriptorProto();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.value) {
                    if (!Array.isArray(object.value))
                        throw TypeError(".google.protobuf.EnumDescriptorProto.value: array expected");
                    message.value = [];
                    for (let i = 0; i < object.value.length; ++i) {
                        if (typeof object.value[i] !== "object")
                            throw TypeError(".google.protobuf.EnumDescriptorProto.value: object expected");
                        message.value[i] = $root.google.protobuf.EnumValueDescriptorProto.fromObject(object.value[i]);
                    }
                }
                if (object.options != null) {
                    if (typeof object.options !== "object")
                        throw TypeError(".google.protobuf.EnumDescriptorProto.options: object expected");
                    message.options = $root.google.protobuf.EnumOptions.fromObject(object.options);
                }
                if (object.reservedRange) {
                    if (!Array.isArray(object.reservedRange))
                        throw TypeError(".google.protobuf.EnumDescriptorProto.reservedRange: array expected");
                    message.reservedRange = [];
                    for (let i = 0; i < object.reservedRange.length; ++i) {
                        if (typeof object.reservedRange[i] !== "object")
                            throw TypeError(".google.protobuf.EnumDescriptorProto.reservedRange: object expected");
                        message.reservedRange[i] = $root.google.protobuf.EnumDescriptorProto.EnumReservedRange.fromObject(object.reservedRange[i]);
                    }
                }
                if (object.reservedName) {
                    if (!Array.isArray(object.reservedName))
                        throw TypeError(".google.protobuf.EnumDescriptorProto.reservedName: array expected");
                    message.reservedName = [];
                    for (let i = 0; i < object.reservedName.length; ++i)
                        message.reservedName[i] = String(object.reservedName[i]);
                }
                switch (object.visibility) {
                default:
                    if (typeof object.visibility === "number") {
                        message.visibility = object.visibility;
                        break;
                    }
                    break;
                case "VISIBILITY_UNSET":
                case 0:
                    message.visibility = 0;
                    break;
                case "VISIBILITY_LOCAL":
                case 1:
                    message.visibility = 1;
                    break;
                case "VISIBILITY_EXPORT":
                case 2:
                    message.visibility = 2;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from an EnumDescriptorProto message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.EnumDescriptorProto
             * @static
             * @param {google.protobuf.EnumDescriptorProto} message EnumDescriptorProto
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            EnumDescriptorProto.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults) {
                    object.value = [];
                    object.reservedRange = [];
                    object.reservedName = [];
                }
                if (options.defaults) {
                    object.name = "";
                    object.options = null;
                    object.visibility = options.enums === String ? "VISIBILITY_UNSET" : 0;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.value && message.value.length) {
                    object.value = [];
                    for (let j = 0; j < message.value.length; ++j)
                        object.value[j] = $root.google.protobuf.EnumValueDescriptorProto.toObject(message.value[j], options);
                }
                if (message.options != null && message.hasOwnProperty("options"))
                    object.options = $root.google.protobuf.EnumOptions.toObject(message.options, options);
                if (message.reservedRange && message.reservedRange.length) {
                    object.reservedRange = [];
                    for (let j = 0; j < message.reservedRange.length; ++j)
                        object.reservedRange[j] = $root.google.protobuf.EnumDescriptorProto.EnumReservedRange.toObject(message.reservedRange[j], options);
                }
                if (message.reservedName && message.reservedName.length) {
                    object.reservedName = [];
                    for (let j = 0; j < message.reservedName.length; ++j)
                        object.reservedName[j] = message.reservedName[j];
                }
                if (message.visibility != null && message.hasOwnProperty("visibility"))
                    object.visibility = options.enums === String ? $root.google.protobuf.SymbolVisibility[message.visibility] === undefined ? message.visibility : $root.google.protobuf.SymbolVisibility[message.visibility] : message.visibility;
                return object;
            };

            /**
             * Converts this EnumDescriptorProto to JSON.
             * @function toJSON
             * @memberof google.protobuf.EnumDescriptorProto
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            EnumDescriptorProto.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for EnumDescriptorProto
             * @function getTypeUrl
             * @memberof google.protobuf.EnumDescriptorProto
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            EnumDescriptorProto.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/google.protobuf.EnumDescriptorProto";
            };

            EnumDescriptorProto.EnumReservedRange = (function() {

                /**
                 * Properties of an EnumReservedRange.
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @interface IEnumReservedRange
                 * @property {number|null} [start] EnumReservedRange start
                 * @property {number|null} [end] EnumReservedRange end
                 */

                /**
                 * Constructs a new EnumReservedRange.
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @classdesc Represents an EnumReservedRange.
                 * @implements IEnumReservedRange
                 * @constructor
                 * @param {google.protobuf.EnumDescriptorProto.IEnumReservedRange=} [properties] Properties to set
                 */
                function EnumReservedRange(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * EnumReservedRange start.
                 * @member {number} start
                 * @memberof google.protobuf.EnumDescriptorProto.EnumReservedRange
                 * @instance
                 */
                EnumReservedRange.prototype.start = 0;

                /**
                 * EnumReservedRange end.
                 * @member {number} end
                 * @memberof google.protobuf.EnumDescriptorProto.EnumReservedRange
                 * @instance
                 */
                EnumReservedRange.prototype.end = 0;

                /**
                 * Creates a new EnumReservedRange instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.EnumDescriptorProto.EnumReservedRange
                 * @static
                 * @param {google.protobuf.EnumDescriptorProto.IEnumReservedRange=} [properties] Properties to set
                 * @returns {google.protobuf.EnumDescriptorProto.EnumReservedRange} EnumReservedRange instance
                 */
                EnumReservedRange.create = function create(properties) {
                    return new EnumReservedRange(properties);
                };

                /**
                 * Encodes the specified EnumReservedRange message. Does not implicitly {@link google.protobuf.EnumDescriptorProto.EnumReservedRange.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.EnumDescriptorProto.EnumReservedRange
                 * @static
                 * @param {google.protobuf.EnumDescriptorProto.IEnumReservedRange} message EnumReservedRange message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EnumReservedRange.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.start != null && Object.hasOwnProperty.call(message, "start"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.start);
                    if (message.end != null && Object.hasOwnProperty.call(message, "end"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.end);
                    return writer;
                };

                /**
                 * Encodes the specified EnumReservedRange message, length delimited. Does not implicitly {@link google.protobuf.EnumDescriptorProto.EnumReservedRange.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.EnumDescriptorProto.EnumReservedRange
                 * @static
                 * @param {google.protobuf.EnumDescriptorProto.IEnumReservedRange} message EnumReservedRange message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EnumReservedRange.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an EnumReservedRange message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.EnumDescriptorProto.EnumReservedRange
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.EnumDescriptorProto.EnumReservedRange} EnumReservedRange
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EnumReservedRange.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumDescriptorProto.EnumReservedRange();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                message.start = reader.int32();
                                break;
                            }
                        case 2: {
                                message.end = reader.int32();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an EnumReservedRange message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.EnumDescriptorProto.EnumReservedRange
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.EnumDescriptorProto.EnumReservedRange} EnumReservedRange
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EnumReservedRange.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an EnumReservedRange message.
                 * @function verify
                 * @memberof google.protobuf.EnumDescriptorProto.EnumReservedRange
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                EnumReservedRange.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.start != null && message.hasOwnProperty("start"))
                        if (!$util.isInteger(message.start))
                            return "start: integer expected";
                    if (message.end != null && message.hasOwnProperty("end"))
                        if (!$util.isInteger(message.end))
                            return "end: integer expected";
                    return null;
                };

                /**
                 * Creates an EnumReservedRange message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.EnumDescriptorProto.EnumReservedRange
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.EnumDescriptorProto.EnumReservedRange} EnumReservedRange
                 */
                EnumReservedRange.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.EnumDescriptorProto.EnumReservedRange)
                        return object;
                    let message = new $root.google.protobuf.EnumDescriptorProto.EnumReservedRange();
                    if (object.start != null)
                        message.start = object.start | 0;
                    if (object.end != null)
                        message.end = object.end | 0;
                    return message;
                };

                /**
                 * Creates a plain object from an EnumReservedRange message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.EnumDescriptorProto.EnumReservedRange
                 * @static
                 * @param {google.protobuf.EnumDescriptorProto.EnumReservedRange} message EnumReservedRange
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                EnumReservedRange.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.start = 0;
                        object.end = 0;
                    }
                    if (message.start != null && message.hasOwnProperty("start"))
                        object.start = message.start;
                    if (message.end != null && message.hasOwnProperty("end"))
                        object.end = message.end;
                    return object;
                };

                /**
                 * Converts this EnumReservedRange to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.EnumDescriptorProto.EnumReservedRange
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                EnumReservedRange.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for EnumReservedRange
                 * @function getTypeUrl
                 * @memberof google.protobuf.EnumDescriptorProto.EnumReservedRange
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                EnumReservedRange.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/google.protobuf.EnumDescriptorProto.EnumReservedRange";
                };

                return EnumReservedRange;
            })();

            return EnumDescriptorProto;
        })();

        protobuf.EnumValueDescriptorProto = (function() {

            /**
             * Properties of an EnumValueDescriptorProto.
             * @memberof google.protobuf
             * @interface IEnumValueDescriptorProto
             * @property {string|null} [name] EnumValueDescriptorProto name
             * @property {number|null} [number] EnumValueDescriptorProto number
             * @property {google.protobuf.IEnumValueOptions|null} [options] EnumValueDescriptorProto options
             */

            /**
             * Constructs a new EnumValueDescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents an EnumValueDescriptorProto.
             * @implements IEnumValueDescriptorProto
             * @constructor
             * @param {google.protobuf.IEnumValueDescriptorProto=} [properties] Properties to set
             */
            function EnumValueDescriptorProto(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * EnumValueDescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @instance
             */
            EnumValueDescriptorProto.prototype.name = "";

            /**
             * EnumValueDescriptorProto number.
             * @member {number} number
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @instance
             */
            EnumValueDescriptorProto.prototype.number = 0;

            /**
             * EnumValueDescriptorProto options.
             * @member {google.protobuf.IEnumValueOptions|null|undefined} options
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @instance
             */
            EnumValueDescriptorProto.prototype.options = null;

            /**
             * Creates a new EnumValueDescriptorProto instance using the specified properties.
             * @function create
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @static
             * @param {google.protobuf.IEnumValueDescriptorProto=} [properties] Properties to set
             * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto instance
             */
            EnumValueDescriptorProto.create = function create(properties) {
                return new EnumValueDescriptorProto(properties);
            };

            /**
             * Encodes the specified EnumValueDescriptorProto message. Does not implicitly {@link google.protobuf.EnumValueDescriptorProto.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @static
             * @param {google.protobuf.IEnumValueDescriptorProto} message EnumValueDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnumValueDescriptorProto.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.number != null && Object.hasOwnProperty.call(message, "number"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.number);
                if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                    $root.google.protobuf.EnumValueOptions.encode(message.options, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified EnumValueDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.EnumValueDescriptorProto.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @static
             * @param {google.protobuf.IEnumValueDescriptorProto} message EnumValueDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnumValueDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an EnumValueDescriptorProto message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnumValueDescriptorProto.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumValueDescriptorProto();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.name = reader.string();
                            break;
                        }
                    case 2: {
                            message.number = reader.int32();
                            break;
                        }
                    case 3: {
                            message.options = $root.google.protobuf.EnumValueOptions.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an EnumValueDescriptorProto message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnumValueDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an EnumValueDescriptorProto message.
             * @function verify
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            EnumValueDescriptorProto.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.number != null && message.hasOwnProperty("number"))
                    if (!$util.isInteger(message.number))
                        return "number: integer expected";
                if (message.options != null && message.hasOwnProperty("options")) {
                    let error = $root.google.protobuf.EnumValueOptions.verify(message.options);
                    if (error)
                        return "options." + error;
                }
                return null;
            };

            /**
             * Creates an EnumValueDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto
             */
            EnumValueDescriptorProto.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.EnumValueDescriptorProto)
                    return object;
                let message = new $root.google.protobuf.EnumValueDescriptorProto();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.number != null)
                    message.number = object.number | 0;
                if (object.options != null) {
                    if (typeof object.options !== "object")
                        throw TypeError(".google.protobuf.EnumValueDescriptorProto.options: object expected");
                    message.options = $root.google.protobuf.EnumValueOptions.fromObject(object.options);
                }
                return message;
            };

            /**
             * Creates a plain object from an EnumValueDescriptorProto message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @static
             * @param {google.protobuf.EnumValueDescriptorProto} message EnumValueDescriptorProto
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            EnumValueDescriptorProto.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.name = "";
                    object.number = 0;
                    object.options = null;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.number != null && message.hasOwnProperty("number"))
                    object.number = message.number;
                if (message.options != null && message.hasOwnProperty("options"))
                    object.options = $root.google.protobuf.EnumValueOptions.toObject(message.options, options);
                return object;
            };

            /**
             * Converts this EnumValueDescriptorProto to JSON.
             * @function toJSON
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            EnumValueDescriptorProto.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for EnumValueDescriptorProto
             * @function getTypeUrl
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            EnumValueDescriptorProto.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/google.protobuf.EnumValueDescriptorProto";
            };

            return EnumValueDescriptorProto;
        })();

        protobuf.ServiceDescriptorProto = (function() {

            /**
             * Properties of a ServiceDescriptorProto.
             * @memberof google.protobuf
             * @interface IServiceDescriptorProto
             * @property {string|null} [name] ServiceDescriptorProto name
             * @property {Array.<google.protobuf.IMethodDescriptorProto>|null} [method] ServiceDescriptorProto method
             * @property {google.protobuf.IServiceOptions|null} [options] ServiceDescriptorProto options
             */

            /**
             * Constructs a new ServiceDescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents a ServiceDescriptorProto.
             * @implements IServiceDescriptorProto
             * @constructor
             * @param {google.protobuf.IServiceDescriptorProto=} [properties] Properties to set
             */
            function ServiceDescriptorProto(properties) {
                this.method = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ServiceDescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.ServiceDescriptorProto
             * @instance
             */
            ServiceDescriptorProto.prototype.name = "";

            /**
             * ServiceDescriptorProto method.
             * @member {Array.<google.protobuf.IMethodDescriptorProto>} method
             * @memberof google.protobuf.ServiceDescriptorProto
             * @instance
             */
            ServiceDescriptorProto.prototype.method = $util.emptyArray;

            /**
             * ServiceDescriptorProto options.
             * @member {google.protobuf.IServiceOptions|null|undefined} options
             * @memberof google.protobuf.ServiceDescriptorProto
             * @instance
             */
            ServiceDescriptorProto.prototype.options = null;

            /**
             * Creates a new ServiceDescriptorProto instance using the specified properties.
             * @function create
             * @memberof google.protobuf.ServiceDescriptorProto
             * @static
             * @param {google.protobuf.IServiceDescriptorProto=} [properties] Properties to set
             * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto instance
             */
            ServiceDescriptorProto.create = function create(properties) {
                return new ServiceDescriptorProto(properties);
            };

            /**
             * Encodes the specified ServiceDescriptorProto message. Does not implicitly {@link google.protobuf.ServiceDescriptorProto.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.ServiceDescriptorProto
             * @static
             * @param {google.protobuf.IServiceDescriptorProto} message ServiceDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ServiceDescriptorProto.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.method != null && message.method.length)
                    for (let i = 0; i < message.method.length; ++i)
                        $root.google.protobuf.MethodDescriptorProto.encode(message.method[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                    $root.google.protobuf.ServiceOptions.encode(message.options, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ServiceDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.ServiceDescriptorProto.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.ServiceDescriptorProto
             * @static
             * @param {google.protobuf.IServiceDescriptorProto} message ServiceDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ServiceDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ServiceDescriptorProto message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.ServiceDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ServiceDescriptorProto.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.ServiceDescriptorProto();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.name = reader.string();
                            break;
                        }
                    case 2: {
                            if (!(message.method && message.method.length))
                                message.method = [];
                            message.method.push($root.google.protobuf.MethodDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        }
                    case 3: {
                            message.options = $root.google.protobuf.ServiceOptions.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ServiceDescriptorProto message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.ServiceDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ServiceDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ServiceDescriptorProto message.
             * @function verify
             * @memberof google.protobuf.ServiceDescriptorProto
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ServiceDescriptorProto.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.method != null && message.hasOwnProperty("method")) {
                    if (!Array.isArray(message.method))
                        return "method: array expected";
                    for (let i = 0; i < message.method.length; ++i) {
                        let error = $root.google.protobuf.MethodDescriptorProto.verify(message.method[i]);
                        if (error)
                            return "method." + error;
                    }
                }
                if (message.options != null && message.hasOwnProperty("options")) {
                    let error = $root.google.protobuf.ServiceOptions.verify(message.options);
                    if (error)
                        return "options." + error;
                }
                return null;
            };

            /**
             * Creates a ServiceDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.ServiceDescriptorProto
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto
             */
            ServiceDescriptorProto.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.ServiceDescriptorProto)
                    return object;
                let message = new $root.google.protobuf.ServiceDescriptorProto();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.method) {
                    if (!Array.isArray(object.method))
                        throw TypeError(".google.protobuf.ServiceDescriptorProto.method: array expected");
                    message.method = [];
                    for (let i = 0; i < object.method.length; ++i) {
                        if (typeof object.method[i] !== "object")
                            throw TypeError(".google.protobuf.ServiceDescriptorProto.method: object expected");
                        message.method[i] = $root.google.protobuf.MethodDescriptorProto.fromObject(object.method[i]);
                    }
                }
                if (object.options != null) {
                    if (typeof object.options !== "object")
                        throw TypeError(".google.protobuf.ServiceDescriptorProto.options: object expected");
                    message.options = $root.google.protobuf.ServiceOptions.fromObject(object.options);
                }
                return message;
            };

            /**
             * Creates a plain object from a ServiceDescriptorProto message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.ServiceDescriptorProto
             * @static
             * @param {google.protobuf.ServiceDescriptorProto} message ServiceDescriptorProto
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ServiceDescriptorProto.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.method = [];
                if (options.defaults) {
                    object.name = "";
                    object.options = null;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.method && message.method.length) {
                    object.method = [];
                    for (let j = 0; j < message.method.length; ++j)
                        object.method[j] = $root.google.protobuf.MethodDescriptorProto.toObject(message.method[j], options);
                }
                if (message.options != null && message.hasOwnProperty("options"))
                    object.options = $root.google.protobuf.ServiceOptions.toObject(message.options, options);
                return object;
            };

            /**
             * Converts this ServiceDescriptorProto to JSON.
             * @function toJSON
             * @memberof google.protobuf.ServiceDescriptorProto
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ServiceDescriptorProto.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ServiceDescriptorProto
             * @function getTypeUrl
             * @memberof google.protobuf.ServiceDescriptorProto
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ServiceDescriptorProto.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/google.protobuf.ServiceDescriptorProto";
            };

            return ServiceDescriptorProto;
        })();

        protobuf.MethodDescriptorProto = (function() {

            /**
             * Properties of a MethodDescriptorProto.
             * @memberof google.protobuf
             * @interface IMethodDescriptorProto
             * @property {string|null} [name] MethodDescriptorProto name
             * @property {string|null} [inputType] MethodDescriptorProto inputType
             * @property {string|null} [outputType] MethodDescriptorProto outputType
             * @property {google.protobuf.IMethodOptions|null} [options] MethodDescriptorProto options
             * @property {boolean|null} [clientStreaming] MethodDescriptorProto clientStreaming
             * @property {boolean|null} [serverStreaming] MethodDescriptorProto serverStreaming
             */

            /**
             * Constructs a new MethodDescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents a MethodDescriptorProto.
             * @implements IMethodDescriptorProto
             * @constructor
             * @param {google.protobuf.IMethodDescriptorProto=} [properties] Properties to set
             */
            function MethodDescriptorProto(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MethodDescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.MethodDescriptorProto
             * @instance
             */
            MethodDescriptorProto.prototype.name = "";

            /**
             * MethodDescriptorProto inputType.
             * @member {string} inputType
             * @memberof google.protobuf.MethodDescriptorProto
             * @instance
             */
            MethodDescriptorProto.prototype.inputType = "";

            /**
             * MethodDescriptorProto outputType.
             * @member {string} outputType
             * @memberof google.protobuf.MethodDescriptorProto
             * @instance
             */
            MethodDescriptorProto.prototype.outputType = "";

            /**
             * MethodDescriptorProto options.
             * @member {google.protobuf.IMethodOptions|null|undefined} options
             * @memberof google.protobuf.MethodDescriptorProto
             * @instance
             */
            MethodDescriptorProto.prototype.options = null;

            /**
             * MethodDescriptorProto clientStreaming.
             * @member {boolean} clientStreaming
             * @memberof google.protobuf.MethodDescriptorProto
             * @instance
             */
            MethodDescriptorProto.prototype.clientStreaming = false;

            /**
             * MethodDescriptorProto serverStreaming.
             * @member {boolean} serverStreaming
             * @memberof google.protobuf.MethodDescriptorProto
             * @instance
             */
            MethodDescriptorProto.prototype.serverStreaming = false;

            /**
             * Creates a new MethodDescriptorProto instance using the specified properties.
             * @function create
             * @memberof google.protobuf.MethodDescriptorProto
             * @static
             * @param {google.protobuf.IMethodDescriptorProto=} [properties] Properties to set
             * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto instance
             */
            MethodDescriptorProto.create = function create(properties) {
                return new MethodDescriptorProto(properties);
            };

            /**
             * Encodes the specified MethodDescriptorProto message. Does not implicitly {@link google.protobuf.MethodDescriptorProto.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.MethodDescriptorProto
             * @static
             * @param {google.protobuf.IMethodDescriptorProto} message MethodDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MethodDescriptorProto.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.inputType != null && Object.hasOwnProperty.call(message, "inputType"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.inputType);
                if (message.outputType != null && Object.hasOwnProperty.call(message, "outputType"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.outputType);
                if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                    $root.google.protobuf.MethodOptions.encode(message.options, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.clientStreaming != null && Object.hasOwnProperty.call(message, "clientStreaming"))
                    writer.uint32(/* id 5, wireType 0 =*/40).bool(message.clientStreaming);
                if (message.serverStreaming != null && Object.hasOwnProperty.call(message, "serverStreaming"))
                    writer.uint32(/* id 6, wireType 0 =*/48).bool(message.serverStreaming);
                return writer;
            };

            /**
             * Encodes the specified MethodDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.MethodDescriptorProto.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.MethodDescriptorProto
             * @static
             * @param {google.protobuf.IMethodDescriptorProto} message MethodDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MethodDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MethodDescriptorProto message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.MethodDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MethodDescriptorProto.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.MethodDescriptorProto();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.name = reader.string();
                            break;
                        }
                    case 2: {
                            message.inputType = reader.string();
                            break;
                        }
                    case 3: {
                            message.outputType = reader.string();
                            break;
                        }
                    case 4: {
                            message.options = $root.google.protobuf.MethodOptions.decode(reader, reader.uint32());
                            break;
                        }
                    case 5: {
                            message.clientStreaming = reader.bool();
                            break;
                        }
                    case 6: {
                            message.serverStreaming = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MethodDescriptorProto message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.MethodDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MethodDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MethodDescriptorProto message.
             * @function verify
             * @memberof google.protobuf.MethodDescriptorProto
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MethodDescriptorProto.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.inputType != null && message.hasOwnProperty("inputType"))
                    if (!$util.isString(message.inputType))
                        return "inputType: string expected";
                if (message.outputType != null && message.hasOwnProperty("outputType"))
                    if (!$util.isString(message.outputType))
                        return "outputType: string expected";
                if (message.options != null && message.hasOwnProperty("options")) {
                    let error = $root.google.protobuf.MethodOptions.verify(message.options);
                    if (error)
                        return "options." + error;
                }
                if (message.clientStreaming != null && message.hasOwnProperty("clientStreaming"))
                    if (typeof message.clientStreaming !== "boolean")
                        return "clientStreaming: boolean expected";
                if (message.serverStreaming != null && message.hasOwnProperty("serverStreaming"))
                    if (typeof message.serverStreaming !== "boolean")
                        return "serverStreaming: boolean expected";
                return null;
            };

            /**
             * Creates a MethodDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.MethodDescriptorProto
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto
             */
            MethodDescriptorProto.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.MethodDescriptorProto)
                    return object;
                let message = new $root.google.protobuf.MethodDescriptorProto();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.inputType != null)
                    message.inputType = String(object.inputType);
                if (object.outputType != null)
                    message.outputType = String(object.outputType);
                if (object.options != null) {
                    if (typeof object.options !== "object")
                        throw TypeError(".google.protobuf.MethodDescriptorProto.options: object expected");
                    message.options = $root.google.protobuf.MethodOptions.fromObject(object.options);
                }
                if (object.clientStreaming != null)
                    message.clientStreaming = Boolean(object.clientStreaming);
                if (object.serverStreaming != null)
                    message.serverStreaming = Boolean(object.serverStreaming);
                return message;
            };

            /**
             * Creates a plain object from a MethodDescriptorProto message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.MethodDescriptorProto
             * @static
             * @param {google.protobuf.MethodDescriptorProto} message MethodDescriptorProto
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MethodDescriptorProto.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.name = "";
                    object.inputType = "";
                    object.outputType = "";
                    object.options = null;
                    object.clientStreaming = false;
                    object.serverStreaming = false;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.inputType != null && message.hasOwnProperty("inputType"))
                    object.inputType = message.inputType;
                if (message.outputType != null && message.hasOwnProperty("outputType"))
                    object.outputType = message.outputType;
                if (message.options != null && message.hasOwnProperty("options"))
                    object.options = $root.google.protobuf.MethodOptions.toObject(message.options, options);
                if (message.clientStreaming != null && message.hasOwnProperty("clientStreaming"))
                    object.clientStreaming = message.clientStreaming;
                if (message.serverStreaming != null && message.hasOwnProperty("serverStreaming"))
                    object.serverStreaming = message.serverStreaming;
                return object;
            };

            /**
             * Converts this MethodDescriptorProto to JSON.
             * @function toJSON
             * @memberof google.protobuf.MethodDescriptorProto
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MethodDescriptorProto.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for MethodDescriptorProto
             * @function getTypeUrl
             * @memberof google.protobuf.MethodDescriptorProto
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            MethodDescriptorProto.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/google.protobuf.MethodDescriptorProto";
            };

            return MethodDescriptorProto;
        })();

        protobuf.FileOptions = (function() {

            /**
             * Properties of a FileOptions.
             * @memberof google.protobuf
             * @interface IFileOptions
             * @property {string|null} [javaPackage] FileOptions javaPackage
             * @property {string|null} [javaOuterClassname] FileOptions javaOuterClassname
             * @property {boolean|null} [javaMultipleFiles] FileOptions javaMultipleFiles
             * @property {boolean|null} [javaGenerateEqualsAndHash] FileOptions javaGenerateEqualsAndHash
             * @property {boolean|null} [javaStringCheckUtf8] FileOptions javaStringCheckUtf8
             * @property {google.protobuf.FileOptions.OptimizeMode|null} [optimizeFor] FileOptions optimizeFor
             * @property {string|null} [goPackage] FileOptions goPackage
             * @property {boolean|null} [ccGenericServices] FileOptions ccGenericServices
             * @property {boolean|null} [javaGenericServices] FileOptions javaGenericServices
             * @property {boolean|null} [pyGenericServices] FileOptions pyGenericServices
             * @property {boolean|null} [deprecated] FileOptions deprecated
             * @property {boolean|null} [ccEnableArenas] FileOptions ccEnableArenas
             * @property {string|null} [objcClassPrefix] FileOptions objcClassPrefix
             * @property {string|null} [csharpNamespace] FileOptions csharpNamespace
             * @property {string|null} [swiftPrefix] FileOptions swiftPrefix
             * @property {string|null} [phpClassPrefix] FileOptions phpClassPrefix
             * @property {string|null} [phpNamespace] FileOptions phpNamespace
             * @property {string|null} [phpMetadataNamespace] FileOptions phpMetadataNamespace
             * @property {string|null} [rubyPackage] FileOptions rubyPackage
             * @property {google.protobuf.IFeatureSet|null} [features] FileOptions features
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] FileOptions uninterpretedOption
             * @property {osi3.IInterfaceVersion|null} [".osi3.currentInterfaceVersion"] FileOptions .osi3.currentInterfaceVersion
             */

            /**
             * Constructs a new FileOptions.
             * @memberof google.protobuf
             * @classdesc Represents a FileOptions.
             * @implements IFileOptions
             * @constructor
             * @param {google.protobuf.IFileOptions=} [properties] Properties to set
             */
            function FileOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FileOptions javaPackage.
             * @member {string} javaPackage
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.javaPackage = "";

            /**
             * FileOptions javaOuterClassname.
             * @member {string} javaOuterClassname
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.javaOuterClassname = "";

            /**
             * FileOptions javaMultipleFiles.
             * @member {boolean} javaMultipleFiles
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.javaMultipleFiles = false;

            /**
             * FileOptions javaGenerateEqualsAndHash.
             * @member {boolean} javaGenerateEqualsAndHash
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.javaGenerateEqualsAndHash = false;

            /**
             * FileOptions javaStringCheckUtf8.
             * @member {boolean} javaStringCheckUtf8
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.javaStringCheckUtf8 = false;

            /**
             * FileOptions optimizeFor.
             * @member {google.protobuf.FileOptions.OptimizeMode} optimizeFor
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.optimizeFor = 1;

            /**
             * FileOptions goPackage.
             * @member {string} goPackage
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.goPackage = "";

            /**
             * FileOptions ccGenericServices.
             * @member {boolean} ccGenericServices
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.ccGenericServices = false;

            /**
             * FileOptions javaGenericServices.
             * @member {boolean} javaGenericServices
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.javaGenericServices = false;

            /**
             * FileOptions pyGenericServices.
             * @member {boolean} pyGenericServices
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.pyGenericServices = false;

            /**
             * FileOptions deprecated.
             * @member {boolean} deprecated
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.deprecated = false;

            /**
             * FileOptions ccEnableArenas.
             * @member {boolean} ccEnableArenas
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.ccEnableArenas = true;

            /**
             * FileOptions objcClassPrefix.
             * @member {string} objcClassPrefix
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.objcClassPrefix = "";

            /**
             * FileOptions csharpNamespace.
             * @member {string} csharpNamespace
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.csharpNamespace = "";

            /**
             * FileOptions swiftPrefix.
             * @member {string} swiftPrefix
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.swiftPrefix = "";

            /**
             * FileOptions phpClassPrefix.
             * @member {string} phpClassPrefix
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.phpClassPrefix = "";

            /**
             * FileOptions phpNamespace.
             * @member {string} phpNamespace
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.phpNamespace = "";

            /**
             * FileOptions phpMetadataNamespace.
             * @member {string} phpMetadataNamespace
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.phpMetadataNamespace = "";

            /**
             * FileOptions rubyPackage.
             * @member {string} rubyPackage
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.rubyPackage = "";

            /**
             * FileOptions features.
             * @member {google.protobuf.IFeatureSet|null|undefined} features
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.features = null;

            /**
             * FileOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.uninterpretedOption = $util.emptyArray;

            /**
             * FileOptions .osi3.currentInterfaceVersion.
             * @member {osi3.IInterfaceVersion|null|undefined} .osi3.currentInterfaceVersion
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype[".osi3.currentInterfaceVersion"] = null;

            /**
             * Creates a new FileOptions instance using the specified properties.
             * @function create
             * @memberof google.protobuf.FileOptions
             * @static
             * @param {google.protobuf.IFileOptions=} [properties] Properties to set
             * @returns {google.protobuf.FileOptions} FileOptions instance
             */
            FileOptions.create = function create(properties) {
                return new FileOptions(properties);
            };

            /**
             * Encodes the specified FileOptions message. Does not implicitly {@link google.protobuf.FileOptions.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.FileOptions
             * @static
             * @param {google.protobuf.IFileOptions} message FileOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FileOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.javaPackage != null && Object.hasOwnProperty.call(message, "javaPackage"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.javaPackage);
                if (message.javaOuterClassname != null && Object.hasOwnProperty.call(message, "javaOuterClassname"))
                    writer.uint32(/* id 8, wireType 2 =*/66).string(message.javaOuterClassname);
                if (message.optimizeFor != null && Object.hasOwnProperty.call(message, "optimizeFor"))
                    writer.uint32(/* id 9, wireType 0 =*/72).int32(message.optimizeFor);
                if (message.javaMultipleFiles != null && Object.hasOwnProperty.call(message, "javaMultipleFiles"))
                    writer.uint32(/* id 10, wireType 0 =*/80).bool(message.javaMultipleFiles);
                if (message.goPackage != null && Object.hasOwnProperty.call(message, "goPackage"))
                    writer.uint32(/* id 11, wireType 2 =*/90).string(message.goPackage);
                if (message.ccGenericServices != null && Object.hasOwnProperty.call(message, "ccGenericServices"))
                    writer.uint32(/* id 16, wireType 0 =*/128).bool(message.ccGenericServices);
                if (message.javaGenericServices != null && Object.hasOwnProperty.call(message, "javaGenericServices"))
                    writer.uint32(/* id 17, wireType 0 =*/136).bool(message.javaGenericServices);
                if (message.pyGenericServices != null && Object.hasOwnProperty.call(message, "pyGenericServices"))
                    writer.uint32(/* id 18, wireType 0 =*/144).bool(message.pyGenericServices);
                if (message.javaGenerateEqualsAndHash != null && Object.hasOwnProperty.call(message, "javaGenerateEqualsAndHash"))
                    writer.uint32(/* id 20, wireType 0 =*/160).bool(message.javaGenerateEqualsAndHash);
                if (message.deprecated != null && Object.hasOwnProperty.call(message, "deprecated"))
                    writer.uint32(/* id 23, wireType 0 =*/184).bool(message.deprecated);
                if (message.javaStringCheckUtf8 != null && Object.hasOwnProperty.call(message, "javaStringCheckUtf8"))
                    writer.uint32(/* id 27, wireType 0 =*/216).bool(message.javaStringCheckUtf8);
                if (message.ccEnableArenas != null && Object.hasOwnProperty.call(message, "ccEnableArenas"))
                    writer.uint32(/* id 31, wireType 0 =*/248).bool(message.ccEnableArenas);
                if (message.objcClassPrefix != null && Object.hasOwnProperty.call(message, "objcClassPrefix"))
                    writer.uint32(/* id 36, wireType 2 =*/290).string(message.objcClassPrefix);
                if (message.csharpNamespace != null && Object.hasOwnProperty.call(message, "csharpNamespace"))
                    writer.uint32(/* id 37, wireType 2 =*/298).string(message.csharpNamespace);
                if (message.swiftPrefix != null && Object.hasOwnProperty.call(message, "swiftPrefix"))
                    writer.uint32(/* id 39, wireType 2 =*/314).string(message.swiftPrefix);
                if (message.phpClassPrefix != null && Object.hasOwnProperty.call(message, "phpClassPrefix"))
                    writer.uint32(/* id 40, wireType 2 =*/322).string(message.phpClassPrefix);
                if (message.phpNamespace != null && Object.hasOwnProperty.call(message, "phpNamespace"))
                    writer.uint32(/* id 41, wireType 2 =*/330).string(message.phpNamespace);
                if (message.phpMetadataNamespace != null && Object.hasOwnProperty.call(message, "phpMetadataNamespace"))
                    writer.uint32(/* id 44, wireType 2 =*/354).string(message.phpMetadataNamespace);
                if (message.rubyPackage != null && Object.hasOwnProperty.call(message, "rubyPackage"))
                    writer.uint32(/* id 45, wireType 2 =*/362).string(message.rubyPackage);
                if (message.features != null && Object.hasOwnProperty.call(message, "features"))
                    $root.google.protobuf.FeatureSet.encode(message.features, writer.uint32(/* id 50, wireType 2 =*/402).fork()).ldelim();
                if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                    for (let i = 0; i < message.uninterpretedOption.length; ++i)
                        $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                if (message[".osi3.currentInterfaceVersion"] != null && Object.hasOwnProperty.call(message, ".osi3.currentInterfaceVersion"))
                    $root.osi3.InterfaceVersion.encode(message[".osi3.currentInterfaceVersion"], writer.uint32(/* id 81000, wireType 2 =*/648002).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified FileOptions message, length delimited. Does not implicitly {@link google.protobuf.FileOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.FileOptions
             * @static
             * @param {google.protobuf.IFileOptions} message FileOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FileOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FileOptions message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.FileOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.FileOptions} FileOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FileOptions.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FileOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.javaPackage = reader.string();
                            break;
                        }
                    case 8: {
                            message.javaOuterClassname = reader.string();
                            break;
                        }
                    case 10: {
                            message.javaMultipleFiles = reader.bool();
                            break;
                        }
                    case 20: {
                            message.javaGenerateEqualsAndHash = reader.bool();
                            break;
                        }
                    case 27: {
                            message.javaStringCheckUtf8 = reader.bool();
                            break;
                        }
                    case 9: {
                            message.optimizeFor = reader.int32();
                            break;
                        }
                    case 11: {
                            message.goPackage = reader.string();
                            break;
                        }
                    case 16: {
                            message.ccGenericServices = reader.bool();
                            break;
                        }
                    case 17: {
                            message.javaGenericServices = reader.bool();
                            break;
                        }
                    case 18: {
                            message.pyGenericServices = reader.bool();
                            break;
                        }
                    case 23: {
                            message.deprecated = reader.bool();
                            break;
                        }
                    case 31: {
                            message.ccEnableArenas = reader.bool();
                            break;
                        }
                    case 36: {
                            message.objcClassPrefix = reader.string();
                            break;
                        }
                    case 37: {
                            message.csharpNamespace = reader.string();
                            break;
                        }
                    case 39: {
                            message.swiftPrefix = reader.string();
                            break;
                        }
                    case 40: {
                            message.phpClassPrefix = reader.string();
                            break;
                        }
                    case 41: {
                            message.phpNamespace = reader.string();
                            break;
                        }
                    case 44: {
                            message.phpMetadataNamespace = reader.string();
                            break;
                        }
                    case 45: {
                            message.rubyPackage = reader.string();
                            break;
                        }
                    case 50: {
                            message.features = $root.google.protobuf.FeatureSet.decode(reader, reader.uint32());
                            break;
                        }
                    case 999: {
                            if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                                message.uninterpretedOption = [];
                            message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                            break;
                        }
                    case 81000: {
                            message[".osi3.currentInterfaceVersion"] = $root.osi3.InterfaceVersion.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FileOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.FileOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.FileOptions} FileOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FileOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FileOptions message.
             * @function verify
             * @memberof google.protobuf.FileOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FileOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.javaPackage != null && message.hasOwnProperty("javaPackage"))
                    if (!$util.isString(message.javaPackage))
                        return "javaPackage: string expected";
                if (message.javaOuterClassname != null && message.hasOwnProperty("javaOuterClassname"))
                    if (!$util.isString(message.javaOuterClassname))
                        return "javaOuterClassname: string expected";
                if (message.javaMultipleFiles != null && message.hasOwnProperty("javaMultipleFiles"))
                    if (typeof message.javaMultipleFiles !== "boolean")
                        return "javaMultipleFiles: boolean expected";
                if (message.javaGenerateEqualsAndHash != null && message.hasOwnProperty("javaGenerateEqualsAndHash"))
                    if (typeof message.javaGenerateEqualsAndHash !== "boolean")
                        return "javaGenerateEqualsAndHash: boolean expected";
                if (message.javaStringCheckUtf8 != null && message.hasOwnProperty("javaStringCheckUtf8"))
                    if (typeof message.javaStringCheckUtf8 !== "boolean")
                        return "javaStringCheckUtf8: boolean expected";
                if (message.optimizeFor != null && message.hasOwnProperty("optimizeFor"))
                    switch (message.optimizeFor) {
                    default:
                        return "optimizeFor: enum value expected";
                    case 1:
                    case 2:
                    case 3:
                        break;
                    }
                if (message.goPackage != null && message.hasOwnProperty("goPackage"))
                    if (!$util.isString(message.goPackage))
                        return "goPackage: string expected";
                if (message.ccGenericServices != null && message.hasOwnProperty("ccGenericServices"))
                    if (typeof message.ccGenericServices !== "boolean")
                        return "ccGenericServices: boolean expected";
                if (message.javaGenericServices != null && message.hasOwnProperty("javaGenericServices"))
                    if (typeof message.javaGenericServices !== "boolean")
                        return "javaGenericServices: boolean expected";
                if (message.pyGenericServices != null && message.hasOwnProperty("pyGenericServices"))
                    if (typeof message.pyGenericServices !== "boolean")
                        return "pyGenericServices: boolean expected";
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    if (typeof message.deprecated !== "boolean")
                        return "deprecated: boolean expected";
                if (message.ccEnableArenas != null && message.hasOwnProperty("ccEnableArenas"))
                    if (typeof message.ccEnableArenas !== "boolean")
                        return "ccEnableArenas: boolean expected";
                if (message.objcClassPrefix != null && message.hasOwnProperty("objcClassPrefix"))
                    if (!$util.isString(message.objcClassPrefix))
                        return "objcClassPrefix: string expected";
                if (message.csharpNamespace != null && message.hasOwnProperty("csharpNamespace"))
                    if (!$util.isString(message.csharpNamespace))
                        return "csharpNamespace: string expected";
                if (message.swiftPrefix != null && message.hasOwnProperty("swiftPrefix"))
                    if (!$util.isString(message.swiftPrefix))
                        return "swiftPrefix: string expected";
                if (message.phpClassPrefix != null && message.hasOwnProperty("phpClassPrefix"))
                    if (!$util.isString(message.phpClassPrefix))
                        return "phpClassPrefix: string expected";
                if (message.phpNamespace != null && message.hasOwnProperty("phpNamespace"))
                    if (!$util.isString(message.phpNamespace))
                        return "phpNamespace: string expected";
                if (message.phpMetadataNamespace != null && message.hasOwnProperty("phpMetadataNamespace"))
                    if (!$util.isString(message.phpMetadataNamespace))
                        return "phpMetadataNamespace: string expected";
                if (message.rubyPackage != null && message.hasOwnProperty("rubyPackage"))
                    if (!$util.isString(message.rubyPackage))
                        return "rubyPackage: string expected";
                if (message.features != null && message.hasOwnProperty("features")) {
                    let error = $root.google.protobuf.FeatureSet.verify(message.features);
                    if (error)
                        return "features." + error;
                }
                if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                    if (!Array.isArray(message.uninterpretedOption))
                        return "uninterpretedOption: array expected";
                    for (let i = 0; i < message.uninterpretedOption.length; ++i) {
                        let error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                        if (error)
                            return "uninterpretedOption." + error;
                    }
                }
                if (message[".osi3.currentInterfaceVersion"] != null && message.hasOwnProperty(".osi3.currentInterfaceVersion")) {
                    let error = $root.osi3.InterfaceVersion.verify(message[".osi3.currentInterfaceVersion"]);
                    if (error)
                        return ".osi3.currentInterfaceVersion." + error;
                }
                return null;
            };

            /**
             * Creates a FileOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.FileOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.FileOptions} FileOptions
             */
            FileOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.FileOptions)
                    return object;
                let message = new $root.google.protobuf.FileOptions();
                if (object.javaPackage != null)
                    message.javaPackage = String(object.javaPackage);
                if (object.javaOuterClassname != null)
                    message.javaOuterClassname = String(object.javaOuterClassname);
                if (object.javaMultipleFiles != null)
                    message.javaMultipleFiles = Boolean(object.javaMultipleFiles);
                if (object.javaGenerateEqualsAndHash != null)
                    message.javaGenerateEqualsAndHash = Boolean(object.javaGenerateEqualsAndHash);
                if (object.javaStringCheckUtf8 != null)
                    message.javaStringCheckUtf8 = Boolean(object.javaStringCheckUtf8);
                switch (object.optimizeFor) {
                default:
                    if (typeof object.optimizeFor === "number") {
                        message.optimizeFor = object.optimizeFor;
                        break;
                    }
                    break;
                case "SPEED":
                case 1:
                    message.optimizeFor = 1;
                    break;
                case "CODE_SIZE":
                case 2:
                    message.optimizeFor = 2;
                    break;
                case "LITE_RUNTIME":
                case 3:
                    message.optimizeFor = 3;
                    break;
                }
                if (object.goPackage != null)
                    message.goPackage = String(object.goPackage);
                if (object.ccGenericServices != null)
                    message.ccGenericServices = Boolean(object.ccGenericServices);
                if (object.javaGenericServices != null)
                    message.javaGenericServices = Boolean(object.javaGenericServices);
                if (object.pyGenericServices != null)
                    message.pyGenericServices = Boolean(object.pyGenericServices);
                if (object.deprecated != null)
                    message.deprecated = Boolean(object.deprecated);
                if (object.ccEnableArenas != null)
                    message.ccEnableArenas = Boolean(object.ccEnableArenas);
                if (object.objcClassPrefix != null)
                    message.objcClassPrefix = String(object.objcClassPrefix);
                if (object.csharpNamespace != null)
                    message.csharpNamespace = String(object.csharpNamespace);
                if (object.swiftPrefix != null)
                    message.swiftPrefix = String(object.swiftPrefix);
                if (object.phpClassPrefix != null)
                    message.phpClassPrefix = String(object.phpClassPrefix);
                if (object.phpNamespace != null)
                    message.phpNamespace = String(object.phpNamespace);
                if (object.phpMetadataNamespace != null)
                    message.phpMetadataNamespace = String(object.phpMetadataNamespace);
                if (object.rubyPackage != null)
                    message.rubyPackage = String(object.rubyPackage);
                if (object.features != null) {
                    if (typeof object.features !== "object")
                        throw TypeError(".google.protobuf.FileOptions.features: object expected");
                    message.features = $root.google.protobuf.FeatureSet.fromObject(object.features);
                }
                if (object.uninterpretedOption) {
                    if (!Array.isArray(object.uninterpretedOption))
                        throw TypeError(".google.protobuf.FileOptions.uninterpretedOption: array expected");
                    message.uninterpretedOption = [];
                    for (let i = 0; i < object.uninterpretedOption.length; ++i) {
                        if (typeof object.uninterpretedOption[i] !== "object")
                            throw TypeError(".google.protobuf.FileOptions.uninterpretedOption: object expected");
                        message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
                    }
                }
                if (object[".osi3.currentInterfaceVersion"] != null) {
                    if (typeof object[".osi3.currentInterfaceVersion"] !== "object")
                        throw TypeError(".google.protobuf.FileOptions..osi3.currentInterfaceVersion: object expected");
                    message[".osi3.currentInterfaceVersion"] = $root.osi3.InterfaceVersion.fromObject(object[".osi3.currentInterfaceVersion"]);
                }
                return message;
            };

            /**
             * Creates a plain object from a FileOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.FileOptions
             * @static
             * @param {google.protobuf.FileOptions} message FileOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FileOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.uninterpretedOption = [];
                if (options.defaults) {
                    object.javaPackage = "";
                    object.javaOuterClassname = "";
                    object.optimizeFor = options.enums === String ? "SPEED" : 1;
                    object.javaMultipleFiles = false;
                    object.goPackage = "";
                    object.ccGenericServices = false;
                    object.javaGenericServices = false;
                    object.pyGenericServices = false;
                    object.javaGenerateEqualsAndHash = false;
                    object.deprecated = false;
                    object.javaStringCheckUtf8 = false;
                    object.ccEnableArenas = true;
                    object.objcClassPrefix = "";
                    object.csharpNamespace = "";
                    object.swiftPrefix = "";
                    object.phpClassPrefix = "";
                    object.phpNamespace = "";
                    object.phpMetadataNamespace = "";
                    object.rubyPackage = "";
                    object.features = null;
                    object[".osi3.currentInterfaceVersion"] = null;
                }
                if (message.javaPackage != null && message.hasOwnProperty("javaPackage"))
                    object.javaPackage = message.javaPackage;
                if (message.javaOuterClassname != null && message.hasOwnProperty("javaOuterClassname"))
                    object.javaOuterClassname = message.javaOuterClassname;
                if (message.optimizeFor != null && message.hasOwnProperty("optimizeFor"))
                    object.optimizeFor = options.enums === String ? $root.google.protobuf.FileOptions.OptimizeMode[message.optimizeFor] === undefined ? message.optimizeFor : $root.google.protobuf.FileOptions.OptimizeMode[message.optimizeFor] : message.optimizeFor;
                if (message.javaMultipleFiles != null && message.hasOwnProperty("javaMultipleFiles"))
                    object.javaMultipleFiles = message.javaMultipleFiles;
                if (message.goPackage != null && message.hasOwnProperty("goPackage"))
                    object.goPackage = message.goPackage;
                if (message.ccGenericServices != null && message.hasOwnProperty("ccGenericServices"))
                    object.ccGenericServices = message.ccGenericServices;
                if (message.javaGenericServices != null && message.hasOwnProperty("javaGenericServices"))
                    object.javaGenericServices = message.javaGenericServices;
                if (message.pyGenericServices != null && message.hasOwnProperty("pyGenericServices"))
                    object.pyGenericServices = message.pyGenericServices;
                if (message.javaGenerateEqualsAndHash != null && message.hasOwnProperty("javaGenerateEqualsAndHash"))
                    object.javaGenerateEqualsAndHash = message.javaGenerateEqualsAndHash;
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    object.deprecated = message.deprecated;
                if (message.javaStringCheckUtf8 != null && message.hasOwnProperty("javaStringCheckUtf8"))
                    object.javaStringCheckUtf8 = message.javaStringCheckUtf8;
                if (message.ccEnableArenas != null && message.hasOwnProperty("ccEnableArenas"))
                    object.ccEnableArenas = message.ccEnableArenas;
                if (message.objcClassPrefix != null && message.hasOwnProperty("objcClassPrefix"))
                    object.objcClassPrefix = message.objcClassPrefix;
                if (message.csharpNamespace != null && message.hasOwnProperty("csharpNamespace"))
                    object.csharpNamespace = message.csharpNamespace;
                if (message.swiftPrefix != null && message.hasOwnProperty("swiftPrefix"))
                    object.swiftPrefix = message.swiftPrefix;
                if (message.phpClassPrefix != null && message.hasOwnProperty("phpClassPrefix"))
                    object.phpClassPrefix = message.phpClassPrefix;
                if (message.phpNamespace != null && message.hasOwnProperty("phpNamespace"))
                    object.phpNamespace = message.phpNamespace;
                if (message.phpMetadataNamespace != null && message.hasOwnProperty("phpMetadataNamespace"))
                    object.phpMetadataNamespace = message.phpMetadataNamespace;
                if (message.rubyPackage != null && message.hasOwnProperty("rubyPackage"))
                    object.rubyPackage = message.rubyPackage;
                if (message.features != null && message.hasOwnProperty("features"))
                    object.features = $root.google.protobuf.FeatureSet.toObject(message.features, options);
                if (message.uninterpretedOption && message.uninterpretedOption.length) {
                    object.uninterpretedOption = [];
                    for (let j = 0; j < message.uninterpretedOption.length; ++j)
                        object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
                }
                if (message[".osi3.currentInterfaceVersion"] != null && message.hasOwnProperty(".osi3.currentInterfaceVersion"))
                    object[".osi3.currentInterfaceVersion"] = $root.osi3.InterfaceVersion.toObject(message[".osi3.currentInterfaceVersion"], options);
                return object;
            };

            /**
             * Converts this FileOptions to JSON.
             * @function toJSON
             * @memberof google.protobuf.FileOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FileOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for FileOptions
             * @function getTypeUrl
             * @memberof google.protobuf.FileOptions
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            FileOptions.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/google.protobuf.FileOptions";
            };

            /**
             * OptimizeMode enum.
             * @name google.protobuf.FileOptions.OptimizeMode
             * @enum {number}
             * @property {number} SPEED=1 SPEED value
             * @property {number} CODE_SIZE=2 CODE_SIZE value
             * @property {number} LITE_RUNTIME=3 LITE_RUNTIME value
             */
            FileOptions.OptimizeMode = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[1] = "SPEED"] = 1;
                values[valuesById[2] = "CODE_SIZE"] = 2;
                values[valuesById[3] = "LITE_RUNTIME"] = 3;
                return values;
            })();

            return FileOptions;
        })();

        protobuf.MessageOptions = (function() {

            /**
             * Properties of a MessageOptions.
             * @memberof google.protobuf
             * @interface IMessageOptions
             * @property {boolean|null} [messageSetWireFormat] MessageOptions messageSetWireFormat
             * @property {boolean|null} [noStandardDescriptorAccessor] MessageOptions noStandardDescriptorAccessor
             * @property {boolean|null} [deprecated] MessageOptions deprecated
             * @property {boolean|null} [mapEntry] MessageOptions mapEntry
             * @property {boolean|null} [deprecatedLegacyJsonFieldConflicts] MessageOptions deprecatedLegacyJsonFieldConflicts
             * @property {google.protobuf.IFeatureSet|null} [features] MessageOptions features
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] MessageOptions uninterpretedOption
             */

            /**
             * Constructs a new MessageOptions.
             * @memberof google.protobuf
             * @classdesc Represents a MessageOptions.
             * @implements IMessageOptions
             * @constructor
             * @param {google.protobuf.IMessageOptions=} [properties] Properties to set
             */
            function MessageOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MessageOptions messageSetWireFormat.
             * @member {boolean} messageSetWireFormat
             * @memberof google.protobuf.MessageOptions
             * @instance
             */
            MessageOptions.prototype.messageSetWireFormat = false;

            /**
             * MessageOptions noStandardDescriptorAccessor.
             * @member {boolean} noStandardDescriptorAccessor
             * @memberof google.protobuf.MessageOptions
             * @instance
             */
            MessageOptions.prototype.noStandardDescriptorAccessor = false;

            /**
             * MessageOptions deprecated.
             * @member {boolean} deprecated
             * @memberof google.protobuf.MessageOptions
             * @instance
             */
            MessageOptions.prototype.deprecated = false;

            /**
             * MessageOptions mapEntry.
             * @member {boolean} mapEntry
             * @memberof google.protobuf.MessageOptions
             * @instance
             */
            MessageOptions.prototype.mapEntry = false;

            /**
             * MessageOptions deprecatedLegacyJsonFieldConflicts.
             * @member {boolean} deprecatedLegacyJsonFieldConflicts
             * @memberof google.protobuf.MessageOptions
             * @instance
             */
            MessageOptions.prototype.deprecatedLegacyJsonFieldConflicts = false;

            /**
             * MessageOptions features.
             * @member {google.protobuf.IFeatureSet|null|undefined} features
             * @memberof google.protobuf.MessageOptions
             * @instance
             */
            MessageOptions.prototype.features = null;

            /**
             * MessageOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.MessageOptions
             * @instance
             */
            MessageOptions.prototype.uninterpretedOption = $util.emptyArray;

            /**
             * Creates a new MessageOptions instance using the specified properties.
             * @function create
             * @memberof google.protobuf.MessageOptions
             * @static
             * @param {google.protobuf.IMessageOptions=} [properties] Properties to set
             * @returns {google.protobuf.MessageOptions} MessageOptions instance
             */
            MessageOptions.create = function create(properties) {
                return new MessageOptions(properties);
            };

            /**
             * Encodes the specified MessageOptions message. Does not implicitly {@link google.protobuf.MessageOptions.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.MessageOptions
             * @static
             * @param {google.protobuf.IMessageOptions} message MessageOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MessageOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.messageSetWireFormat != null && Object.hasOwnProperty.call(message, "messageSetWireFormat"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.messageSetWireFormat);
                if (message.noStandardDescriptorAccessor != null && Object.hasOwnProperty.call(message, "noStandardDescriptorAccessor"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.noStandardDescriptorAccessor);
                if (message.deprecated != null && Object.hasOwnProperty.call(message, "deprecated"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.deprecated);
                if (message.mapEntry != null && Object.hasOwnProperty.call(message, "mapEntry"))
                    writer.uint32(/* id 7, wireType 0 =*/56).bool(message.mapEntry);
                if (message.deprecatedLegacyJsonFieldConflicts != null && Object.hasOwnProperty.call(message, "deprecatedLegacyJsonFieldConflicts"))
                    writer.uint32(/* id 11, wireType 0 =*/88).bool(message.deprecatedLegacyJsonFieldConflicts);
                if (message.features != null && Object.hasOwnProperty.call(message, "features"))
                    $root.google.protobuf.FeatureSet.encode(message.features, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
                if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                    for (let i = 0; i < message.uninterpretedOption.length; ++i)
                        $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified MessageOptions message, length delimited. Does not implicitly {@link google.protobuf.MessageOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.MessageOptions
             * @static
             * @param {google.protobuf.IMessageOptions} message MessageOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MessageOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MessageOptions message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.MessageOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.MessageOptions} MessageOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MessageOptions.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.MessageOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.messageSetWireFormat = reader.bool();
                            break;
                        }
                    case 2: {
                            message.noStandardDescriptorAccessor = reader.bool();
                            break;
                        }
                    case 3: {
                            message.deprecated = reader.bool();
                            break;
                        }
                    case 7: {
                            message.mapEntry = reader.bool();
                            break;
                        }
                    case 11: {
                            message.deprecatedLegacyJsonFieldConflicts = reader.bool();
                            break;
                        }
                    case 12: {
                            message.features = $root.google.protobuf.FeatureSet.decode(reader, reader.uint32());
                            break;
                        }
                    case 999: {
                            if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                                message.uninterpretedOption = [];
                            message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MessageOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.MessageOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.MessageOptions} MessageOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MessageOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MessageOptions message.
             * @function verify
             * @memberof google.protobuf.MessageOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MessageOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.messageSetWireFormat != null && message.hasOwnProperty("messageSetWireFormat"))
                    if (typeof message.messageSetWireFormat !== "boolean")
                        return "messageSetWireFormat: boolean expected";
                if (message.noStandardDescriptorAccessor != null && message.hasOwnProperty("noStandardDescriptorAccessor"))
                    if (typeof message.noStandardDescriptorAccessor !== "boolean")
                        return "noStandardDescriptorAccessor: boolean expected";
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    if (typeof message.deprecated !== "boolean")
                        return "deprecated: boolean expected";
                if (message.mapEntry != null && message.hasOwnProperty("mapEntry"))
                    if (typeof message.mapEntry !== "boolean")
                        return "mapEntry: boolean expected";
                if (message.deprecatedLegacyJsonFieldConflicts != null && message.hasOwnProperty("deprecatedLegacyJsonFieldConflicts"))
                    if (typeof message.deprecatedLegacyJsonFieldConflicts !== "boolean")
                        return "deprecatedLegacyJsonFieldConflicts: boolean expected";
                if (message.features != null && message.hasOwnProperty("features")) {
                    let error = $root.google.protobuf.FeatureSet.verify(message.features);
                    if (error)
                        return "features." + error;
                }
                if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                    if (!Array.isArray(message.uninterpretedOption))
                        return "uninterpretedOption: array expected";
                    for (let i = 0; i < message.uninterpretedOption.length; ++i) {
                        let error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                        if (error)
                            return "uninterpretedOption." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a MessageOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.MessageOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.MessageOptions} MessageOptions
             */
            MessageOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.MessageOptions)
                    return object;
                let message = new $root.google.protobuf.MessageOptions();
                if (object.messageSetWireFormat != null)
                    message.messageSetWireFormat = Boolean(object.messageSetWireFormat);
                if (object.noStandardDescriptorAccessor != null)
                    message.noStandardDescriptorAccessor = Boolean(object.noStandardDescriptorAccessor);
                if (object.deprecated != null)
                    message.deprecated = Boolean(object.deprecated);
                if (object.mapEntry != null)
                    message.mapEntry = Boolean(object.mapEntry);
                if (object.deprecatedLegacyJsonFieldConflicts != null)
                    message.deprecatedLegacyJsonFieldConflicts = Boolean(object.deprecatedLegacyJsonFieldConflicts);
                if (object.features != null) {
                    if (typeof object.features !== "object")
                        throw TypeError(".google.protobuf.MessageOptions.features: object expected");
                    message.features = $root.google.protobuf.FeatureSet.fromObject(object.features);
                }
                if (object.uninterpretedOption) {
                    if (!Array.isArray(object.uninterpretedOption))
                        throw TypeError(".google.protobuf.MessageOptions.uninterpretedOption: array expected");
                    message.uninterpretedOption = [];
                    for (let i = 0; i < object.uninterpretedOption.length; ++i) {
                        if (typeof object.uninterpretedOption[i] !== "object")
                            throw TypeError(".google.protobuf.MessageOptions.uninterpretedOption: object expected");
                        message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a MessageOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.MessageOptions
             * @static
             * @param {google.protobuf.MessageOptions} message MessageOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MessageOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.uninterpretedOption = [];
                if (options.defaults) {
                    object.messageSetWireFormat = false;
                    object.noStandardDescriptorAccessor = false;
                    object.deprecated = false;
                    object.mapEntry = false;
                    object.deprecatedLegacyJsonFieldConflicts = false;
                    object.features = null;
                }
                if (message.messageSetWireFormat != null && message.hasOwnProperty("messageSetWireFormat"))
                    object.messageSetWireFormat = message.messageSetWireFormat;
                if (message.noStandardDescriptorAccessor != null && message.hasOwnProperty("noStandardDescriptorAccessor"))
                    object.noStandardDescriptorAccessor = message.noStandardDescriptorAccessor;
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    object.deprecated = message.deprecated;
                if (message.mapEntry != null && message.hasOwnProperty("mapEntry"))
                    object.mapEntry = message.mapEntry;
                if (message.deprecatedLegacyJsonFieldConflicts != null && message.hasOwnProperty("deprecatedLegacyJsonFieldConflicts"))
                    object.deprecatedLegacyJsonFieldConflicts = message.deprecatedLegacyJsonFieldConflicts;
                if (message.features != null && message.hasOwnProperty("features"))
                    object.features = $root.google.protobuf.FeatureSet.toObject(message.features, options);
                if (message.uninterpretedOption && message.uninterpretedOption.length) {
                    object.uninterpretedOption = [];
                    for (let j = 0; j < message.uninterpretedOption.length; ++j)
                        object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
                }
                return object;
            };

            /**
             * Converts this MessageOptions to JSON.
             * @function toJSON
             * @memberof google.protobuf.MessageOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MessageOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for MessageOptions
             * @function getTypeUrl
             * @memberof google.protobuf.MessageOptions
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            MessageOptions.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/google.protobuf.MessageOptions";
            };

            return MessageOptions;
        })();

        protobuf.FieldOptions = (function() {

            /**
             * Properties of a FieldOptions.
             * @memberof google.protobuf
             * @interface IFieldOptions
             * @property {google.protobuf.FieldOptions.CType|null} [ctype] FieldOptions ctype
             * @property {boolean|null} [packed] FieldOptions packed
             * @property {google.protobuf.FieldOptions.JSType|null} [jstype] FieldOptions jstype
             * @property {boolean|null} [lazy] FieldOptions lazy
             * @property {boolean|null} [unverifiedLazy] FieldOptions unverifiedLazy
             * @property {boolean|null} [deprecated] FieldOptions deprecated
             * @property {boolean|null} [weak] FieldOptions weak
             * @property {boolean|null} [debugRedact] FieldOptions debugRedact
             * @property {google.protobuf.FieldOptions.OptionRetention|null} [retention] FieldOptions retention
             * @property {Array.<google.protobuf.FieldOptions.OptionTargetType>|null} [targets] FieldOptions targets
             * @property {Array.<google.protobuf.FieldOptions.IEditionDefault>|null} [editionDefaults] FieldOptions editionDefaults
             * @property {google.protobuf.IFeatureSet|null} [features] FieldOptions features
             * @property {google.protobuf.FieldOptions.IFeatureSupport|null} [featureSupport] FieldOptions featureSupport
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] FieldOptions uninterpretedOption
             */

            /**
             * Constructs a new FieldOptions.
             * @memberof google.protobuf
             * @classdesc Represents a FieldOptions.
             * @implements IFieldOptions
             * @constructor
             * @param {google.protobuf.IFieldOptions=} [properties] Properties to set
             */
            function FieldOptions(properties) {
                this.targets = [];
                this.editionDefaults = [];
                this.uninterpretedOption = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FieldOptions ctype.
             * @member {google.protobuf.FieldOptions.CType} ctype
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.ctype = 0;

            /**
             * FieldOptions packed.
             * @member {boolean} packed
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.packed = false;

            /**
             * FieldOptions jstype.
             * @member {google.protobuf.FieldOptions.JSType} jstype
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.jstype = 0;

            /**
             * FieldOptions lazy.
             * @member {boolean} lazy
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.lazy = false;

            /**
             * FieldOptions unverifiedLazy.
             * @member {boolean} unverifiedLazy
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.unverifiedLazy = false;

            /**
             * FieldOptions deprecated.
             * @member {boolean} deprecated
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.deprecated = false;

            /**
             * FieldOptions weak.
             * @member {boolean} weak
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.weak = false;

            /**
             * FieldOptions debugRedact.
             * @member {boolean} debugRedact
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.debugRedact = false;

            /**
             * FieldOptions retention.
             * @member {google.protobuf.FieldOptions.OptionRetention} retention
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.retention = 0;

            /**
             * FieldOptions targets.
             * @member {Array.<google.protobuf.FieldOptions.OptionTargetType>} targets
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.targets = $util.emptyArray;

            /**
             * FieldOptions editionDefaults.
             * @member {Array.<google.protobuf.FieldOptions.IEditionDefault>} editionDefaults
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.editionDefaults = $util.emptyArray;

            /**
             * FieldOptions features.
             * @member {google.protobuf.IFeatureSet|null|undefined} features
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.features = null;

            /**
             * FieldOptions featureSupport.
             * @member {google.protobuf.FieldOptions.IFeatureSupport|null|undefined} featureSupport
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.featureSupport = null;

            /**
             * FieldOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.uninterpretedOption = $util.emptyArray;

            /**
             * Creates a new FieldOptions instance using the specified properties.
             * @function create
             * @memberof google.protobuf.FieldOptions
             * @static
             * @param {google.protobuf.IFieldOptions=} [properties] Properties to set
             * @returns {google.protobuf.FieldOptions} FieldOptions instance
             */
            FieldOptions.create = function create(properties) {
                return new FieldOptions(properties);
            };

            /**
             * Encodes the specified FieldOptions message. Does not implicitly {@link google.protobuf.FieldOptions.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.FieldOptions
             * @static
             * @param {google.protobuf.IFieldOptions} message FieldOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FieldOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.ctype != null && Object.hasOwnProperty.call(message, "ctype"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.ctype);
                if (message.packed != null && Object.hasOwnProperty.call(message, "packed"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.packed);
                if (message.deprecated != null && Object.hasOwnProperty.call(message, "deprecated"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.deprecated);
                if (message.lazy != null && Object.hasOwnProperty.call(message, "lazy"))
                    writer.uint32(/* id 5, wireType 0 =*/40).bool(message.lazy);
                if (message.jstype != null && Object.hasOwnProperty.call(message, "jstype"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int32(message.jstype);
                if (message.weak != null && Object.hasOwnProperty.call(message, "weak"))
                    writer.uint32(/* id 10, wireType 0 =*/80).bool(message.weak);
                if (message.unverifiedLazy != null && Object.hasOwnProperty.call(message, "unverifiedLazy"))
                    writer.uint32(/* id 15, wireType 0 =*/120).bool(message.unverifiedLazy);
                if (message.debugRedact != null && Object.hasOwnProperty.call(message, "debugRedact"))
                    writer.uint32(/* id 16, wireType 0 =*/128).bool(message.debugRedact);
                if (message.retention != null && Object.hasOwnProperty.call(message, "retention"))
                    writer.uint32(/* id 17, wireType 0 =*/136).int32(message.retention);
                if (message.targets != null && message.targets.length)
                    for (let i = 0; i < message.targets.length; ++i)
                        writer.uint32(/* id 19, wireType 0 =*/152).int32(message.targets[i]);
                if (message.editionDefaults != null && message.editionDefaults.length)
                    for (let i = 0; i < message.editionDefaults.length; ++i)
                        $root.google.protobuf.FieldOptions.EditionDefault.encode(message.editionDefaults[i], writer.uint32(/* id 20, wireType 2 =*/162).fork()).ldelim();
                if (message.features != null && Object.hasOwnProperty.call(message, "features"))
                    $root.google.protobuf.FeatureSet.encode(message.features, writer.uint32(/* id 21, wireType 2 =*/170).fork()).ldelim();
                if (message.featureSupport != null && Object.hasOwnProperty.call(message, "featureSupport"))
                    $root.google.protobuf.FieldOptions.FeatureSupport.encode(message.featureSupport, writer.uint32(/* id 22, wireType 2 =*/178).fork()).ldelim();
                if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                    for (let i = 0; i < message.uninterpretedOption.length; ++i)
                        $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified FieldOptions message, length delimited. Does not implicitly {@link google.protobuf.FieldOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.FieldOptions
             * @static
             * @param {google.protobuf.IFieldOptions} message FieldOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FieldOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FieldOptions message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.FieldOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.FieldOptions} FieldOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FieldOptions.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FieldOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.ctype = reader.int32();
                            break;
                        }
                    case 2: {
                            message.packed = reader.bool();
                            break;
                        }
                    case 6: {
                            message.jstype = reader.int32();
                            break;
                        }
                    case 5: {
                            message.lazy = reader.bool();
                            break;
                        }
                    case 15: {
                            message.unverifiedLazy = reader.bool();
                            break;
                        }
                    case 3: {
                            message.deprecated = reader.bool();
                            break;
                        }
                    case 10: {
                            message.weak = reader.bool();
                            break;
                        }
                    case 16: {
                            message.debugRedact = reader.bool();
                            break;
                        }
                    case 17: {
                            message.retention = reader.int32();
                            break;
                        }
                    case 19: {
                            if (!(message.targets && message.targets.length))
                                message.targets = [];
                            if ((tag & 7) === 2) {
                                let end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.targets.push(reader.int32());
                            } else
                                message.targets.push(reader.int32());
                            break;
                        }
                    case 20: {
                            if (!(message.editionDefaults && message.editionDefaults.length))
                                message.editionDefaults = [];
                            message.editionDefaults.push($root.google.protobuf.FieldOptions.EditionDefault.decode(reader, reader.uint32()));
                            break;
                        }
                    case 21: {
                            message.features = $root.google.protobuf.FeatureSet.decode(reader, reader.uint32());
                            break;
                        }
                    case 22: {
                            message.featureSupport = $root.google.protobuf.FieldOptions.FeatureSupport.decode(reader, reader.uint32());
                            break;
                        }
                    case 999: {
                            if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                                message.uninterpretedOption = [];
                            message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FieldOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.FieldOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.FieldOptions} FieldOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FieldOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FieldOptions message.
             * @function verify
             * @memberof google.protobuf.FieldOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FieldOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.ctype != null && message.hasOwnProperty("ctype"))
                    switch (message.ctype) {
                    default:
                        return "ctype: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                if (message.packed != null && message.hasOwnProperty("packed"))
                    if (typeof message.packed !== "boolean")
                        return "packed: boolean expected";
                if (message.jstype != null && message.hasOwnProperty("jstype"))
                    switch (message.jstype) {
                    default:
                        return "jstype: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                if (message.lazy != null && message.hasOwnProperty("lazy"))
                    if (typeof message.lazy !== "boolean")
                        return "lazy: boolean expected";
                if (message.unverifiedLazy != null && message.hasOwnProperty("unverifiedLazy"))
                    if (typeof message.unverifiedLazy !== "boolean")
                        return "unverifiedLazy: boolean expected";
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    if (typeof message.deprecated !== "boolean")
                        return "deprecated: boolean expected";
                if (message.weak != null && message.hasOwnProperty("weak"))
                    if (typeof message.weak !== "boolean")
                        return "weak: boolean expected";
                if (message.debugRedact != null && message.hasOwnProperty("debugRedact"))
                    if (typeof message.debugRedact !== "boolean")
                        return "debugRedact: boolean expected";
                if (message.retention != null && message.hasOwnProperty("retention"))
                    switch (message.retention) {
                    default:
                        return "retention: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                if (message.targets != null && message.hasOwnProperty("targets")) {
                    if (!Array.isArray(message.targets))
                        return "targets: array expected";
                    for (let i = 0; i < message.targets.length; ++i)
                        switch (message.targets[i]) {
                        default:
                            return "targets: enum value[] expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                        case 7:
                        case 8:
                        case 9:
                            break;
                        }
                }
                if (message.editionDefaults != null && message.hasOwnProperty("editionDefaults")) {
                    if (!Array.isArray(message.editionDefaults))
                        return "editionDefaults: array expected";
                    for (let i = 0; i < message.editionDefaults.length; ++i) {
                        let error = $root.google.protobuf.FieldOptions.EditionDefault.verify(message.editionDefaults[i]);
                        if (error)
                            return "editionDefaults." + error;
                    }
                }
                if (message.features != null && message.hasOwnProperty("features")) {
                    let error = $root.google.protobuf.FeatureSet.verify(message.features);
                    if (error)
                        return "features." + error;
                }
                if (message.featureSupport != null && message.hasOwnProperty("featureSupport")) {
                    let error = $root.google.protobuf.FieldOptions.FeatureSupport.verify(message.featureSupport);
                    if (error)
                        return "featureSupport." + error;
                }
                if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                    if (!Array.isArray(message.uninterpretedOption))
                        return "uninterpretedOption: array expected";
                    for (let i = 0; i < message.uninterpretedOption.length; ++i) {
                        let error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                        if (error)
                            return "uninterpretedOption." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a FieldOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.FieldOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.FieldOptions} FieldOptions
             */
            FieldOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.FieldOptions)
                    return object;
                let message = new $root.google.protobuf.FieldOptions();
                switch (object.ctype) {
                default:
                    if (typeof object.ctype === "number") {
                        message.ctype = object.ctype;
                        break;
                    }
                    break;
                case "STRING":
                case 0:
                    message.ctype = 0;
                    break;
                case "CORD":
                case 1:
                    message.ctype = 1;
                    break;
                case "STRING_PIECE":
                case 2:
                    message.ctype = 2;
                    break;
                }
                if (object.packed != null)
                    message.packed = Boolean(object.packed);
                switch (object.jstype) {
                default:
                    if (typeof object.jstype === "number") {
                        message.jstype = object.jstype;
                        break;
                    }
                    break;
                case "JS_NORMAL":
                case 0:
                    message.jstype = 0;
                    break;
                case "JS_STRING":
                case 1:
                    message.jstype = 1;
                    break;
                case "JS_NUMBER":
                case 2:
                    message.jstype = 2;
                    break;
                }
                if (object.lazy != null)
                    message.lazy = Boolean(object.lazy);
                if (object.unverifiedLazy != null)
                    message.unverifiedLazy = Boolean(object.unverifiedLazy);
                if (object.deprecated != null)
                    message.deprecated = Boolean(object.deprecated);
                if (object.weak != null)
                    message.weak = Boolean(object.weak);
                if (object.debugRedact != null)
                    message.debugRedact = Boolean(object.debugRedact);
                switch (object.retention) {
                default:
                    if (typeof object.retention === "number") {
                        message.retention = object.retention;
                        break;
                    }
                    break;
                case "RETENTION_UNKNOWN":
                case 0:
                    message.retention = 0;
                    break;
                case "RETENTION_RUNTIME":
                case 1:
                    message.retention = 1;
                    break;
                case "RETENTION_SOURCE":
                case 2:
                    message.retention = 2;
                    break;
                }
                if (object.targets) {
                    if (!Array.isArray(object.targets))
                        throw TypeError(".google.protobuf.FieldOptions.targets: array expected");
                    message.targets = [];
                    for (let i = 0; i < object.targets.length; ++i)
                        switch (object.targets[i]) {
                        default:
                            if (typeof object.targets[i] === "number") {
                                message.targets[i] = object.targets[i];
                                break;
                            }
                        case "TARGET_TYPE_UNKNOWN":
                        case 0:
                            message.targets[i] = 0;
                            break;
                        case "TARGET_TYPE_FILE":
                        case 1:
                            message.targets[i] = 1;
                            break;
                        case "TARGET_TYPE_EXTENSION_RANGE":
                        case 2:
                            message.targets[i] = 2;
                            break;
                        case "TARGET_TYPE_MESSAGE":
                        case 3:
                            message.targets[i] = 3;
                            break;
                        case "TARGET_TYPE_FIELD":
                        case 4:
                            message.targets[i] = 4;
                            break;
                        case "TARGET_TYPE_ONEOF":
                        case 5:
                            message.targets[i] = 5;
                            break;
                        case "TARGET_TYPE_ENUM":
                        case 6:
                            message.targets[i] = 6;
                            break;
                        case "TARGET_TYPE_ENUM_ENTRY":
                        case 7:
                            message.targets[i] = 7;
                            break;
                        case "TARGET_TYPE_SERVICE":
                        case 8:
                            message.targets[i] = 8;
                            break;
                        case "TARGET_TYPE_METHOD":
                        case 9:
                            message.targets[i] = 9;
                            break;
                        }
                }
                if (object.editionDefaults) {
                    if (!Array.isArray(object.editionDefaults))
                        throw TypeError(".google.protobuf.FieldOptions.editionDefaults: array expected");
                    message.editionDefaults = [];
                    for (let i = 0; i < object.editionDefaults.length; ++i) {
                        if (typeof object.editionDefaults[i] !== "object")
                            throw TypeError(".google.protobuf.FieldOptions.editionDefaults: object expected");
                        message.editionDefaults[i] = $root.google.protobuf.FieldOptions.EditionDefault.fromObject(object.editionDefaults[i]);
                    }
                }
                if (object.features != null) {
                    if (typeof object.features !== "object")
                        throw TypeError(".google.protobuf.FieldOptions.features: object expected");
                    message.features = $root.google.protobuf.FeatureSet.fromObject(object.features);
                }
                if (object.featureSupport != null) {
                    if (typeof object.featureSupport !== "object")
                        throw TypeError(".google.protobuf.FieldOptions.featureSupport: object expected");
                    message.featureSupport = $root.google.protobuf.FieldOptions.FeatureSupport.fromObject(object.featureSupport);
                }
                if (object.uninterpretedOption) {
                    if (!Array.isArray(object.uninterpretedOption))
                        throw TypeError(".google.protobuf.FieldOptions.uninterpretedOption: array expected");
                    message.uninterpretedOption = [];
                    for (let i = 0; i < object.uninterpretedOption.length; ++i) {
                        if (typeof object.uninterpretedOption[i] !== "object")
                            throw TypeError(".google.protobuf.FieldOptions.uninterpretedOption: object expected");
                        message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a FieldOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.FieldOptions
             * @static
             * @param {google.protobuf.FieldOptions} message FieldOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FieldOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults) {
                    object.targets = [];
                    object.editionDefaults = [];
                    object.uninterpretedOption = [];
                }
                if (options.defaults) {
                    object.ctype = options.enums === String ? "STRING" : 0;
                    object.packed = false;
                    object.deprecated = false;
                    object.lazy = false;
                    object.jstype = options.enums === String ? "JS_NORMAL" : 0;
                    object.weak = false;
                    object.unverifiedLazy = false;
                    object.debugRedact = false;
                    object.retention = options.enums === String ? "RETENTION_UNKNOWN" : 0;
                    object.features = null;
                    object.featureSupport = null;
                }
                if (message.ctype != null && message.hasOwnProperty("ctype"))
                    object.ctype = options.enums === String ? $root.google.protobuf.FieldOptions.CType[message.ctype] === undefined ? message.ctype : $root.google.protobuf.FieldOptions.CType[message.ctype] : message.ctype;
                if (message.packed != null && message.hasOwnProperty("packed"))
                    object.packed = message.packed;
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    object.deprecated = message.deprecated;
                if (message.lazy != null && message.hasOwnProperty("lazy"))
                    object.lazy = message.lazy;
                if (message.jstype != null && message.hasOwnProperty("jstype"))
                    object.jstype = options.enums === String ? $root.google.protobuf.FieldOptions.JSType[message.jstype] === undefined ? message.jstype : $root.google.protobuf.FieldOptions.JSType[message.jstype] : message.jstype;
                if (message.weak != null && message.hasOwnProperty("weak"))
                    object.weak = message.weak;
                if (message.unverifiedLazy != null && message.hasOwnProperty("unverifiedLazy"))
                    object.unverifiedLazy = message.unverifiedLazy;
                if (message.debugRedact != null && message.hasOwnProperty("debugRedact"))
                    object.debugRedact = message.debugRedact;
                if (message.retention != null && message.hasOwnProperty("retention"))
                    object.retention = options.enums === String ? $root.google.protobuf.FieldOptions.OptionRetention[message.retention] === undefined ? message.retention : $root.google.protobuf.FieldOptions.OptionRetention[message.retention] : message.retention;
                if (message.targets && message.targets.length) {
                    object.targets = [];
                    for (let j = 0; j < message.targets.length; ++j)
                        object.targets[j] = options.enums === String ? $root.google.protobuf.FieldOptions.OptionTargetType[message.targets[j]] === undefined ? message.targets[j] : $root.google.protobuf.FieldOptions.OptionTargetType[message.targets[j]] : message.targets[j];
                }
                if (message.editionDefaults && message.editionDefaults.length) {
                    object.editionDefaults = [];
                    for (let j = 0; j < message.editionDefaults.length; ++j)
                        object.editionDefaults[j] = $root.google.protobuf.FieldOptions.EditionDefault.toObject(message.editionDefaults[j], options);
                }
                if (message.features != null && message.hasOwnProperty("features"))
                    object.features = $root.google.protobuf.FeatureSet.toObject(message.features, options);
                if (message.featureSupport != null && message.hasOwnProperty("featureSupport"))
                    object.featureSupport = $root.google.protobuf.FieldOptions.FeatureSupport.toObject(message.featureSupport, options);
                if (message.uninterpretedOption && message.uninterpretedOption.length) {
                    object.uninterpretedOption = [];
                    for (let j = 0; j < message.uninterpretedOption.length; ++j)
                        object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
                }
                return object;
            };

            /**
             * Converts this FieldOptions to JSON.
             * @function toJSON
             * @memberof google.protobuf.FieldOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FieldOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for FieldOptions
             * @function getTypeUrl
             * @memberof google.protobuf.FieldOptions
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            FieldOptions.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/google.protobuf.FieldOptions";
            };

            /**
             * CType enum.
             * @name google.protobuf.FieldOptions.CType
             * @enum {number}
             * @property {number} STRING=0 STRING value
             * @property {number} CORD=1 CORD value
             * @property {number} STRING_PIECE=2 STRING_PIECE value
             */
            FieldOptions.CType = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "STRING"] = 0;
                values[valuesById[1] = "CORD"] = 1;
                values[valuesById[2] = "STRING_PIECE"] = 2;
                return values;
            })();

            /**
             * JSType enum.
             * @name google.protobuf.FieldOptions.JSType
             * @enum {number}
             * @property {number} JS_NORMAL=0 JS_NORMAL value
             * @property {number} JS_STRING=1 JS_STRING value
             * @property {number} JS_NUMBER=2 JS_NUMBER value
             */
            FieldOptions.JSType = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "JS_NORMAL"] = 0;
                values[valuesById[1] = "JS_STRING"] = 1;
                values[valuesById[2] = "JS_NUMBER"] = 2;
                return values;
            })();

            /**
             * OptionRetention enum.
             * @name google.protobuf.FieldOptions.OptionRetention
             * @enum {number}
             * @property {number} RETENTION_UNKNOWN=0 RETENTION_UNKNOWN value
             * @property {number} RETENTION_RUNTIME=1 RETENTION_RUNTIME value
             * @property {number} RETENTION_SOURCE=2 RETENTION_SOURCE value
             */
            FieldOptions.OptionRetention = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "RETENTION_UNKNOWN"] = 0;
                values[valuesById[1] = "RETENTION_RUNTIME"] = 1;
                values[valuesById[2] = "RETENTION_SOURCE"] = 2;
                return values;
            })();

            /**
             * OptionTargetType enum.
             * @name google.protobuf.FieldOptions.OptionTargetType
             * @enum {number}
             * @property {number} TARGET_TYPE_UNKNOWN=0 TARGET_TYPE_UNKNOWN value
             * @property {number} TARGET_TYPE_FILE=1 TARGET_TYPE_FILE value
             * @property {number} TARGET_TYPE_EXTENSION_RANGE=2 TARGET_TYPE_EXTENSION_RANGE value
             * @property {number} TARGET_TYPE_MESSAGE=3 TARGET_TYPE_MESSAGE value
             * @property {number} TARGET_TYPE_FIELD=4 TARGET_TYPE_FIELD value
             * @property {number} TARGET_TYPE_ONEOF=5 TARGET_TYPE_ONEOF value
             * @property {number} TARGET_TYPE_ENUM=6 TARGET_TYPE_ENUM value
             * @property {number} TARGET_TYPE_ENUM_ENTRY=7 TARGET_TYPE_ENUM_ENTRY value
             * @property {number} TARGET_TYPE_SERVICE=8 TARGET_TYPE_SERVICE value
             * @property {number} TARGET_TYPE_METHOD=9 TARGET_TYPE_METHOD value
             */
            FieldOptions.OptionTargetType = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "TARGET_TYPE_UNKNOWN"] = 0;
                values[valuesById[1] = "TARGET_TYPE_FILE"] = 1;
                values[valuesById[2] = "TARGET_TYPE_EXTENSION_RANGE"] = 2;
                values[valuesById[3] = "TARGET_TYPE_MESSAGE"] = 3;
                values[valuesById[4] = "TARGET_TYPE_FIELD"] = 4;
                values[valuesById[5] = "TARGET_TYPE_ONEOF"] = 5;
                values[valuesById[6] = "TARGET_TYPE_ENUM"] = 6;
                values[valuesById[7] = "TARGET_TYPE_ENUM_ENTRY"] = 7;
                values[valuesById[8] = "TARGET_TYPE_SERVICE"] = 8;
                values[valuesById[9] = "TARGET_TYPE_METHOD"] = 9;
                return values;
            })();

            FieldOptions.EditionDefault = (function() {

                /**
                 * Properties of an EditionDefault.
                 * @memberof google.protobuf.FieldOptions
                 * @interface IEditionDefault
                 * @property {google.protobuf.Edition|null} [edition] EditionDefault edition
                 * @property {string|null} [value] EditionDefault value
                 */

                /**
                 * Constructs a new EditionDefault.
                 * @memberof google.protobuf.FieldOptions
                 * @classdesc Represents an EditionDefault.
                 * @implements IEditionDefault
                 * @constructor
                 * @param {google.protobuf.FieldOptions.IEditionDefault=} [properties] Properties to set
                 */
                function EditionDefault(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * EditionDefault edition.
                 * @member {google.protobuf.Edition} edition
                 * @memberof google.protobuf.FieldOptions.EditionDefault
                 * @instance
                 */
                EditionDefault.prototype.edition = 0;

                /**
                 * EditionDefault value.
                 * @member {string} value
                 * @memberof google.protobuf.FieldOptions.EditionDefault
                 * @instance
                 */
                EditionDefault.prototype.value = "";

                /**
                 * Creates a new EditionDefault instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.FieldOptions.EditionDefault
                 * @static
                 * @param {google.protobuf.FieldOptions.IEditionDefault=} [properties] Properties to set
                 * @returns {google.protobuf.FieldOptions.EditionDefault} EditionDefault instance
                 */
                EditionDefault.create = function create(properties) {
                    return new EditionDefault(properties);
                };

                /**
                 * Encodes the specified EditionDefault message. Does not implicitly {@link google.protobuf.FieldOptions.EditionDefault.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.FieldOptions.EditionDefault
                 * @static
                 * @param {google.protobuf.FieldOptions.IEditionDefault} message EditionDefault message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EditionDefault.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.value);
                    if (message.edition != null && Object.hasOwnProperty.call(message, "edition"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.edition);
                    return writer;
                };

                /**
                 * Encodes the specified EditionDefault message, length delimited. Does not implicitly {@link google.protobuf.FieldOptions.EditionDefault.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.FieldOptions.EditionDefault
                 * @static
                 * @param {google.protobuf.FieldOptions.IEditionDefault} message EditionDefault message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EditionDefault.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an EditionDefault message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.FieldOptions.EditionDefault
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.FieldOptions.EditionDefault} EditionDefault
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EditionDefault.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FieldOptions.EditionDefault();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 3: {
                                message.edition = reader.int32();
                                break;
                            }
                        case 2: {
                                message.value = reader.string();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an EditionDefault message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.FieldOptions.EditionDefault
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.FieldOptions.EditionDefault} EditionDefault
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EditionDefault.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an EditionDefault message.
                 * @function verify
                 * @memberof google.protobuf.FieldOptions.EditionDefault
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                EditionDefault.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.edition != null && message.hasOwnProperty("edition"))
                        switch (message.edition) {
                        default:
                            return "edition: enum value expected";
                        case 0:
                        case 900:
                        case 998:
                        case 999:
                        case 1000:
                        case 1001:
                        case 1:
                        case 2:
                        case 99997:
                        case 99998:
                        case 99999:
                        case 2147483647:
                            break;
                        }
                    if (message.value != null && message.hasOwnProperty("value"))
                        if (!$util.isString(message.value))
                            return "value: string expected";
                    return null;
                };

                /**
                 * Creates an EditionDefault message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.FieldOptions.EditionDefault
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.FieldOptions.EditionDefault} EditionDefault
                 */
                EditionDefault.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.FieldOptions.EditionDefault)
                        return object;
                    let message = new $root.google.protobuf.FieldOptions.EditionDefault();
                    switch (object.edition) {
                    default:
                        if (typeof object.edition === "number") {
                            message.edition = object.edition;
                            break;
                        }
                        break;
                    case "EDITION_UNKNOWN":
                    case 0:
                        message.edition = 0;
                        break;
                    case "EDITION_LEGACY":
                    case 900:
                        message.edition = 900;
                        break;
                    case "EDITION_PROTO2":
                    case 998:
                        message.edition = 998;
                        break;
                    case "EDITION_PROTO3":
                    case 999:
                        message.edition = 999;
                        break;
                    case "EDITION_2023":
                    case 1000:
                        message.edition = 1000;
                        break;
                    case "EDITION_2024":
                    case 1001:
                        message.edition = 1001;
                        break;
                    case "EDITION_1_TEST_ONLY":
                    case 1:
                        message.edition = 1;
                        break;
                    case "EDITION_2_TEST_ONLY":
                    case 2:
                        message.edition = 2;
                        break;
                    case "EDITION_99997_TEST_ONLY":
                    case 99997:
                        message.edition = 99997;
                        break;
                    case "EDITION_99998_TEST_ONLY":
                    case 99998:
                        message.edition = 99998;
                        break;
                    case "EDITION_99999_TEST_ONLY":
                    case 99999:
                        message.edition = 99999;
                        break;
                    case "EDITION_MAX":
                    case 2147483647:
                        message.edition = 2147483647;
                        break;
                    }
                    if (object.value != null)
                        message.value = String(object.value);
                    return message;
                };

                /**
                 * Creates a plain object from an EditionDefault message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.FieldOptions.EditionDefault
                 * @static
                 * @param {google.protobuf.FieldOptions.EditionDefault} message EditionDefault
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                EditionDefault.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.value = "";
                        object.edition = options.enums === String ? "EDITION_UNKNOWN" : 0;
                    }
                    if (message.value != null && message.hasOwnProperty("value"))
                        object.value = message.value;
                    if (message.edition != null && message.hasOwnProperty("edition"))
                        object.edition = options.enums === String ? $root.google.protobuf.Edition[message.edition] === undefined ? message.edition : $root.google.protobuf.Edition[message.edition] : message.edition;
                    return object;
                };

                /**
                 * Converts this EditionDefault to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.FieldOptions.EditionDefault
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                EditionDefault.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for EditionDefault
                 * @function getTypeUrl
                 * @memberof google.protobuf.FieldOptions.EditionDefault
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                EditionDefault.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/google.protobuf.FieldOptions.EditionDefault";
                };

                return EditionDefault;
            })();

            FieldOptions.FeatureSupport = (function() {

                /**
                 * Properties of a FeatureSupport.
                 * @memberof google.protobuf.FieldOptions
                 * @interface IFeatureSupport
                 * @property {google.protobuf.Edition|null} [editionIntroduced] FeatureSupport editionIntroduced
                 * @property {google.protobuf.Edition|null} [editionDeprecated] FeatureSupport editionDeprecated
                 * @property {string|null} [deprecationWarning] FeatureSupport deprecationWarning
                 * @property {google.protobuf.Edition|null} [editionRemoved] FeatureSupport editionRemoved
                 */

                /**
                 * Constructs a new FeatureSupport.
                 * @memberof google.protobuf.FieldOptions
                 * @classdesc Represents a FeatureSupport.
                 * @implements IFeatureSupport
                 * @constructor
                 * @param {google.protobuf.FieldOptions.IFeatureSupport=} [properties] Properties to set
                 */
                function FeatureSupport(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * FeatureSupport editionIntroduced.
                 * @member {google.protobuf.Edition} editionIntroduced
                 * @memberof google.protobuf.FieldOptions.FeatureSupport
                 * @instance
                 */
                FeatureSupport.prototype.editionIntroduced = 0;

                /**
                 * FeatureSupport editionDeprecated.
                 * @member {google.protobuf.Edition} editionDeprecated
                 * @memberof google.protobuf.FieldOptions.FeatureSupport
                 * @instance
                 */
                FeatureSupport.prototype.editionDeprecated = 0;

                /**
                 * FeatureSupport deprecationWarning.
                 * @member {string} deprecationWarning
                 * @memberof google.protobuf.FieldOptions.FeatureSupport
                 * @instance
                 */
                FeatureSupport.prototype.deprecationWarning = "";

                /**
                 * FeatureSupport editionRemoved.
                 * @member {google.protobuf.Edition} editionRemoved
                 * @memberof google.protobuf.FieldOptions.FeatureSupport
                 * @instance
                 */
                FeatureSupport.prototype.editionRemoved = 0;

                /**
                 * Creates a new FeatureSupport instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.FieldOptions.FeatureSupport
                 * @static
                 * @param {google.protobuf.FieldOptions.IFeatureSupport=} [properties] Properties to set
                 * @returns {google.protobuf.FieldOptions.FeatureSupport} FeatureSupport instance
                 */
                FeatureSupport.create = function create(properties) {
                    return new FeatureSupport(properties);
                };

                /**
                 * Encodes the specified FeatureSupport message. Does not implicitly {@link google.protobuf.FieldOptions.FeatureSupport.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.FieldOptions.FeatureSupport
                 * @static
                 * @param {google.protobuf.FieldOptions.IFeatureSupport} message FeatureSupport message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FeatureSupport.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.editionIntroduced != null && Object.hasOwnProperty.call(message, "editionIntroduced"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.editionIntroduced);
                    if (message.editionDeprecated != null && Object.hasOwnProperty.call(message, "editionDeprecated"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.editionDeprecated);
                    if (message.deprecationWarning != null && Object.hasOwnProperty.call(message, "deprecationWarning"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.deprecationWarning);
                    if (message.editionRemoved != null && Object.hasOwnProperty.call(message, "editionRemoved"))
                        writer.uint32(/* id 4, wireType 0 =*/32).int32(message.editionRemoved);
                    return writer;
                };

                /**
                 * Encodes the specified FeatureSupport message, length delimited. Does not implicitly {@link google.protobuf.FieldOptions.FeatureSupport.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.FieldOptions.FeatureSupport
                 * @static
                 * @param {google.protobuf.FieldOptions.IFeatureSupport} message FeatureSupport message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FeatureSupport.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a FeatureSupport message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.FieldOptions.FeatureSupport
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.FieldOptions.FeatureSupport} FeatureSupport
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FeatureSupport.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FieldOptions.FeatureSupport();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                message.editionIntroduced = reader.int32();
                                break;
                            }
                        case 2: {
                                message.editionDeprecated = reader.int32();
                                break;
                            }
                        case 3: {
                                message.deprecationWarning = reader.string();
                                break;
                            }
                        case 4: {
                                message.editionRemoved = reader.int32();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a FeatureSupport message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.FieldOptions.FeatureSupport
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.FieldOptions.FeatureSupport} FeatureSupport
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FeatureSupport.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a FeatureSupport message.
                 * @function verify
                 * @memberof google.protobuf.FieldOptions.FeatureSupport
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                FeatureSupport.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.editionIntroduced != null && message.hasOwnProperty("editionIntroduced"))
                        switch (message.editionIntroduced) {
                        default:
                            return "editionIntroduced: enum value expected";
                        case 0:
                        case 900:
                        case 998:
                        case 999:
                        case 1000:
                        case 1001:
                        case 1:
                        case 2:
                        case 99997:
                        case 99998:
                        case 99999:
                        case 2147483647:
                            break;
                        }
                    if (message.editionDeprecated != null && message.hasOwnProperty("editionDeprecated"))
                        switch (message.editionDeprecated) {
                        default:
                            return "editionDeprecated: enum value expected";
                        case 0:
                        case 900:
                        case 998:
                        case 999:
                        case 1000:
                        case 1001:
                        case 1:
                        case 2:
                        case 99997:
                        case 99998:
                        case 99999:
                        case 2147483647:
                            break;
                        }
                    if (message.deprecationWarning != null && message.hasOwnProperty("deprecationWarning"))
                        if (!$util.isString(message.deprecationWarning))
                            return "deprecationWarning: string expected";
                    if (message.editionRemoved != null && message.hasOwnProperty("editionRemoved"))
                        switch (message.editionRemoved) {
                        default:
                            return "editionRemoved: enum value expected";
                        case 0:
                        case 900:
                        case 998:
                        case 999:
                        case 1000:
                        case 1001:
                        case 1:
                        case 2:
                        case 99997:
                        case 99998:
                        case 99999:
                        case 2147483647:
                            break;
                        }
                    return null;
                };

                /**
                 * Creates a FeatureSupport message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.FieldOptions.FeatureSupport
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.FieldOptions.FeatureSupport} FeatureSupport
                 */
                FeatureSupport.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.FieldOptions.FeatureSupport)
                        return object;
                    let message = new $root.google.protobuf.FieldOptions.FeatureSupport();
                    switch (object.editionIntroduced) {
                    default:
                        if (typeof object.editionIntroduced === "number") {
                            message.editionIntroduced = object.editionIntroduced;
                            break;
                        }
                        break;
                    case "EDITION_UNKNOWN":
                    case 0:
                        message.editionIntroduced = 0;
                        break;
                    case "EDITION_LEGACY":
                    case 900:
                        message.editionIntroduced = 900;
                        break;
                    case "EDITION_PROTO2":
                    case 998:
                        message.editionIntroduced = 998;
                        break;
                    case "EDITION_PROTO3":
                    case 999:
                        message.editionIntroduced = 999;
                        break;
                    case "EDITION_2023":
                    case 1000:
                        message.editionIntroduced = 1000;
                        break;
                    case "EDITION_2024":
                    case 1001:
                        message.editionIntroduced = 1001;
                        break;
                    case "EDITION_1_TEST_ONLY":
                    case 1:
                        message.editionIntroduced = 1;
                        break;
                    case "EDITION_2_TEST_ONLY":
                    case 2:
                        message.editionIntroduced = 2;
                        break;
                    case "EDITION_99997_TEST_ONLY":
                    case 99997:
                        message.editionIntroduced = 99997;
                        break;
                    case "EDITION_99998_TEST_ONLY":
                    case 99998:
                        message.editionIntroduced = 99998;
                        break;
                    case "EDITION_99999_TEST_ONLY":
                    case 99999:
                        message.editionIntroduced = 99999;
                        break;
                    case "EDITION_MAX":
                    case 2147483647:
                        message.editionIntroduced = 2147483647;
                        break;
                    }
                    switch (object.editionDeprecated) {
                    default:
                        if (typeof object.editionDeprecated === "number") {
                            message.editionDeprecated = object.editionDeprecated;
                            break;
                        }
                        break;
                    case "EDITION_UNKNOWN":
                    case 0:
                        message.editionDeprecated = 0;
                        break;
                    case "EDITION_LEGACY":
                    case 900:
                        message.editionDeprecated = 900;
                        break;
                    case "EDITION_PROTO2":
                    case 998:
                        message.editionDeprecated = 998;
                        break;
                    case "EDITION_PROTO3":
                    case 999:
                        message.editionDeprecated = 999;
                        break;
                    case "EDITION_2023":
                    case 1000:
                        message.editionDeprecated = 1000;
                        break;
                    case "EDITION_2024":
                    case 1001:
                        message.editionDeprecated = 1001;
                        break;
                    case "EDITION_1_TEST_ONLY":
                    case 1:
                        message.editionDeprecated = 1;
                        break;
                    case "EDITION_2_TEST_ONLY":
                    case 2:
                        message.editionDeprecated = 2;
                        break;
                    case "EDITION_99997_TEST_ONLY":
                    case 99997:
                        message.editionDeprecated = 99997;
                        break;
                    case "EDITION_99998_TEST_ONLY":
                    case 99998:
                        message.editionDeprecated = 99998;
                        break;
                    case "EDITION_99999_TEST_ONLY":
                    case 99999:
                        message.editionDeprecated = 99999;
                        break;
                    case "EDITION_MAX":
                    case 2147483647:
                        message.editionDeprecated = 2147483647;
                        break;
                    }
                    if (object.deprecationWarning != null)
                        message.deprecationWarning = String(object.deprecationWarning);
                    switch (object.editionRemoved) {
                    default:
                        if (typeof object.editionRemoved === "number") {
                            message.editionRemoved = object.editionRemoved;
                            break;
                        }
                        break;
                    case "EDITION_UNKNOWN":
                    case 0:
                        message.editionRemoved = 0;
                        break;
                    case "EDITION_LEGACY":
                    case 900:
                        message.editionRemoved = 900;
                        break;
                    case "EDITION_PROTO2":
                    case 998:
                        message.editionRemoved = 998;
                        break;
                    case "EDITION_PROTO3":
                    case 999:
                        message.editionRemoved = 999;
                        break;
                    case "EDITION_2023":
                    case 1000:
                        message.editionRemoved = 1000;
                        break;
                    case "EDITION_2024":
                    case 1001:
                        message.editionRemoved = 1001;
                        break;
                    case "EDITION_1_TEST_ONLY":
                    case 1:
                        message.editionRemoved = 1;
                        break;
                    case "EDITION_2_TEST_ONLY":
                    case 2:
                        message.editionRemoved = 2;
                        break;
                    case "EDITION_99997_TEST_ONLY":
                    case 99997:
                        message.editionRemoved = 99997;
                        break;
                    case "EDITION_99998_TEST_ONLY":
                    case 99998:
                        message.editionRemoved = 99998;
                        break;
                    case "EDITION_99999_TEST_ONLY":
                    case 99999:
                        message.editionRemoved = 99999;
                        break;
                    case "EDITION_MAX":
                    case 2147483647:
                        message.editionRemoved = 2147483647;
                        break;
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a FeatureSupport message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.FieldOptions.FeatureSupport
                 * @static
                 * @param {google.protobuf.FieldOptions.FeatureSupport} message FeatureSupport
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                FeatureSupport.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.editionIntroduced = options.enums === String ? "EDITION_UNKNOWN" : 0;
                        object.editionDeprecated = options.enums === String ? "EDITION_UNKNOWN" : 0;
                        object.deprecationWarning = "";
                        object.editionRemoved = options.enums === String ? "EDITION_UNKNOWN" : 0;
                    }
                    if (message.editionIntroduced != null && message.hasOwnProperty("editionIntroduced"))
                        object.editionIntroduced = options.enums === String ? $root.google.protobuf.Edition[message.editionIntroduced] === undefined ? message.editionIntroduced : $root.google.protobuf.Edition[message.editionIntroduced] : message.editionIntroduced;
                    if (message.editionDeprecated != null && message.hasOwnProperty("editionDeprecated"))
                        object.editionDeprecated = options.enums === String ? $root.google.protobuf.Edition[message.editionDeprecated] === undefined ? message.editionDeprecated : $root.google.protobuf.Edition[message.editionDeprecated] : message.editionDeprecated;
                    if (message.deprecationWarning != null && message.hasOwnProperty("deprecationWarning"))
                        object.deprecationWarning = message.deprecationWarning;
                    if (message.editionRemoved != null && message.hasOwnProperty("editionRemoved"))
                        object.editionRemoved = options.enums === String ? $root.google.protobuf.Edition[message.editionRemoved] === undefined ? message.editionRemoved : $root.google.protobuf.Edition[message.editionRemoved] : message.editionRemoved;
                    return object;
                };

                /**
                 * Converts this FeatureSupport to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.FieldOptions.FeatureSupport
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                FeatureSupport.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for FeatureSupport
                 * @function getTypeUrl
                 * @memberof google.protobuf.FieldOptions.FeatureSupport
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                FeatureSupport.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/google.protobuf.FieldOptions.FeatureSupport";
                };

                return FeatureSupport;
            })();

            return FieldOptions;
        })();

        protobuf.OneofOptions = (function() {

            /**
             * Properties of an OneofOptions.
             * @memberof google.protobuf
             * @interface IOneofOptions
             * @property {google.protobuf.IFeatureSet|null} [features] OneofOptions features
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] OneofOptions uninterpretedOption
             */

            /**
             * Constructs a new OneofOptions.
             * @memberof google.protobuf
             * @classdesc Represents an OneofOptions.
             * @implements IOneofOptions
             * @constructor
             * @param {google.protobuf.IOneofOptions=} [properties] Properties to set
             */
            function OneofOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * OneofOptions features.
             * @member {google.protobuf.IFeatureSet|null|undefined} features
             * @memberof google.protobuf.OneofOptions
             * @instance
             */
            OneofOptions.prototype.features = null;

            /**
             * OneofOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.OneofOptions
             * @instance
             */
            OneofOptions.prototype.uninterpretedOption = $util.emptyArray;

            /**
             * Creates a new OneofOptions instance using the specified properties.
             * @function create
             * @memberof google.protobuf.OneofOptions
             * @static
             * @param {google.protobuf.IOneofOptions=} [properties] Properties to set
             * @returns {google.protobuf.OneofOptions} OneofOptions instance
             */
            OneofOptions.create = function create(properties) {
                return new OneofOptions(properties);
            };

            /**
             * Encodes the specified OneofOptions message. Does not implicitly {@link google.protobuf.OneofOptions.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.OneofOptions
             * @static
             * @param {google.protobuf.IOneofOptions} message OneofOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OneofOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.features != null && Object.hasOwnProperty.call(message, "features"))
                    $root.google.protobuf.FeatureSet.encode(message.features, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                    for (let i = 0; i < message.uninterpretedOption.length; ++i)
                        $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified OneofOptions message, length delimited. Does not implicitly {@link google.protobuf.OneofOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.OneofOptions
             * @static
             * @param {google.protobuf.IOneofOptions} message OneofOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OneofOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an OneofOptions message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.OneofOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.OneofOptions} OneofOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OneofOptions.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.OneofOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.features = $root.google.protobuf.FeatureSet.decode(reader, reader.uint32());
                            break;
                        }
                    case 999: {
                            if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                                message.uninterpretedOption = [];
                            message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an OneofOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.OneofOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.OneofOptions} OneofOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OneofOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an OneofOptions message.
             * @function verify
             * @memberof google.protobuf.OneofOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            OneofOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.features != null && message.hasOwnProperty("features")) {
                    let error = $root.google.protobuf.FeatureSet.verify(message.features);
                    if (error)
                        return "features." + error;
                }
                if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                    if (!Array.isArray(message.uninterpretedOption))
                        return "uninterpretedOption: array expected";
                    for (let i = 0; i < message.uninterpretedOption.length; ++i) {
                        let error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                        if (error)
                            return "uninterpretedOption." + error;
                    }
                }
                return null;
            };

            /**
             * Creates an OneofOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.OneofOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.OneofOptions} OneofOptions
             */
            OneofOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.OneofOptions)
                    return object;
                let message = new $root.google.protobuf.OneofOptions();
                if (object.features != null) {
                    if (typeof object.features !== "object")
                        throw TypeError(".google.protobuf.OneofOptions.features: object expected");
                    message.features = $root.google.protobuf.FeatureSet.fromObject(object.features);
                }
                if (object.uninterpretedOption) {
                    if (!Array.isArray(object.uninterpretedOption))
                        throw TypeError(".google.protobuf.OneofOptions.uninterpretedOption: array expected");
                    message.uninterpretedOption = [];
                    for (let i = 0; i < object.uninterpretedOption.length; ++i) {
                        if (typeof object.uninterpretedOption[i] !== "object")
                            throw TypeError(".google.protobuf.OneofOptions.uninterpretedOption: object expected");
                        message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from an OneofOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.OneofOptions
             * @static
             * @param {google.protobuf.OneofOptions} message OneofOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            OneofOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.uninterpretedOption = [];
                if (options.defaults)
                    object.features = null;
                if (message.features != null && message.hasOwnProperty("features"))
                    object.features = $root.google.protobuf.FeatureSet.toObject(message.features, options);
                if (message.uninterpretedOption && message.uninterpretedOption.length) {
                    object.uninterpretedOption = [];
                    for (let j = 0; j < message.uninterpretedOption.length; ++j)
                        object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
                }
                return object;
            };

            /**
             * Converts this OneofOptions to JSON.
             * @function toJSON
             * @memberof google.protobuf.OneofOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            OneofOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for OneofOptions
             * @function getTypeUrl
             * @memberof google.protobuf.OneofOptions
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            OneofOptions.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/google.protobuf.OneofOptions";
            };

            return OneofOptions;
        })();

        protobuf.EnumOptions = (function() {

            /**
             * Properties of an EnumOptions.
             * @memberof google.protobuf
             * @interface IEnumOptions
             * @property {boolean|null} [allowAlias] EnumOptions allowAlias
             * @property {boolean|null} [deprecated] EnumOptions deprecated
             * @property {boolean|null} [deprecatedLegacyJsonFieldConflicts] EnumOptions deprecatedLegacyJsonFieldConflicts
             * @property {google.protobuf.IFeatureSet|null} [features] EnumOptions features
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] EnumOptions uninterpretedOption
             */

            /**
             * Constructs a new EnumOptions.
             * @memberof google.protobuf
             * @classdesc Represents an EnumOptions.
             * @implements IEnumOptions
             * @constructor
             * @param {google.protobuf.IEnumOptions=} [properties] Properties to set
             */
            function EnumOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * EnumOptions allowAlias.
             * @member {boolean} allowAlias
             * @memberof google.protobuf.EnumOptions
             * @instance
             */
            EnumOptions.prototype.allowAlias = false;

            /**
             * EnumOptions deprecated.
             * @member {boolean} deprecated
             * @memberof google.protobuf.EnumOptions
             * @instance
             */
            EnumOptions.prototype.deprecated = false;

            /**
             * EnumOptions deprecatedLegacyJsonFieldConflicts.
             * @member {boolean} deprecatedLegacyJsonFieldConflicts
             * @memberof google.protobuf.EnumOptions
             * @instance
             */
            EnumOptions.prototype.deprecatedLegacyJsonFieldConflicts = false;

            /**
             * EnumOptions features.
             * @member {google.protobuf.IFeatureSet|null|undefined} features
             * @memberof google.protobuf.EnumOptions
             * @instance
             */
            EnumOptions.prototype.features = null;

            /**
             * EnumOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.EnumOptions
             * @instance
             */
            EnumOptions.prototype.uninterpretedOption = $util.emptyArray;

            /**
             * Creates a new EnumOptions instance using the specified properties.
             * @function create
             * @memberof google.protobuf.EnumOptions
             * @static
             * @param {google.protobuf.IEnumOptions=} [properties] Properties to set
             * @returns {google.protobuf.EnumOptions} EnumOptions instance
             */
            EnumOptions.create = function create(properties) {
                return new EnumOptions(properties);
            };

            /**
             * Encodes the specified EnumOptions message. Does not implicitly {@link google.protobuf.EnumOptions.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.EnumOptions
             * @static
             * @param {google.protobuf.IEnumOptions} message EnumOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnumOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.allowAlias != null && Object.hasOwnProperty.call(message, "allowAlias"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.allowAlias);
                if (message.deprecated != null && Object.hasOwnProperty.call(message, "deprecated"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.deprecated);
                if (message.deprecatedLegacyJsonFieldConflicts != null && Object.hasOwnProperty.call(message, "deprecatedLegacyJsonFieldConflicts"))
                    writer.uint32(/* id 6, wireType 0 =*/48).bool(message.deprecatedLegacyJsonFieldConflicts);
                if (message.features != null && Object.hasOwnProperty.call(message, "features"))
                    $root.google.protobuf.FeatureSet.encode(message.features, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                    for (let i = 0; i < message.uninterpretedOption.length; ++i)
                        $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified EnumOptions message, length delimited. Does not implicitly {@link google.protobuf.EnumOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.EnumOptions
             * @static
             * @param {google.protobuf.IEnumOptions} message EnumOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnumOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an EnumOptions message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.EnumOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.EnumOptions} EnumOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnumOptions.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 2: {
                            message.allowAlias = reader.bool();
                            break;
                        }
                    case 3: {
                            message.deprecated = reader.bool();
                            break;
                        }
                    case 6: {
                            message.deprecatedLegacyJsonFieldConflicts = reader.bool();
                            break;
                        }
                    case 7: {
                            message.features = $root.google.protobuf.FeatureSet.decode(reader, reader.uint32());
                            break;
                        }
                    case 999: {
                            if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                                message.uninterpretedOption = [];
                            message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an EnumOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.EnumOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.EnumOptions} EnumOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnumOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an EnumOptions message.
             * @function verify
             * @memberof google.protobuf.EnumOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            EnumOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.allowAlias != null && message.hasOwnProperty("allowAlias"))
                    if (typeof message.allowAlias !== "boolean")
                        return "allowAlias: boolean expected";
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    if (typeof message.deprecated !== "boolean")
                        return "deprecated: boolean expected";
                if (message.deprecatedLegacyJsonFieldConflicts != null && message.hasOwnProperty("deprecatedLegacyJsonFieldConflicts"))
                    if (typeof message.deprecatedLegacyJsonFieldConflicts !== "boolean")
                        return "deprecatedLegacyJsonFieldConflicts: boolean expected";
                if (message.features != null && message.hasOwnProperty("features")) {
                    let error = $root.google.protobuf.FeatureSet.verify(message.features);
                    if (error)
                        return "features." + error;
                }
                if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                    if (!Array.isArray(message.uninterpretedOption))
                        return "uninterpretedOption: array expected";
                    for (let i = 0; i < message.uninterpretedOption.length; ++i) {
                        let error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                        if (error)
                            return "uninterpretedOption." + error;
                    }
                }
                return null;
            };

            /**
             * Creates an EnumOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.EnumOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.EnumOptions} EnumOptions
             */
            EnumOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.EnumOptions)
                    return object;
                let message = new $root.google.protobuf.EnumOptions();
                if (object.allowAlias != null)
                    message.allowAlias = Boolean(object.allowAlias);
                if (object.deprecated != null)
                    message.deprecated = Boolean(object.deprecated);
                if (object.deprecatedLegacyJsonFieldConflicts != null)
                    message.deprecatedLegacyJsonFieldConflicts = Boolean(object.deprecatedLegacyJsonFieldConflicts);
                if (object.features != null) {
                    if (typeof object.features !== "object")
                        throw TypeError(".google.protobuf.EnumOptions.features: object expected");
                    message.features = $root.google.protobuf.FeatureSet.fromObject(object.features);
                }
                if (object.uninterpretedOption) {
                    if (!Array.isArray(object.uninterpretedOption))
                        throw TypeError(".google.protobuf.EnumOptions.uninterpretedOption: array expected");
                    message.uninterpretedOption = [];
                    for (let i = 0; i < object.uninterpretedOption.length; ++i) {
                        if (typeof object.uninterpretedOption[i] !== "object")
                            throw TypeError(".google.protobuf.EnumOptions.uninterpretedOption: object expected");
                        message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from an EnumOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.EnumOptions
             * @static
             * @param {google.protobuf.EnumOptions} message EnumOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            EnumOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.uninterpretedOption = [];
                if (options.defaults) {
                    object.allowAlias = false;
                    object.deprecated = false;
                    object.deprecatedLegacyJsonFieldConflicts = false;
                    object.features = null;
                }
                if (message.allowAlias != null && message.hasOwnProperty("allowAlias"))
                    object.allowAlias = message.allowAlias;
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    object.deprecated = message.deprecated;
                if (message.deprecatedLegacyJsonFieldConflicts != null && message.hasOwnProperty("deprecatedLegacyJsonFieldConflicts"))
                    object.deprecatedLegacyJsonFieldConflicts = message.deprecatedLegacyJsonFieldConflicts;
                if (message.features != null && message.hasOwnProperty("features"))
                    object.features = $root.google.protobuf.FeatureSet.toObject(message.features, options);
                if (message.uninterpretedOption && message.uninterpretedOption.length) {
                    object.uninterpretedOption = [];
                    for (let j = 0; j < message.uninterpretedOption.length; ++j)
                        object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
                }
                return object;
            };

            /**
             * Converts this EnumOptions to JSON.
             * @function toJSON
             * @memberof google.protobuf.EnumOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            EnumOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for EnumOptions
             * @function getTypeUrl
             * @memberof google.protobuf.EnumOptions
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            EnumOptions.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/google.protobuf.EnumOptions";
            };

            return EnumOptions;
        })();

        protobuf.EnumValueOptions = (function() {

            /**
             * Properties of an EnumValueOptions.
             * @memberof google.protobuf
             * @interface IEnumValueOptions
             * @property {boolean|null} [deprecated] EnumValueOptions deprecated
             * @property {google.protobuf.IFeatureSet|null} [features] EnumValueOptions features
             * @property {boolean|null} [debugRedact] EnumValueOptions debugRedact
             * @property {google.protobuf.FieldOptions.IFeatureSupport|null} [featureSupport] EnumValueOptions featureSupport
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] EnumValueOptions uninterpretedOption
             */

            /**
             * Constructs a new EnumValueOptions.
             * @memberof google.protobuf
             * @classdesc Represents an EnumValueOptions.
             * @implements IEnumValueOptions
             * @constructor
             * @param {google.protobuf.IEnumValueOptions=} [properties] Properties to set
             */
            function EnumValueOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * EnumValueOptions deprecated.
             * @member {boolean} deprecated
             * @memberof google.protobuf.EnumValueOptions
             * @instance
             */
            EnumValueOptions.prototype.deprecated = false;

            /**
             * EnumValueOptions features.
             * @member {google.protobuf.IFeatureSet|null|undefined} features
             * @memberof google.protobuf.EnumValueOptions
             * @instance
             */
            EnumValueOptions.prototype.features = null;

            /**
             * EnumValueOptions debugRedact.
             * @member {boolean} debugRedact
             * @memberof google.protobuf.EnumValueOptions
             * @instance
             */
            EnumValueOptions.prototype.debugRedact = false;

            /**
             * EnumValueOptions featureSupport.
             * @member {google.protobuf.FieldOptions.IFeatureSupport|null|undefined} featureSupport
             * @memberof google.protobuf.EnumValueOptions
             * @instance
             */
            EnumValueOptions.prototype.featureSupport = null;

            /**
             * EnumValueOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.EnumValueOptions
             * @instance
             */
            EnumValueOptions.prototype.uninterpretedOption = $util.emptyArray;

            /**
             * Creates a new EnumValueOptions instance using the specified properties.
             * @function create
             * @memberof google.protobuf.EnumValueOptions
             * @static
             * @param {google.protobuf.IEnumValueOptions=} [properties] Properties to set
             * @returns {google.protobuf.EnumValueOptions} EnumValueOptions instance
             */
            EnumValueOptions.create = function create(properties) {
                return new EnumValueOptions(properties);
            };

            /**
             * Encodes the specified EnumValueOptions message. Does not implicitly {@link google.protobuf.EnumValueOptions.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.EnumValueOptions
             * @static
             * @param {google.protobuf.IEnumValueOptions} message EnumValueOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnumValueOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.deprecated != null && Object.hasOwnProperty.call(message, "deprecated"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.deprecated);
                if (message.features != null && Object.hasOwnProperty.call(message, "features"))
                    $root.google.protobuf.FeatureSet.encode(message.features, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.debugRedact != null && Object.hasOwnProperty.call(message, "debugRedact"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.debugRedact);
                if (message.featureSupport != null && Object.hasOwnProperty.call(message, "featureSupport"))
                    $root.google.protobuf.FieldOptions.FeatureSupport.encode(message.featureSupport, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                    for (let i = 0; i < message.uninterpretedOption.length; ++i)
                        $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified EnumValueOptions message, length delimited. Does not implicitly {@link google.protobuf.EnumValueOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.EnumValueOptions
             * @static
             * @param {google.protobuf.IEnumValueOptions} message EnumValueOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnumValueOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an EnumValueOptions message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.EnumValueOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.EnumValueOptions} EnumValueOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnumValueOptions.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumValueOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.deprecated = reader.bool();
                            break;
                        }
                    case 2: {
                            message.features = $root.google.protobuf.FeatureSet.decode(reader, reader.uint32());
                            break;
                        }
                    case 3: {
                            message.debugRedact = reader.bool();
                            break;
                        }
                    case 4: {
                            message.featureSupport = $root.google.protobuf.FieldOptions.FeatureSupport.decode(reader, reader.uint32());
                            break;
                        }
                    case 999: {
                            if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                                message.uninterpretedOption = [];
                            message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an EnumValueOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.EnumValueOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.EnumValueOptions} EnumValueOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnumValueOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an EnumValueOptions message.
             * @function verify
             * @memberof google.protobuf.EnumValueOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            EnumValueOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    if (typeof message.deprecated !== "boolean")
                        return "deprecated: boolean expected";
                if (message.features != null && message.hasOwnProperty("features")) {
                    let error = $root.google.protobuf.FeatureSet.verify(message.features);
                    if (error)
                        return "features." + error;
                }
                if (message.debugRedact != null && message.hasOwnProperty("debugRedact"))
                    if (typeof message.debugRedact !== "boolean")
                        return "debugRedact: boolean expected";
                if (message.featureSupport != null && message.hasOwnProperty("featureSupport")) {
                    let error = $root.google.protobuf.FieldOptions.FeatureSupport.verify(message.featureSupport);
                    if (error)
                        return "featureSupport." + error;
                }
                if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                    if (!Array.isArray(message.uninterpretedOption))
                        return "uninterpretedOption: array expected";
                    for (let i = 0; i < message.uninterpretedOption.length; ++i) {
                        let error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                        if (error)
                            return "uninterpretedOption." + error;
                    }
                }
                return null;
            };

            /**
             * Creates an EnumValueOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.EnumValueOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.EnumValueOptions} EnumValueOptions
             */
            EnumValueOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.EnumValueOptions)
                    return object;
                let message = new $root.google.protobuf.EnumValueOptions();
                if (object.deprecated != null)
                    message.deprecated = Boolean(object.deprecated);
                if (object.features != null) {
                    if (typeof object.features !== "object")
                        throw TypeError(".google.protobuf.EnumValueOptions.features: object expected");
                    message.features = $root.google.protobuf.FeatureSet.fromObject(object.features);
                }
                if (object.debugRedact != null)
                    message.debugRedact = Boolean(object.debugRedact);
                if (object.featureSupport != null) {
                    if (typeof object.featureSupport !== "object")
                        throw TypeError(".google.protobuf.EnumValueOptions.featureSupport: object expected");
                    message.featureSupport = $root.google.protobuf.FieldOptions.FeatureSupport.fromObject(object.featureSupport);
                }
                if (object.uninterpretedOption) {
                    if (!Array.isArray(object.uninterpretedOption))
                        throw TypeError(".google.protobuf.EnumValueOptions.uninterpretedOption: array expected");
                    message.uninterpretedOption = [];
                    for (let i = 0; i < object.uninterpretedOption.length; ++i) {
                        if (typeof object.uninterpretedOption[i] !== "object")
                            throw TypeError(".google.protobuf.EnumValueOptions.uninterpretedOption: object expected");
                        message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from an EnumValueOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.EnumValueOptions
             * @static
             * @param {google.protobuf.EnumValueOptions} message EnumValueOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            EnumValueOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.uninterpretedOption = [];
                if (options.defaults) {
                    object.deprecated = false;
                    object.features = null;
                    object.debugRedact = false;
                    object.featureSupport = null;
                }
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    object.deprecated = message.deprecated;
                if (message.features != null && message.hasOwnProperty("features"))
                    object.features = $root.google.protobuf.FeatureSet.toObject(message.features, options);
                if (message.debugRedact != null && message.hasOwnProperty("debugRedact"))
                    object.debugRedact = message.debugRedact;
                if (message.featureSupport != null && message.hasOwnProperty("featureSupport"))
                    object.featureSupport = $root.google.protobuf.FieldOptions.FeatureSupport.toObject(message.featureSupport, options);
                if (message.uninterpretedOption && message.uninterpretedOption.length) {
                    object.uninterpretedOption = [];
                    for (let j = 0; j < message.uninterpretedOption.length; ++j)
                        object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
                }
                return object;
            };

            /**
             * Converts this EnumValueOptions to JSON.
             * @function toJSON
             * @memberof google.protobuf.EnumValueOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            EnumValueOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for EnumValueOptions
             * @function getTypeUrl
             * @memberof google.protobuf.EnumValueOptions
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            EnumValueOptions.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/google.protobuf.EnumValueOptions";
            };

            return EnumValueOptions;
        })();

        protobuf.ServiceOptions = (function() {

            /**
             * Properties of a ServiceOptions.
             * @memberof google.protobuf
             * @interface IServiceOptions
             * @property {google.protobuf.IFeatureSet|null} [features] ServiceOptions features
             * @property {boolean|null} [deprecated] ServiceOptions deprecated
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] ServiceOptions uninterpretedOption
             */

            /**
             * Constructs a new ServiceOptions.
             * @memberof google.protobuf
             * @classdesc Represents a ServiceOptions.
             * @implements IServiceOptions
             * @constructor
             * @param {google.protobuf.IServiceOptions=} [properties] Properties to set
             */
            function ServiceOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ServiceOptions features.
             * @member {google.protobuf.IFeatureSet|null|undefined} features
             * @memberof google.protobuf.ServiceOptions
             * @instance
             */
            ServiceOptions.prototype.features = null;

            /**
             * ServiceOptions deprecated.
             * @member {boolean} deprecated
             * @memberof google.protobuf.ServiceOptions
             * @instance
             */
            ServiceOptions.prototype.deprecated = false;

            /**
             * ServiceOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.ServiceOptions
             * @instance
             */
            ServiceOptions.prototype.uninterpretedOption = $util.emptyArray;

            /**
             * Creates a new ServiceOptions instance using the specified properties.
             * @function create
             * @memberof google.protobuf.ServiceOptions
             * @static
             * @param {google.protobuf.IServiceOptions=} [properties] Properties to set
             * @returns {google.protobuf.ServiceOptions} ServiceOptions instance
             */
            ServiceOptions.create = function create(properties) {
                return new ServiceOptions(properties);
            };

            /**
             * Encodes the specified ServiceOptions message. Does not implicitly {@link google.protobuf.ServiceOptions.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.ServiceOptions
             * @static
             * @param {google.protobuf.IServiceOptions} message ServiceOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ServiceOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.deprecated != null && Object.hasOwnProperty.call(message, "deprecated"))
                    writer.uint32(/* id 33, wireType 0 =*/264).bool(message.deprecated);
                if (message.features != null && Object.hasOwnProperty.call(message, "features"))
                    $root.google.protobuf.FeatureSet.encode(message.features, writer.uint32(/* id 34, wireType 2 =*/274).fork()).ldelim();
                if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                    for (let i = 0; i < message.uninterpretedOption.length; ++i)
                        $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ServiceOptions message, length delimited. Does not implicitly {@link google.protobuf.ServiceOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.ServiceOptions
             * @static
             * @param {google.protobuf.IServiceOptions} message ServiceOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ServiceOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ServiceOptions message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.ServiceOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.ServiceOptions} ServiceOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ServiceOptions.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.ServiceOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 34: {
                            message.features = $root.google.protobuf.FeatureSet.decode(reader, reader.uint32());
                            break;
                        }
                    case 33: {
                            message.deprecated = reader.bool();
                            break;
                        }
                    case 999: {
                            if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                                message.uninterpretedOption = [];
                            message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ServiceOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.ServiceOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.ServiceOptions} ServiceOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ServiceOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ServiceOptions message.
             * @function verify
             * @memberof google.protobuf.ServiceOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ServiceOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.features != null && message.hasOwnProperty("features")) {
                    let error = $root.google.protobuf.FeatureSet.verify(message.features);
                    if (error)
                        return "features." + error;
                }
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    if (typeof message.deprecated !== "boolean")
                        return "deprecated: boolean expected";
                if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                    if (!Array.isArray(message.uninterpretedOption))
                        return "uninterpretedOption: array expected";
                    for (let i = 0; i < message.uninterpretedOption.length; ++i) {
                        let error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                        if (error)
                            return "uninterpretedOption." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a ServiceOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.ServiceOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.ServiceOptions} ServiceOptions
             */
            ServiceOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.ServiceOptions)
                    return object;
                let message = new $root.google.protobuf.ServiceOptions();
                if (object.features != null) {
                    if (typeof object.features !== "object")
                        throw TypeError(".google.protobuf.ServiceOptions.features: object expected");
                    message.features = $root.google.protobuf.FeatureSet.fromObject(object.features);
                }
                if (object.deprecated != null)
                    message.deprecated = Boolean(object.deprecated);
                if (object.uninterpretedOption) {
                    if (!Array.isArray(object.uninterpretedOption))
                        throw TypeError(".google.protobuf.ServiceOptions.uninterpretedOption: array expected");
                    message.uninterpretedOption = [];
                    for (let i = 0; i < object.uninterpretedOption.length; ++i) {
                        if (typeof object.uninterpretedOption[i] !== "object")
                            throw TypeError(".google.protobuf.ServiceOptions.uninterpretedOption: object expected");
                        message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a ServiceOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.ServiceOptions
             * @static
             * @param {google.protobuf.ServiceOptions} message ServiceOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ServiceOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.uninterpretedOption = [];
                if (options.defaults) {
                    object.deprecated = false;
                    object.features = null;
                }
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    object.deprecated = message.deprecated;
                if (message.features != null && message.hasOwnProperty("features"))
                    object.features = $root.google.protobuf.FeatureSet.toObject(message.features, options);
                if (message.uninterpretedOption && message.uninterpretedOption.length) {
                    object.uninterpretedOption = [];
                    for (let j = 0; j < message.uninterpretedOption.length; ++j)
                        object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
                }
                return object;
            };

            /**
             * Converts this ServiceOptions to JSON.
             * @function toJSON
             * @memberof google.protobuf.ServiceOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ServiceOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ServiceOptions
             * @function getTypeUrl
             * @memberof google.protobuf.ServiceOptions
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ServiceOptions.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/google.protobuf.ServiceOptions";
            };

            return ServiceOptions;
        })();

        protobuf.MethodOptions = (function() {

            /**
             * Properties of a MethodOptions.
             * @memberof google.protobuf
             * @interface IMethodOptions
             * @property {boolean|null} [deprecated] MethodOptions deprecated
             * @property {google.protobuf.MethodOptions.IdempotencyLevel|null} [idempotencyLevel] MethodOptions idempotencyLevel
             * @property {google.protobuf.IFeatureSet|null} [features] MethodOptions features
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] MethodOptions uninterpretedOption
             */

            /**
             * Constructs a new MethodOptions.
             * @memberof google.protobuf
             * @classdesc Represents a MethodOptions.
             * @implements IMethodOptions
             * @constructor
             * @param {google.protobuf.IMethodOptions=} [properties] Properties to set
             */
            function MethodOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MethodOptions deprecated.
             * @member {boolean} deprecated
             * @memberof google.protobuf.MethodOptions
             * @instance
             */
            MethodOptions.prototype.deprecated = false;

            /**
             * MethodOptions idempotencyLevel.
             * @member {google.protobuf.MethodOptions.IdempotencyLevel} idempotencyLevel
             * @memberof google.protobuf.MethodOptions
             * @instance
             */
            MethodOptions.prototype.idempotencyLevel = 0;

            /**
             * MethodOptions features.
             * @member {google.protobuf.IFeatureSet|null|undefined} features
             * @memberof google.protobuf.MethodOptions
             * @instance
             */
            MethodOptions.prototype.features = null;

            /**
             * MethodOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.MethodOptions
             * @instance
             */
            MethodOptions.prototype.uninterpretedOption = $util.emptyArray;

            /**
             * Creates a new MethodOptions instance using the specified properties.
             * @function create
             * @memberof google.protobuf.MethodOptions
             * @static
             * @param {google.protobuf.IMethodOptions=} [properties] Properties to set
             * @returns {google.protobuf.MethodOptions} MethodOptions instance
             */
            MethodOptions.create = function create(properties) {
                return new MethodOptions(properties);
            };

            /**
             * Encodes the specified MethodOptions message. Does not implicitly {@link google.protobuf.MethodOptions.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.MethodOptions
             * @static
             * @param {google.protobuf.IMethodOptions} message MethodOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MethodOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.deprecated != null && Object.hasOwnProperty.call(message, "deprecated"))
                    writer.uint32(/* id 33, wireType 0 =*/264).bool(message.deprecated);
                if (message.idempotencyLevel != null && Object.hasOwnProperty.call(message, "idempotencyLevel"))
                    writer.uint32(/* id 34, wireType 0 =*/272).int32(message.idempotencyLevel);
                if (message.features != null && Object.hasOwnProperty.call(message, "features"))
                    $root.google.protobuf.FeatureSet.encode(message.features, writer.uint32(/* id 35, wireType 2 =*/282).fork()).ldelim();
                if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                    for (let i = 0; i < message.uninterpretedOption.length; ++i)
                        $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified MethodOptions message, length delimited. Does not implicitly {@link google.protobuf.MethodOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.MethodOptions
             * @static
             * @param {google.protobuf.IMethodOptions} message MethodOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MethodOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MethodOptions message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.MethodOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.MethodOptions} MethodOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MethodOptions.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.MethodOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 33: {
                            message.deprecated = reader.bool();
                            break;
                        }
                    case 34: {
                            message.idempotencyLevel = reader.int32();
                            break;
                        }
                    case 35: {
                            message.features = $root.google.protobuf.FeatureSet.decode(reader, reader.uint32());
                            break;
                        }
                    case 999: {
                            if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                                message.uninterpretedOption = [];
                            message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MethodOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.MethodOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.MethodOptions} MethodOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MethodOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MethodOptions message.
             * @function verify
             * @memberof google.protobuf.MethodOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MethodOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    if (typeof message.deprecated !== "boolean")
                        return "deprecated: boolean expected";
                if (message.idempotencyLevel != null && message.hasOwnProperty("idempotencyLevel"))
                    switch (message.idempotencyLevel) {
                    default:
                        return "idempotencyLevel: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                if (message.features != null && message.hasOwnProperty("features")) {
                    let error = $root.google.protobuf.FeatureSet.verify(message.features);
                    if (error)
                        return "features." + error;
                }
                if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                    if (!Array.isArray(message.uninterpretedOption))
                        return "uninterpretedOption: array expected";
                    for (let i = 0; i < message.uninterpretedOption.length; ++i) {
                        let error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                        if (error)
                            return "uninterpretedOption." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a MethodOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.MethodOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.MethodOptions} MethodOptions
             */
            MethodOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.MethodOptions)
                    return object;
                let message = new $root.google.protobuf.MethodOptions();
                if (object.deprecated != null)
                    message.deprecated = Boolean(object.deprecated);
                switch (object.idempotencyLevel) {
                default:
                    if (typeof object.idempotencyLevel === "number") {
                        message.idempotencyLevel = object.idempotencyLevel;
                        break;
                    }
                    break;
                case "IDEMPOTENCY_UNKNOWN":
                case 0:
                    message.idempotencyLevel = 0;
                    break;
                case "NO_SIDE_EFFECTS":
                case 1:
                    message.idempotencyLevel = 1;
                    break;
                case "IDEMPOTENT":
                case 2:
                    message.idempotencyLevel = 2;
                    break;
                }
                if (object.features != null) {
                    if (typeof object.features !== "object")
                        throw TypeError(".google.protobuf.MethodOptions.features: object expected");
                    message.features = $root.google.protobuf.FeatureSet.fromObject(object.features);
                }
                if (object.uninterpretedOption) {
                    if (!Array.isArray(object.uninterpretedOption))
                        throw TypeError(".google.protobuf.MethodOptions.uninterpretedOption: array expected");
                    message.uninterpretedOption = [];
                    for (let i = 0; i < object.uninterpretedOption.length; ++i) {
                        if (typeof object.uninterpretedOption[i] !== "object")
                            throw TypeError(".google.protobuf.MethodOptions.uninterpretedOption: object expected");
                        message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a MethodOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.MethodOptions
             * @static
             * @param {google.protobuf.MethodOptions} message MethodOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MethodOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.uninterpretedOption = [];
                if (options.defaults) {
                    object.deprecated = false;
                    object.idempotencyLevel = options.enums === String ? "IDEMPOTENCY_UNKNOWN" : 0;
                    object.features = null;
                }
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    object.deprecated = message.deprecated;
                if (message.idempotencyLevel != null && message.hasOwnProperty("idempotencyLevel"))
                    object.idempotencyLevel = options.enums === String ? $root.google.protobuf.MethodOptions.IdempotencyLevel[message.idempotencyLevel] === undefined ? message.idempotencyLevel : $root.google.protobuf.MethodOptions.IdempotencyLevel[message.idempotencyLevel] : message.idempotencyLevel;
                if (message.features != null && message.hasOwnProperty("features"))
                    object.features = $root.google.protobuf.FeatureSet.toObject(message.features, options);
                if (message.uninterpretedOption && message.uninterpretedOption.length) {
                    object.uninterpretedOption = [];
                    for (let j = 0; j < message.uninterpretedOption.length; ++j)
                        object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
                }
                return object;
            };

            /**
             * Converts this MethodOptions to JSON.
             * @function toJSON
             * @memberof google.protobuf.MethodOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MethodOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for MethodOptions
             * @function getTypeUrl
             * @memberof google.protobuf.MethodOptions
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            MethodOptions.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/google.protobuf.MethodOptions";
            };

            /**
             * IdempotencyLevel enum.
             * @name google.protobuf.MethodOptions.IdempotencyLevel
             * @enum {number}
             * @property {number} IDEMPOTENCY_UNKNOWN=0 IDEMPOTENCY_UNKNOWN value
             * @property {number} NO_SIDE_EFFECTS=1 NO_SIDE_EFFECTS value
             * @property {number} IDEMPOTENT=2 IDEMPOTENT value
             */
            MethodOptions.IdempotencyLevel = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "IDEMPOTENCY_UNKNOWN"] = 0;
                values[valuesById[1] = "NO_SIDE_EFFECTS"] = 1;
                values[valuesById[2] = "IDEMPOTENT"] = 2;
                return values;
            })();

            return MethodOptions;
        })();

        protobuf.UninterpretedOption = (function() {

            /**
             * Properties of an UninterpretedOption.
             * @memberof google.protobuf
             * @interface IUninterpretedOption
             * @property {Array.<google.protobuf.UninterpretedOption.INamePart>|null} [name] UninterpretedOption name
             * @property {string|null} [identifierValue] UninterpretedOption identifierValue
             * @property {number|Long|null} [positiveIntValue] UninterpretedOption positiveIntValue
             * @property {number|Long|null} [negativeIntValue] UninterpretedOption negativeIntValue
             * @property {number|null} [doubleValue] UninterpretedOption doubleValue
             * @property {Uint8Array|null} [stringValue] UninterpretedOption stringValue
             * @property {string|null} [aggregateValue] UninterpretedOption aggregateValue
             */

            /**
             * Constructs a new UninterpretedOption.
             * @memberof google.protobuf
             * @classdesc Represents an UninterpretedOption.
             * @implements IUninterpretedOption
             * @constructor
             * @param {google.protobuf.IUninterpretedOption=} [properties] Properties to set
             */
            function UninterpretedOption(properties) {
                this.name = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * UninterpretedOption name.
             * @member {Array.<google.protobuf.UninterpretedOption.INamePart>} name
             * @memberof google.protobuf.UninterpretedOption
             * @instance
             */
            UninterpretedOption.prototype.name = $util.emptyArray;

            /**
             * UninterpretedOption identifierValue.
             * @member {string} identifierValue
             * @memberof google.protobuf.UninterpretedOption
             * @instance
             */
            UninterpretedOption.prototype.identifierValue = "";

            /**
             * UninterpretedOption positiveIntValue.
             * @member {number|Long} positiveIntValue
             * @memberof google.protobuf.UninterpretedOption
             * @instance
             */
            UninterpretedOption.prototype.positiveIntValue = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * UninterpretedOption negativeIntValue.
             * @member {number|Long} negativeIntValue
             * @memberof google.protobuf.UninterpretedOption
             * @instance
             */
            UninterpretedOption.prototype.negativeIntValue = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * UninterpretedOption doubleValue.
             * @member {number} doubleValue
             * @memberof google.protobuf.UninterpretedOption
             * @instance
             */
            UninterpretedOption.prototype.doubleValue = 0;

            /**
             * UninterpretedOption stringValue.
             * @member {Uint8Array} stringValue
             * @memberof google.protobuf.UninterpretedOption
             * @instance
             */
            UninterpretedOption.prototype.stringValue = $util.newBuffer([]);

            /**
             * UninterpretedOption aggregateValue.
             * @member {string} aggregateValue
             * @memberof google.protobuf.UninterpretedOption
             * @instance
             */
            UninterpretedOption.prototype.aggregateValue = "";

            /**
             * Creates a new UninterpretedOption instance using the specified properties.
             * @function create
             * @memberof google.protobuf.UninterpretedOption
             * @static
             * @param {google.protobuf.IUninterpretedOption=} [properties] Properties to set
             * @returns {google.protobuf.UninterpretedOption} UninterpretedOption instance
             */
            UninterpretedOption.create = function create(properties) {
                return new UninterpretedOption(properties);
            };

            /**
             * Encodes the specified UninterpretedOption message. Does not implicitly {@link google.protobuf.UninterpretedOption.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.UninterpretedOption
             * @static
             * @param {google.protobuf.IUninterpretedOption} message UninterpretedOption message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UninterpretedOption.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.name.length)
                    for (let i = 0; i < message.name.length; ++i)
                        $root.google.protobuf.UninterpretedOption.NamePart.encode(message.name[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.identifierValue != null && Object.hasOwnProperty.call(message, "identifierValue"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.identifierValue);
                if (message.positiveIntValue != null && Object.hasOwnProperty.call(message, "positiveIntValue"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.positiveIntValue);
                if (message.negativeIntValue != null && Object.hasOwnProperty.call(message, "negativeIntValue"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int64(message.negativeIntValue);
                if (message.doubleValue != null && Object.hasOwnProperty.call(message, "doubleValue"))
                    writer.uint32(/* id 6, wireType 1 =*/49).double(message.doubleValue);
                if (message.stringValue != null && Object.hasOwnProperty.call(message, "stringValue"))
                    writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.stringValue);
                if (message.aggregateValue != null && Object.hasOwnProperty.call(message, "aggregateValue"))
                    writer.uint32(/* id 8, wireType 2 =*/66).string(message.aggregateValue);
                return writer;
            };

            /**
             * Encodes the specified UninterpretedOption message, length delimited. Does not implicitly {@link google.protobuf.UninterpretedOption.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.UninterpretedOption
             * @static
             * @param {google.protobuf.IUninterpretedOption} message UninterpretedOption message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UninterpretedOption.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an UninterpretedOption message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.UninterpretedOption
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.UninterpretedOption} UninterpretedOption
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UninterpretedOption.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.UninterpretedOption();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 2: {
                            if (!(message.name && message.name.length))
                                message.name = [];
                            message.name.push($root.google.protobuf.UninterpretedOption.NamePart.decode(reader, reader.uint32()));
                            break;
                        }
                    case 3: {
                            message.identifierValue = reader.string();
                            break;
                        }
                    case 4: {
                            message.positiveIntValue = reader.uint64();
                            break;
                        }
                    case 5: {
                            message.negativeIntValue = reader.int64();
                            break;
                        }
                    case 6: {
                            message.doubleValue = reader.double();
                            break;
                        }
                    case 7: {
                            message.stringValue = reader.bytes();
                            break;
                        }
                    case 8: {
                            message.aggregateValue = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an UninterpretedOption message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.UninterpretedOption
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.UninterpretedOption} UninterpretedOption
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UninterpretedOption.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an UninterpretedOption message.
             * @function verify
             * @memberof google.protobuf.UninterpretedOption
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            UninterpretedOption.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name")) {
                    if (!Array.isArray(message.name))
                        return "name: array expected";
                    for (let i = 0; i < message.name.length; ++i) {
                        let error = $root.google.protobuf.UninterpretedOption.NamePart.verify(message.name[i]);
                        if (error)
                            return "name." + error;
                    }
                }
                if (message.identifierValue != null && message.hasOwnProperty("identifierValue"))
                    if (!$util.isString(message.identifierValue))
                        return "identifierValue: string expected";
                if (message.positiveIntValue != null && message.hasOwnProperty("positiveIntValue"))
                    if (!$util.isInteger(message.positiveIntValue) && !(message.positiveIntValue && $util.isInteger(message.positiveIntValue.low) && $util.isInteger(message.positiveIntValue.high)))
                        return "positiveIntValue: integer|Long expected";
                if (message.negativeIntValue != null && message.hasOwnProperty("negativeIntValue"))
                    if (!$util.isInteger(message.negativeIntValue) && !(message.negativeIntValue && $util.isInteger(message.negativeIntValue.low) && $util.isInteger(message.negativeIntValue.high)))
                        return "negativeIntValue: integer|Long expected";
                if (message.doubleValue != null && message.hasOwnProperty("doubleValue"))
                    if (typeof message.doubleValue !== "number")
                        return "doubleValue: number expected";
                if (message.stringValue != null && message.hasOwnProperty("stringValue"))
                    if (!(message.stringValue && typeof message.stringValue.length === "number" || $util.isString(message.stringValue)))
                        return "stringValue: buffer expected";
                if (message.aggregateValue != null && message.hasOwnProperty("aggregateValue"))
                    if (!$util.isString(message.aggregateValue))
                        return "aggregateValue: string expected";
                return null;
            };

            /**
             * Creates an UninterpretedOption message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.UninterpretedOption
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.UninterpretedOption} UninterpretedOption
             */
            UninterpretedOption.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.UninterpretedOption)
                    return object;
                let message = new $root.google.protobuf.UninterpretedOption();
                if (object.name) {
                    if (!Array.isArray(object.name))
                        throw TypeError(".google.protobuf.UninterpretedOption.name: array expected");
                    message.name = [];
                    for (let i = 0; i < object.name.length; ++i) {
                        if (typeof object.name[i] !== "object")
                            throw TypeError(".google.protobuf.UninterpretedOption.name: object expected");
                        message.name[i] = $root.google.protobuf.UninterpretedOption.NamePart.fromObject(object.name[i]);
                    }
                }
                if (object.identifierValue != null)
                    message.identifierValue = String(object.identifierValue);
                if (object.positiveIntValue != null)
                    if ($util.Long)
                        (message.positiveIntValue = $util.Long.fromValue(object.positiveIntValue)).unsigned = true;
                    else if (typeof object.positiveIntValue === "string")
                        message.positiveIntValue = parseInt(object.positiveIntValue, 10);
                    else if (typeof object.positiveIntValue === "number")
                        message.positiveIntValue = object.positiveIntValue;
                    else if (typeof object.positiveIntValue === "object")
                        message.positiveIntValue = new $util.LongBits(object.positiveIntValue.low >>> 0, object.positiveIntValue.high >>> 0).toNumber(true);
                if (object.negativeIntValue != null)
                    if ($util.Long)
                        (message.negativeIntValue = $util.Long.fromValue(object.negativeIntValue)).unsigned = false;
                    else if (typeof object.negativeIntValue === "string")
                        message.negativeIntValue = parseInt(object.negativeIntValue, 10);
                    else if (typeof object.negativeIntValue === "number")
                        message.negativeIntValue = object.negativeIntValue;
                    else if (typeof object.negativeIntValue === "object")
                        message.negativeIntValue = new $util.LongBits(object.negativeIntValue.low >>> 0, object.negativeIntValue.high >>> 0).toNumber();
                if (object.doubleValue != null)
                    message.doubleValue = Number(object.doubleValue);
                if (object.stringValue != null)
                    if (typeof object.stringValue === "string")
                        $util.base64.decode(object.stringValue, message.stringValue = $util.newBuffer($util.base64.length(object.stringValue)), 0);
                    else if (object.stringValue.length >= 0)
                        message.stringValue = object.stringValue;
                if (object.aggregateValue != null)
                    message.aggregateValue = String(object.aggregateValue);
                return message;
            };

            /**
             * Creates a plain object from an UninterpretedOption message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.UninterpretedOption
             * @static
             * @param {google.protobuf.UninterpretedOption} message UninterpretedOption
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            UninterpretedOption.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.name = [];
                if (options.defaults) {
                    object.identifierValue = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.positiveIntValue = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.positiveIntValue = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, false);
                        object.negativeIntValue = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.negativeIntValue = options.longs === String ? "0" : 0;
                    object.doubleValue = 0;
                    if (options.bytes === String)
                        object.stringValue = "";
                    else {
                        object.stringValue = [];
                        if (options.bytes !== Array)
                            object.stringValue = $util.newBuffer(object.stringValue);
                    }
                    object.aggregateValue = "";
                }
                if (message.name && message.name.length) {
                    object.name = [];
                    for (let j = 0; j < message.name.length; ++j)
                        object.name[j] = $root.google.protobuf.UninterpretedOption.NamePart.toObject(message.name[j], options);
                }
                if (message.identifierValue != null && message.hasOwnProperty("identifierValue"))
                    object.identifierValue = message.identifierValue;
                if (message.positiveIntValue != null && message.hasOwnProperty("positiveIntValue"))
                    if (typeof message.positiveIntValue === "number")
                        object.positiveIntValue = options.longs === String ? String(message.positiveIntValue) : message.positiveIntValue;
                    else
                        object.positiveIntValue = options.longs === String ? $util.Long.prototype.toString.call(message.positiveIntValue) : options.longs === Number ? new $util.LongBits(message.positiveIntValue.low >>> 0, message.positiveIntValue.high >>> 0).toNumber(true) : message.positiveIntValue;
                if (message.negativeIntValue != null && message.hasOwnProperty("negativeIntValue"))
                    if (typeof message.negativeIntValue === "number")
                        object.negativeIntValue = options.longs === String ? String(message.negativeIntValue) : message.negativeIntValue;
                    else
                        object.negativeIntValue = options.longs === String ? $util.Long.prototype.toString.call(message.negativeIntValue) : options.longs === Number ? new $util.LongBits(message.negativeIntValue.low >>> 0, message.negativeIntValue.high >>> 0).toNumber() : message.negativeIntValue;
                if (message.doubleValue != null && message.hasOwnProperty("doubleValue"))
                    object.doubleValue = options.json && !isFinite(message.doubleValue) ? String(message.doubleValue) : message.doubleValue;
                if (message.stringValue != null && message.hasOwnProperty("stringValue"))
                    object.stringValue = options.bytes === String ? $util.base64.encode(message.stringValue, 0, message.stringValue.length) : options.bytes === Array ? Array.prototype.slice.call(message.stringValue) : message.stringValue;
                if (message.aggregateValue != null && message.hasOwnProperty("aggregateValue"))
                    object.aggregateValue = message.aggregateValue;
                return object;
            };

            /**
             * Converts this UninterpretedOption to JSON.
             * @function toJSON
             * @memberof google.protobuf.UninterpretedOption
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            UninterpretedOption.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for UninterpretedOption
             * @function getTypeUrl
             * @memberof google.protobuf.UninterpretedOption
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            UninterpretedOption.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/google.protobuf.UninterpretedOption";
            };

            UninterpretedOption.NamePart = (function() {

                /**
                 * Properties of a NamePart.
                 * @memberof google.protobuf.UninterpretedOption
                 * @interface INamePart
                 * @property {string} namePart NamePart namePart
                 * @property {boolean} isExtension NamePart isExtension
                 */

                /**
                 * Constructs a new NamePart.
                 * @memberof google.protobuf.UninterpretedOption
                 * @classdesc Represents a NamePart.
                 * @implements INamePart
                 * @constructor
                 * @param {google.protobuf.UninterpretedOption.INamePart=} [properties] Properties to set
                 */
                function NamePart(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * NamePart namePart.
                 * @member {string} namePart
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @instance
                 */
                NamePart.prototype.namePart = "";

                /**
                 * NamePart isExtension.
                 * @member {boolean} isExtension
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @instance
                 */
                NamePart.prototype.isExtension = false;

                /**
                 * Creates a new NamePart instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @static
                 * @param {google.protobuf.UninterpretedOption.INamePart=} [properties] Properties to set
                 * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart instance
                 */
                NamePart.create = function create(properties) {
                    return new NamePart(properties);
                };

                /**
                 * Encodes the specified NamePart message. Does not implicitly {@link google.protobuf.UninterpretedOption.NamePart.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @static
                 * @param {google.protobuf.UninterpretedOption.INamePart} message NamePart message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NamePart.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.namePart);
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.isExtension);
                    return writer;
                };

                /**
                 * Encodes the specified NamePart message, length delimited. Does not implicitly {@link google.protobuf.UninterpretedOption.NamePart.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @static
                 * @param {google.protobuf.UninterpretedOption.INamePart} message NamePart message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NamePart.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a NamePart message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NamePart.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.UninterpretedOption.NamePart();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                message.namePart = reader.string();
                                break;
                            }
                        case 2: {
                                message.isExtension = reader.bool();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    if (!message.hasOwnProperty("namePart"))
                        throw $util.ProtocolError("missing required 'namePart'", { instance: message });
                    if (!message.hasOwnProperty("isExtension"))
                        throw $util.ProtocolError("missing required 'isExtension'", { instance: message });
                    return message;
                };

                /**
                 * Decodes a NamePart message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NamePart.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a NamePart message.
                 * @function verify
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                NamePart.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (!$util.isString(message.namePart))
                        return "namePart: string expected";
                    if (typeof message.isExtension !== "boolean")
                        return "isExtension: boolean expected";
                    return null;
                };

                /**
                 * Creates a NamePart message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart
                 */
                NamePart.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.UninterpretedOption.NamePart)
                        return object;
                    let message = new $root.google.protobuf.UninterpretedOption.NamePart();
                    if (object.namePart != null)
                        message.namePart = String(object.namePart);
                    if (object.isExtension != null)
                        message.isExtension = Boolean(object.isExtension);
                    return message;
                };

                /**
                 * Creates a plain object from a NamePart message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @static
                 * @param {google.protobuf.UninterpretedOption.NamePart} message NamePart
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                NamePart.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.namePart = "";
                        object.isExtension = false;
                    }
                    if (message.namePart != null && message.hasOwnProperty("namePart"))
                        object.namePart = message.namePart;
                    if (message.isExtension != null && message.hasOwnProperty("isExtension"))
                        object.isExtension = message.isExtension;
                    return object;
                };

                /**
                 * Converts this NamePart to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                NamePart.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for NamePart
                 * @function getTypeUrl
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                NamePart.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/google.protobuf.UninterpretedOption.NamePart";
                };

                return NamePart;
            })();

            return UninterpretedOption;
        })();

        protobuf.FeatureSet = (function() {

            /**
             * Properties of a FeatureSet.
             * @memberof google.protobuf
             * @interface IFeatureSet
             * @property {google.protobuf.FeatureSet.FieldPresence|null} [fieldPresence] FeatureSet fieldPresence
             * @property {google.protobuf.FeatureSet.EnumType|null} [enumType] FeatureSet enumType
             * @property {google.protobuf.FeatureSet.RepeatedFieldEncoding|null} [repeatedFieldEncoding] FeatureSet repeatedFieldEncoding
             * @property {google.protobuf.FeatureSet.Utf8Validation|null} [utf8Validation] FeatureSet utf8Validation
             * @property {google.protobuf.FeatureSet.MessageEncoding|null} [messageEncoding] FeatureSet messageEncoding
             * @property {google.protobuf.FeatureSet.JsonFormat|null} [jsonFormat] FeatureSet jsonFormat
             * @property {google.protobuf.FeatureSet.EnforceNamingStyle|null} [enforceNamingStyle] FeatureSet enforceNamingStyle
             * @property {google.protobuf.FeatureSet.VisibilityFeature.DefaultSymbolVisibility|null} [defaultSymbolVisibility] FeatureSet defaultSymbolVisibility
             */

            /**
             * Constructs a new FeatureSet.
             * @memberof google.protobuf
             * @classdesc Represents a FeatureSet.
             * @implements IFeatureSet
             * @constructor
             * @param {google.protobuf.IFeatureSet=} [properties] Properties to set
             */
            function FeatureSet(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FeatureSet fieldPresence.
             * @member {google.protobuf.FeatureSet.FieldPresence} fieldPresence
             * @memberof google.protobuf.FeatureSet
             * @instance
             */
            FeatureSet.prototype.fieldPresence = 0;

            /**
             * FeatureSet enumType.
             * @member {google.protobuf.FeatureSet.EnumType} enumType
             * @memberof google.protobuf.FeatureSet
             * @instance
             */
            FeatureSet.prototype.enumType = 0;

            /**
             * FeatureSet repeatedFieldEncoding.
             * @member {google.protobuf.FeatureSet.RepeatedFieldEncoding} repeatedFieldEncoding
             * @memberof google.protobuf.FeatureSet
             * @instance
             */
            FeatureSet.prototype.repeatedFieldEncoding = 0;

            /**
             * FeatureSet utf8Validation.
             * @member {google.protobuf.FeatureSet.Utf8Validation} utf8Validation
             * @memberof google.protobuf.FeatureSet
             * @instance
             */
            FeatureSet.prototype.utf8Validation = 0;

            /**
             * FeatureSet messageEncoding.
             * @member {google.protobuf.FeatureSet.MessageEncoding} messageEncoding
             * @memberof google.protobuf.FeatureSet
             * @instance
             */
            FeatureSet.prototype.messageEncoding = 0;

            /**
             * FeatureSet jsonFormat.
             * @member {google.protobuf.FeatureSet.JsonFormat} jsonFormat
             * @memberof google.protobuf.FeatureSet
             * @instance
             */
            FeatureSet.prototype.jsonFormat = 0;

            /**
             * FeatureSet enforceNamingStyle.
             * @member {google.protobuf.FeatureSet.EnforceNamingStyle} enforceNamingStyle
             * @memberof google.protobuf.FeatureSet
             * @instance
             */
            FeatureSet.prototype.enforceNamingStyle = 0;

            /**
             * FeatureSet defaultSymbolVisibility.
             * @member {google.protobuf.FeatureSet.VisibilityFeature.DefaultSymbolVisibility} defaultSymbolVisibility
             * @memberof google.protobuf.FeatureSet
             * @instance
             */
            FeatureSet.prototype.defaultSymbolVisibility = 0;

            /**
             * Creates a new FeatureSet instance using the specified properties.
             * @function create
             * @memberof google.protobuf.FeatureSet
             * @static
             * @param {google.protobuf.IFeatureSet=} [properties] Properties to set
             * @returns {google.protobuf.FeatureSet} FeatureSet instance
             */
            FeatureSet.create = function create(properties) {
                return new FeatureSet(properties);
            };

            /**
             * Encodes the specified FeatureSet message. Does not implicitly {@link google.protobuf.FeatureSet.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.FeatureSet
             * @static
             * @param {google.protobuf.IFeatureSet} message FeatureSet message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FeatureSet.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.fieldPresence != null && Object.hasOwnProperty.call(message, "fieldPresence"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.fieldPresence);
                if (message.enumType != null && Object.hasOwnProperty.call(message, "enumType"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.enumType);
                if (message.repeatedFieldEncoding != null && Object.hasOwnProperty.call(message, "repeatedFieldEncoding"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.repeatedFieldEncoding);
                if (message.utf8Validation != null && Object.hasOwnProperty.call(message, "utf8Validation"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.utf8Validation);
                if (message.messageEncoding != null && Object.hasOwnProperty.call(message, "messageEncoding"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.messageEncoding);
                if (message.jsonFormat != null && Object.hasOwnProperty.call(message, "jsonFormat"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int32(message.jsonFormat);
                if (message.enforceNamingStyle != null && Object.hasOwnProperty.call(message, "enforceNamingStyle"))
                    writer.uint32(/* id 7, wireType 0 =*/56).int32(message.enforceNamingStyle);
                if (message.defaultSymbolVisibility != null && Object.hasOwnProperty.call(message, "defaultSymbolVisibility"))
                    writer.uint32(/* id 8, wireType 0 =*/64).int32(message.defaultSymbolVisibility);
                return writer;
            };

            /**
             * Encodes the specified FeatureSet message, length delimited. Does not implicitly {@link google.protobuf.FeatureSet.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.FeatureSet
             * @static
             * @param {google.protobuf.IFeatureSet} message FeatureSet message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FeatureSet.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FeatureSet message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.FeatureSet
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.FeatureSet} FeatureSet
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FeatureSet.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FeatureSet();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.fieldPresence = reader.int32();
                            break;
                        }
                    case 2: {
                            message.enumType = reader.int32();
                            break;
                        }
                    case 3: {
                            message.repeatedFieldEncoding = reader.int32();
                            break;
                        }
                    case 4: {
                            message.utf8Validation = reader.int32();
                            break;
                        }
                    case 5: {
                            message.messageEncoding = reader.int32();
                            break;
                        }
                    case 6: {
                            message.jsonFormat = reader.int32();
                            break;
                        }
                    case 7: {
                            message.enforceNamingStyle = reader.int32();
                            break;
                        }
                    case 8: {
                            message.defaultSymbolVisibility = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FeatureSet message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.FeatureSet
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.FeatureSet} FeatureSet
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FeatureSet.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FeatureSet message.
             * @function verify
             * @memberof google.protobuf.FeatureSet
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FeatureSet.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.fieldPresence != null && message.hasOwnProperty("fieldPresence"))
                    switch (message.fieldPresence) {
                    default:
                        return "fieldPresence: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                        break;
                    }
                if (message.enumType != null && message.hasOwnProperty("enumType"))
                    switch (message.enumType) {
                    default:
                        return "enumType: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                if (message.repeatedFieldEncoding != null && message.hasOwnProperty("repeatedFieldEncoding"))
                    switch (message.repeatedFieldEncoding) {
                    default:
                        return "repeatedFieldEncoding: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                if (message.utf8Validation != null && message.hasOwnProperty("utf8Validation"))
                    switch (message.utf8Validation) {
                    default:
                        return "utf8Validation: enum value expected";
                    case 0:
                    case 2:
                    case 3:
                        break;
                    }
                if (message.messageEncoding != null && message.hasOwnProperty("messageEncoding"))
                    switch (message.messageEncoding) {
                    default:
                        return "messageEncoding: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                if (message.jsonFormat != null && message.hasOwnProperty("jsonFormat"))
                    switch (message.jsonFormat) {
                    default:
                        return "jsonFormat: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                if (message.enforceNamingStyle != null && message.hasOwnProperty("enforceNamingStyle"))
                    switch (message.enforceNamingStyle) {
                    default:
                        return "enforceNamingStyle: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                if (message.defaultSymbolVisibility != null && message.hasOwnProperty("defaultSymbolVisibility"))
                    switch (message.defaultSymbolVisibility) {
                    default:
                        return "defaultSymbolVisibility: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                        break;
                    }
                return null;
            };

            /**
             * Creates a FeatureSet message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.FeatureSet
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.FeatureSet} FeatureSet
             */
            FeatureSet.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.FeatureSet)
                    return object;
                let message = new $root.google.protobuf.FeatureSet();
                switch (object.fieldPresence) {
                default:
                    if (typeof object.fieldPresence === "number") {
                        message.fieldPresence = object.fieldPresence;
                        break;
                    }
                    break;
                case "FIELD_PRESENCE_UNKNOWN":
                case 0:
                    message.fieldPresence = 0;
                    break;
                case "EXPLICIT":
                case 1:
                    message.fieldPresence = 1;
                    break;
                case "IMPLICIT":
                case 2:
                    message.fieldPresence = 2;
                    break;
                case "LEGACY_REQUIRED":
                case 3:
                    message.fieldPresence = 3;
                    break;
                }
                switch (object.enumType) {
                default:
                    if (typeof object.enumType === "number") {
                        message.enumType = object.enumType;
                        break;
                    }
                    break;
                case "ENUM_TYPE_UNKNOWN":
                case 0:
                    message.enumType = 0;
                    break;
                case "OPEN":
                case 1:
                    message.enumType = 1;
                    break;
                case "CLOSED":
                case 2:
                    message.enumType = 2;
                    break;
                }
                switch (object.repeatedFieldEncoding) {
                default:
                    if (typeof object.repeatedFieldEncoding === "number") {
                        message.repeatedFieldEncoding = object.repeatedFieldEncoding;
                        break;
                    }
                    break;
                case "REPEATED_FIELD_ENCODING_UNKNOWN":
                case 0:
                    message.repeatedFieldEncoding = 0;
                    break;
                case "PACKED":
                case 1:
                    message.repeatedFieldEncoding = 1;
                    break;
                case "EXPANDED":
                case 2:
                    message.repeatedFieldEncoding = 2;
                    break;
                }
                switch (object.utf8Validation) {
                default:
                    if (typeof object.utf8Validation === "number") {
                        message.utf8Validation = object.utf8Validation;
                        break;
                    }
                    break;
                case "UTF8_VALIDATION_UNKNOWN":
                case 0:
                    message.utf8Validation = 0;
                    break;
                case "VERIFY":
                case 2:
                    message.utf8Validation = 2;
                    break;
                case "NONE":
                case 3:
                    message.utf8Validation = 3;
                    break;
                }
                switch (object.messageEncoding) {
                default:
                    if (typeof object.messageEncoding === "number") {
                        message.messageEncoding = object.messageEncoding;
                        break;
                    }
                    break;
                case "MESSAGE_ENCODING_UNKNOWN":
                case 0:
                    message.messageEncoding = 0;
                    break;
                case "LENGTH_PREFIXED":
                case 1:
                    message.messageEncoding = 1;
                    break;
                case "DELIMITED":
                case 2:
                    message.messageEncoding = 2;
                    break;
                }
                switch (object.jsonFormat) {
                default:
                    if (typeof object.jsonFormat === "number") {
                        message.jsonFormat = object.jsonFormat;
                        break;
                    }
                    break;
                case "JSON_FORMAT_UNKNOWN":
                case 0:
                    message.jsonFormat = 0;
                    break;
                case "ALLOW":
                case 1:
                    message.jsonFormat = 1;
                    break;
                case "LEGACY_BEST_EFFORT":
                case 2:
                    message.jsonFormat = 2;
                    break;
                }
                switch (object.enforceNamingStyle) {
                default:
                    if (typeof object.enforceNamingStyle === "number") {
                        message.enforceNamingStyle = object.enforceNamingStyle;
                        break;
                    }
                    break;
                case "ENFORCE_NAMING_STYLE_UNKNOWN":
                case 0:
                    message.enforceNamingStyle = 0;
                    break;
                case "STYLE2024":
                case 1:
                    message.enforceNamingStyle = 1;
                    break;
                case "STYLE_LEGACY":
                case 2:
                    message.enforceNamingStyle = 2;
                    break;
                }
                switch (object.defaultSymbolVisibility) {
                default:
                    if (typeof object.defaultSymbolVisibility === "number") {
                        message.defaultSymbolVisibility = object.defaultSymbolVisibility;
                        break;
                    }
                    break;
                case "DEFAULT_SYMBOL_VISIBILITY_UNKNOWN":
                case 0:
                    message.defaultSymbolVisibility = 0;
                    break;
                case "EXPORT_ALL":
                case 1:
                    message.defaultSymbolVisibility = 1;
                    break;
                case "EXPORT_TOP_LEVEL":
                case 2:
                    message.defaultSymbolVisibility = 2;
                    break;
                case "LOCAL_ALL":
                case 3:
                    message.defaultSymbolVisibility = 3;
                    break;
                case "STRICT":
                case 4:
                    message.defaultSymbolVisibility = 4;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from a FeatureSet message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.FeatureSet
             * @static
             * @param {google.protobuf.FeatureSet} message FeatureSet
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FeatureSet.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.fieldPresence = options.enums === String ? "FIELD_PRESENCE_UNKNOWN" : 0;
                    object.enumType = options.enums === String ? "ENUM_TYPE_UNKNOWN" : 0;
                    object.repeatedFieldEncoding = options.enums === String ? "REPEATED_FIELD_ENCODING_UNKNOWN" : 0;
                    object.utf8Validation = options.enums === String ? "UTF8_VALIDATION_UNKNOWN" : 0;
                    object.messageEncoding = options.enums === String ? "MESSAGE_ENCODING_UNKNOWN" : 0;
                    object.jsonFormat = options.enums === String ? "JSON_FORMAT_UNKNOWN" : 0;
                    object.enforceNamingStyle = options.enums === String ? "ENFORCE_NAMING_STYLE_UNKNOWN" : 0;
                    object.defaultSymbolVisibility = options.enums === String ? "DEFAULT_SYMBOL_VISIBILITY_UNKNOWN" : 0;
                }
                if (message.fieldPresence != null && message.hasOwnProperty("fieldPresence"))
                    object.fieldPresence = options.enums === String ? $root.google.protobuf.FeatureSet.FieldPresence[message.fieldPresence] === undefined ? message.fieldPresence : $root.google.protobuf.FeatureSet.FieldPresence[message.fieldPresence] : message.fieldPresence;
                if (message.enumType != null && message.hasOwnProperty("enumType"))
                    object.enumType = options.enums === String ? $root.google.protobuf.FeatureSet.EnumType[message.enumType] === undefined ? message.enumType : $root.google.protobuf.FeatureSet.EnumType[message.enumType] : message.enumType;
                if (message.repeatedFieldEncoding != null && message.hasOwnProperty("repeatedFieldEncoding"))
                    object.repeatedFieldEncoding = options.enums === String ? $root.google.protobuf.FeatureSet.RepeatedFieldEncoding[message.repeatedFieldEncoding] === undefined ? message.repeatedFieldEncoding : $root.google.protobuf.FeatureSet.RepeatedFieldEncoding[message.repeatedFieldEncoding] : message.repeatedFieldEncoding;
                if (message.utf8Validation != null && message.hasOwnProperty("utf8Validation"))
                    object.utf8Validation = options.enums === String ? $root.google.protobuf.FeatureSet.Utf8Validation[message.utf8Validation] === undefined ? message.utf8Validation : $root.google.protobuf.FeatureSet.Utf8Validation[message.utf8Validation] : message.utf8Validation;
                if (message.messageEncoding != null && message.hasOwnProperty("messageEncoding"))
                    object.messageEncoding = options.enums === String ? $root.google.protobuf.FeatureSet.MessageEncoding[message.messageEncoding] === undefined ? message.messageEncoding : $root.google.protobuf.FeatureSet.MessageEncoding[message.messageEncoding] : message.messageEncoding;
                if (message.jsonFormat != null && message.hasOwnProperty("jsonFormat"))
                    object.jsonFormat = options.enums === String ? $root.google.protobuf.FeatureSet.JsonFormat[message.jsonFormat] === undefined ? message.jsonFormat : $root.google.protobuf.FeatureSet.JsonFormat[message.jsonFormat] : message.jsonFormat;
                if (message.enforceNamingStyle != null && message.hasOwnProperty("enforceNamingStyle"))
                    object.enforceNamingStyle = options.enums === String ? $root.google.protobuf.FeatureSet.EnforceNamingStyle[message.enforceNamingStyle] === undefined ? message.enforceNamingStyle : $root.google.protobuf.FeatureSet.EnforceNamingStyle[message.enforceNamingStyle] : message.enforceNamingStyle;
                if (message.defaultSymbolVisibility != null && message.hasOwnProperty("defaultSymbolVisibility"))
                    object.defaultSymbolVisibility = options.enums === String ? $root.google.protobuf.FeatureSet.VisibilityFeature.DefaultSymbolVisibility[message.defaultSymbolVisibility] === undefined ? message.defaultSymbolVisibility : $root.google.protobuf.FeatureSet.VisibilityFeature.DefaultSymbolVisibility[message.defaultSymbolVisibility] : message.defaultSymbolVisibility;
                return object;
            };

            /**
             * Converts this FeatureSet to JSON.
             * @function toJSON
             * @memberof google.protobuf.FeatureSet
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FeatureSet.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for FeatureSet
             * @function getTypeUrl
             * @memberof google.protobuf.FeatureSet
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            FeatureSet.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/google.protobuf.FeatureSet";
            };

            /**
             * FieldPresence enum.
             * @name google.protobuf.FeatureSet.FieldPresence
             * @enum {number}
             * @property {number} FIELD_PRESENCE_UNKNOWN=0 FIELD_PRESENCE_UNKNOWN value
             * @property {number} EXPLICIT=1 EXPLICIT value
             * @property {number} IMPLICIT=2 IMPLICIT value
             * @property {number} LEGACY_REQUIRED=3 LEGACY_REQUIRED value
             */
            FeatureSet.FieldPresence = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "FIELD_PRESENCE_UNKNOWN"] = 0;
                values[valuesById[1] = "EXPLICIT"] = 1;
                values[valuesById[2] = "IMPLICIT"] = 2;
                values[valuesById[3] = "LEGACY_REQUIRED"] = 3;
                return values;
            })();

            /**
             * EnumType enum.
             * @name google.protobuf.FeatureSet.EnumType
             * @enum {number}
             * @property {number} ENUM_TYPE_UNKNOWN=0 ENUM_TYPE_UNKNOWN value
             * @property {number} OPEN=1 OPEN value
             * @property {number} CLOSED=2 CLOSED value
             */
            FeatureSet.EnumType = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "ENUM_TYPE_UNKNOWN"] = 0;
                values[valuesById[1] = "OPEN"] = 1;
                values[valuesById[2] = "CLOSED"] = 2;
                return values;
            })();

            /**
             * RepeatedFieldEncoding enum.
             * @name google.protobuf.FeatureSet.RepeatedFieldEncoding
             * @enum {number}
             * @property {number} REPEATED_FIELD_ENCODING_UNKNOWN=0 REPEATED_FIELD_ENCODING_UNKNOWN value
             * @property {number} PACKED=1 PACKED value
             * @property {number} EXPANDED=2 EXPANDED value
             */
            FeatureSet.RepeatedFieldEncoding = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "REPEATED_FIELD_ENCODING_UNKNOWN"] = 0;
                values[valuesById[1] = "PACKED"] = 1;
                values[valuesById[2] = "EXPANDED"] = 2;
                return values;
            })();

            /**
             * Utf8Validation enum.
             * @name google.protobuf.FeatureSet.Utf8Validation
             * @enum {number}
             * @property {number} UTF8_VALIDATION_UNKNOWN=0 UTF8_VALIDATION_UNKNOWN value
             * @property {number} VERIFY=2 VERIFY value
             * @property {number} NONE=3 NONE value
             */
            FeatureSet.Utf8Validation = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "UTF8_VALIDATION_UNKNOWN"] = 0;
                values[valuesById[2] = "VERIFY"] = 2;
                values[valuesById[3] = "NONE"] = 3;
                return values;
            })();

            /**
             * MessageEncoding enum.
             * @name google.protobuf.FeatureSet.MessageEncoding
             * @enum {number}
             * @property {number} MESSAGE_ENCODING_UNKNOWN=0 MESSAGE_ENCODING_UNKNOWN value
             * @property {number} LENGTH_PREFIXED=1 LENGTH_PREFIXED value
             * @property {number} DELIMITED=2 DELIMITED value
             */
            FeatureSet.MessageEncoding = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "MESSAGE_ENCODING_UNKNOWN"] = 0;
                values[valuesById[1] = "LENGTH_PREFIXED"] = 1;
                values[valuesById[2] = "DELIMITED"] = 2;
                return values;
            })();

            /**
             * JsonFormat enum.
             * @name google.protobuf.FeatureSet.JsonFormat
             * @enum {number}
             * @property {number} JSON_FORMAT_UNKNOWN=0 JSON_FORMAT_UNKNOWN value
             * @property {number} ALLOW=1 ALLOW value
             * @property {number} LEGACY_BEST_EFFORT=2 LEGACY_BEST_EFFORT value
             */
            FeatureSet.JsonFormat = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "JSON_FORMAT_UNKNOWN"] = 0;
                values[valuesById[1] = "ALLOW"] = 1;
                values[valuesById[2] = "LEGACY_BEST_EFFORT"] = 2;
                return values;
            })();

            /**
             * EnforceNamingStyle enum.
             * @name google.protobuf.FeatureSet.EnforceNamingStyle
             * @enum {number}
             * @property {number} ENFORCE_NAMING_STYLE_UNKNOWN=0 ENFORCE_NAMING_STYLE_UNKNOWN value
             * @property {number} STYLE2024=1 STYLE2024 value
             * @property {number} STYLE_LEGACY=2 STYLE_LEGACY value
             */
            FeatureSet.EnforceNamingStyle = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "ENFORCE_NAMING_STYLE_UNKNOWN"] = 0;
                values[valuesById[1] = "STYLE2024"] = 1;
                values[valuesById[2] = "STYLE_LEGACY"] = 2;
                return values;
            })();

            FeatureSet.VisibilityFeature = (function() {

                /**
                 * Properties of a VisibilityFeature.
                 * @memberof google.protobuf.FeatureSet
                 * @interface IVisibilityFeature
                 */

                /**
                 * Constructs a new VisibilityFeature.
                 * @memberof google.protobuf.FeatureSet
                 * @classdesc Represents a VisibilityFeature.
                 * @implements IVisibilityFeature
                 * @constructor
                 * @param {google.protobuf.FeatureSet.IVisibilityFeature=} [properties] Properties to set
                 */
                function VisibilityFeature(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Creates a new VisibilityFeature instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.FeatureSet.VisibilityFeature
                 * @static
                 * @param {google.protobuf.FeatureSet.IVisibilityFeature=} [properties] Properties to set
                 * @returns {google.protobuf.FeatureSet.VisibilityFeature} VisibilityFeature instance
                 */
                VisibilityFeature.create = function create(properties) {
                    return new VisibilityFeature(properties);
                };

                /**
                 * Encodes the specified VisibilityFeature message. Does not implicitly {@link google.protobuf.FeatureSet.VisibilityFeature.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.FeatureSet.VisibilityFeature
                 * @static
                 * @param {google.protobuf.FeatureSet.IVisibilityFeature} message VisibilityFeature message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                VisibilityFeature.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };

                /**
                 * Encodes the specified VisibilityFeature message, length delimited. Does not implicitly {@link google.protobuf.FeatureSet.VisibilityFeature.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.FeatureSet.VisibilityFeature
                 * @static
                 * @param {google.protobuf.FeatureSet.IVisibilityFeature} message VisibilityFeature message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                VisibilityFeature.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a VisibilityFeature message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.FeatureSet.VisibilityFeature
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.FeatureSet.VisibilityFeature} VisibilityFeature
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                VisibilityFeature.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FeatureSet.VisibilityFeature();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a VisibilityFeature message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.FeatureSet.VisibilityFeature
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.FeatureSet.VisibilityFeature} VisibilityFeature
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                VisibilityFeature.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a VisibilityFeature message.
                 * @function verify
                 * @memberof google.protobuf.FeatureSet.VisibilityFeature
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                VisibilityFeature.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };

                /**
                 * Creates a VisibilityFeature message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.FeatureSet.VisibilityFeature
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.FeatureSet.VisibilityFeature} VisibilityFeature
                 */
                VisibilityFeature.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.FeatureSet.VisibilityFeature)
                        return object;
                    return new $root.google.protobuf.FeatureSet.VisibilityFeature();
                };

                /**
                 * Creates a plain object from a VisibilityFeature message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.FeatureSet.VisibilityFeature
                 * @static
                 * @param {google.protobuf.FeatureSet.VisibilityFeature} message VisibilityFeature
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                VisibilityFeature.toObject = function toObject() {
                    return {};
                };

                /**
                 * Converts this VisibilityFeature to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.FeatureSet.VisibilityFeature
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                VisibilityFeature.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for VisibilityFeature
                 * @function getTypeUrl
                 * @memberof google.protobuf.FeatureSet.VisibilityFeature
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                VisibilityFeature.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/google.protobuf.FeatureSet.VisibilityFeature";
                };

                /**
                 * DefaultSymbolVisibility enum.
                 * @name google.protobuf.FeatureSet.VisibilityFeature.DefaultSymbolVisibility
                 * @enum {number}
                 * @property {number} DEFAULT_SYMBOL_VISIBILITY_UNKNOWN=0 DEFAULT_SYMBOL_VISIBILITY_UNKNOWN value
                 * @property {number} EXPORT_ALL=1 EXPORT_ALL value
                 * @property {number} EXPORT_TOP_LEVEL=2 EXPORT_TOP_LEVEL value
                 * @property {number} LOCAL_ALL=3 LOCAL_ALL value
                 * @property {number} STRICT=4 STRICT value
                 */
                VisibilityFeature.DefaultSymbolVisibility = (function() {
                    const valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "DEFAULT_SYMBOL_VISIBILITY_UNKNOWN"] = 0;
                    values[valuesById[1] = "EXPORT_ALL"] = 1;
                    values[valuesById[2] = "EXPORT_TOP_LEVEL"] = 2;
                    values[valuesById[3] = "LOCAL_ALL"] = 3;
                    values[valuesById[4] = "STRICT"] = 4;
                    return values;
                })();

                return VisibilityFeature;
            })();

            return FeatureSet;
        })();

        protobuf.FeatureSetDefaults = (function() {

            /**
             * Properties of a FeatureSetDefaults.
             * @memberof google.protobuf
             * @interface IFeatureSetDefaults
             * @property {Array.<google.protobuf.FeatureSetDefaults.IFeatureSetEditionDefault>|null} [defaults] FeatureSetDefaults defaults
             * @property {google.protobuf.Edition|null} [minimumEdition] FeatureSetDefaults minimumEdition
             * @property {google.protobuf.Edition|null} [maximumEdition] FeatureSetDefaults maximumEdition
             */

            /**
             * Constructs a new FeatureSetDefaults.
             * @memberof google.protobuf
             * @classdesc Represents a FeatureSetDefaults.
             * @implements IFeatureSetDefaults
             * @constructor
             * @param {google.protobuf.IFeatureSetDefaults=} [properties] Properties to set
             */
            function FeatureSetDefaults(properties) {
                this.defaults = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FeatureSetDefaults defaults.
             * @member {Array.<google.protobuf.FeatureSetDefaults.IFeatureSetEditionDefault>} defaults
             * @memberof google.protobuf.FeatureSetDefaults
             * @instance
             */
            FeatureSetDefaults.prototype.defaults = $util.emptyArray;

            /**
             * FeatureSetDefaults minimumEdition.
             * @member {google.protobuf.Edition} minimumEdition
             * @memberof google.protobuf.FeatureSetDefaults
             * @instance
             */
            FeatureSetDefaults.prototype.minimumEdition = 0;

            /**
             * FeatureSetDefaults maximumEdition.
             * @member {google.protobuf.Edition} maximumEdition
             * @memberof google.protobuf.FeatureSetDefaults
             * @instance
             */
            FeatureSetDefaults.prototype.maximumEdition = 0;

            /**
             * Creates a new FeatureSetDefaults instance using the specified properties.
             * @function create
             * @memberof google.protobuf.FeatureSetDefaults
             * @static
             * @param {google.protobuf.IFeatureSetDefaults=} [properties] Properties to set
             * @returns {google.protobuf.FeatureSetDefaults} FeatureSetDefaults instance
             */
            FeatureSetDefaults.create = function create(properties) {
                return new FeatureSetDefaults(properties);
            };

            /**
             * Encodes the specified FeatureSetDefaults message. Does not implicitly {@link google.protobuf.FeatureSetDefaults.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.FeatureSetDefaults
             * @static
             * @param {google.protobuf.IFeatureSetDefaults} message FeatureSetDefaults message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FeatureSetDefaults.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.defaults != null && message.defaults.length)
                    for (let i = 0; i < message.defaults.length; ++i)
                        $root.google.protobuf.FeatureSetDefaults.FeatureSetEditionDefault.encode(message.defaults[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.minimumEdition != null && Object.hasOwnProperty.call(message, "minimumEdition"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.minimumEdition);
                if (message.maximumEdition != null && Object.hasOwnProperty.call(message, "maximumEdition"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.maximumEdition);
                return writer;
            };

            /**
             * Encodes the specified FeatureSetDefaults message, length delimited. Does not implicitly {@link google.protobuf.FeatureSetDefaults.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.FeatureSetDefaults
             * @static
             * @param {google.protobuf.IFeatureSetDefaults} message FeatureSetDefaults message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FeatureSetDefaults.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FeatureSetDefaults message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.FeatureSetDefaults
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.FeatureSetDefaults} FeatureSetDefaults
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FeatureSetDefaults.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FeatureSetDefaults();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.defaults && message.defaults.length))
                                message.defaults = [];
                            message.defaults.push($root.google.protobuf.FeatureSetDefaults.FeatureSetEditionDefault.decode(reader, reader.uint32()));
                            break;
                        }
                    case 4: {
                            message.minimumEdition = reader.int32();
                            break;
                        }
                    case 5: {
                            message.maximumEdition = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FeatureSetDefaults message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.FeatureSetDefaults
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.FeatureSetDefaults} FeatureSetDefaults
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FeatureSetDefaults.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FeatureSetDefaults message.
             * @function verify
             * @memberof google.protobuf.FeatureSetDefaults
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FeatureSetDefaults.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.defaults != null && message.hasOwnProperty("defaults")) {
                    if (!Array.isArray(message.defaults))
                        return "defaults: array expected";
                    for (let i = 0; i < message.defaults.length; ++i) {
                        let error = $root.google.protobuf.FeatureSetDefaults.FeatureSetEditionDefault.verify(message.defaults[i]);
                        if (error)
                            return "defaults." + error;
                    }
                }
                if (message.minimumEdition != null && message.hasOwnProperty("minimumEdition"))
                    switch (message.minimumEdition) {
                    default:
                        return "minimumEdition: enum value expected";
                    case 0:
                    case 900:
                    case 998:
                    case 999:
                    case 1000:
                    case 1001:
                    case 1:
                    case 2:
                    case 99997:
                    case 99998:
                    case 99999:
                    case 2147483647:
                        break;
                    }
                if (message.maximumEdition != null && message.hasOwnProperty("maximumEdition"))
                    switch (message.maximumEdition) {
                    default:
                        return "maximumEdition: enum value expected";
                    case 0:
                    case 900:
                    case 998:
                    case 999:
                    case 1000:
                    case 1001:
                    case 1:
                    case 2:
                    case 99997:
                    case 99998:
                    case 99999:
                    case 2147483647:
                        break;
                    }
                return null;
            };

            /**
             * Creates a FeatureSetDefaults message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.FeatureSetDefaults
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.FeatureSetDefaults} FeatureSetDefaults
             */
            FeatureSetDefaults.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.FeatureSetDefaults)
                    return object;
                let message = new $root.google.protobuf.FeatureSetDefaults();
                if (object.defaults) {
                    if (!Array.isArray(object.defaults))
                        throw TypeError(".google.protobuf.FeatureSetDefaults.defaults: array expected");
                    message.defaults = [];
                    for (let i = 0; i < object.defaults.length; ++i) {
                        if (typeof object.defaults[i] !== "object")
                            throw TypeError(".google.protobuf.FeatureSetDefaults.defaults: object expected");
                        message.defaults[i] = $root.google.protobuf.FeatureSetDefaults.FeatureSetEditionDefault.fromObject(object.defaults[i]);
                    }
                }
                switch (object.minimumEdition) {
                default:
                    if (typeof object.minimumEdition === "number") {
                        message.minimumEdition = object.minimumEdition;
                        break;
                    }
                    break;
                case "EDITION_UNKNOWN":
                case 0:
                    message.minimumEdition = 0;
                    break;
                case "EDITION_LEGACY":
                case 900:
                    message.minimumEdition = 900;
                    break;
                case "EDITION_PROTO2":
                case 998:
                    message.minimumEdition = 998;
                    break;
                case "EDITION_PROTO3":
                case 999:
                    message.minimumEdition = 999;
                    break;
                case "EDITION_2023":
                case 1000:
                    message.minimumEdition = 1000;
                    break;
                case "EDITION_2024":
                case 1001:
                    message.minimumEdition = 1001;
                    break;
                case "EDITION_1_TEST_ONLY":
                case 1:
                    message.minimumEdition = 1;
                    break;
                case "EDITION_2_TEST_ONLY":
                case 2:
                    message.minimumEdition = 2;
                    break;
                case "EDITION_99997_TEST_ONLY":
                case 99997:
                    message.minimumEdition = 99997;
                    break;
                case "EDITION_99998_TEST_ONLY":
                case 99998:
                    message.minimumEdition = 99998;
                    break;
                case "EDITION_99999_TEST_ONLY":
                case 99999:
                    message.minimumEdition = 99999;
                    break;
                case "EDITION_MAX":
                case 2147483647:
                    message.minimumEdition = 2147483647;
                    break;
                }
                switch (object.maximumEdition) {
                default:
                    if (typeof object.maximumEdition === "number") {
                        message.maximumEdition = object.maximumEdition;
                        break;
                    }
                    break;
                case "EDITION_UNKNOWN":
                case 0:
                    message.maximumEdition = 0;
                    break;
                case "EDITION_LEGACY":
                case 900:
                    message.maximumEdition = 900;
                    break;
                case "EDITION_PROTO2":
                case 998:
                    message.maximumEdition = 998;
                    break;
                case "EDITION_PROTO3":
                case 999:
                    message.maximumEdition = 999;
                    break;
                case "EDITION_2023":
                case 1000:
                    message.maximumEdition = 1000;
                    break;
                case "EDITION_2024":
                case 1001:
                    message.maximumEdition = 1001;
                    break;
                case "EDITION_1_TEST_ONLY":
                case 1:
                    message.maximumEdition = 1;
                    break;
                case "EDITION_2_TEST_ONLY":
                case 2:
                    message.maximumEdition = 2;
                    break;
                case "EDITION_99997_TEST_ONLY":
                case 99997:
                    message.maximumEdition = 99997;
                    break;
                case "EDITION_99998_TEST_ONLY":
                case 99998:
                    message.maximumEdition = 99998;
                    break;
                case "EDITION_99999_TEST_ONLY":
                case 99999:
                    message.maximumEdition = 99999;
                    break;
                case "EDITION_MAX":
                case 2147483647:
                    message.maximumEdition = 2147483647;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from a FeatureSetDefaults message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.FeatureSetDefaults
             * @static
             * @param {google.protobuf.FeatureSetDefaults} message FeatureSetDefaults
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FeatureSetDefaults.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.defaults = [];
                if (options.defaults) {
                    object.minimumEdition = options.enums === String ? "EDITION_UNKNOWN" : 0;
                    object.maximumEdition = options.enums === String ? "EDITION_UNKNOWN" : 0;
                }
                if (message.defaults && message.defaults.length) {
                    object.defaults = [];
                    for (let j = 0; j < message.defaults.length; ++j)
                        object.defaults[j] = $root.google.protobuf.FeatureSetDefaults.FeatureSetEditionDefault.toObject(message.defaults[j], options);
                }
                if (message.minimumEdition != null && message.hasOwnProperty("minimumEdition"))
                    object.minimumEdition = options.enums === String ? $root.google.protobuf.Edition[message.minimumEdition] === undefined ? message.minimumEdition : $root.google.protobuf.Edition[message.minimumEdition] : message.minimumEdition;
                if (message.maximumEdition != null && message.hasOwnProperty("maximumEdition"))
                    object.maximumEdition = options.enums === String ? $root.google.protobuf.Edition[message.maximumEdition] === undefined ? message.maximumEdition : $root.google.protobuf.Edition[message.maximumEdition] : message.maximumEdition;
                return object;
            };

            /**
             * Converts this FeatureSetDefaults to JSON.
             * @function toJSON
             * @memberof google.protobuf.FeatureSetDefaults
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FeatureSetDefaults.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for FeatureSetDefaults
             * @function getTypeUrl
             * @memberof google.protobuf.FeatureSetDefaults
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            FeatureSetDefaults.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/google.protobuf.FeatureSetDefaults";
            };

            FeatureSetDefaults.FeatureSetEditionDefault = (function() {

                /**
                 * Properties of a FeatureSetEditionDefault.
                 * @memberof google.protobuf.FeatureSetDefaults
                 * @interface IFeatureSetEditionDefault
                 * @property {google.protobuf.Edition|null} [edition] FeatureSetEditionDefault edition
                 * @property {google.protobuf.IFeatureSet|null} [overridableFeatures] FeatureSetEditionDefault overridableFeatures
                 * @property {google.protobuf.IFeatureSet|null} [fixedFeatures] FeatureSetEditionDefault fixedFeatures
                 */

                /**
                 * Constructs a new FeatureSetEditionDefault.
                 * @memberof google.protobuf.FeatureSetDefaults
                 * @classdesc Represents a FeatureSetEditionDefault.
                 * @implements IFeatureSetEditionDefault
                 * @constructor
                 * @param {google.protobuf.FeatureSetDefaults.IFeatureSetEditionDefault=} [properties] Properties to set
                 */
                function FeatureSetEditionDefault(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * FeatureSetEditionDefault edition.
                 * @member {google.protobuf.Edition} edition
                 * @memberof google.protobuf.FeatureSetDefaults.FeatureSetEditionDefault
                 * @instance
                 */
                FeatureSetEditionDefault.prototype.edition = 0;

                /**
                 * FeatureSetEditionDefault overridableFeatures.
                 * @member {google.protobuf.IFeatureSet|null|undefined} overridableFeatures
                 * @memberof google.protobuf.FeatureSetDefaults.FeatureSetEditionDefault
                 * @instance
                 */
                FeatureSetEditionDefault.prototype.overridableFeatures = null;

                /**
                 * FeatureSetEditionDefault fixedFeatures.
                 * @member {google.protobuf.IFeatureSet|null|undefined} fixedFeatures
                 * @memberof google.protobuf.FeatureSetDefaults.FeatureSetEditionDefault
                 * @instance
                 */
                FeatureSetEditionDefault.prototype.fixedFeatures = null;

                /**
                 * Creates a new FeatureSetEditionDefault instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.FeatureSetDefaults.FeatureSetEditionDefault
                 * @static
                 * @param {google.protobuf.FeatureSetDefaults.IFeatureSetEditionDefault=} [properties] Properties to set
                 * @returns {google.protobuf.FeatureSetDefaults.FeatureSetEditionDefault} FeatureSetEditionDefault instance
                 */
                FeatureSetEditionDefault.create = function create(properties) {
                    return new FeatureSetEditionDefault(properties);
                };

                /**
                 * Encodes the specified FeatureSetEditionDefault message. Does not implicitly {@link google.protobuf.FeatureSetDefaults.FeatureSetEditionDefault.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.FeatureSetDefaults.FeatureSetEditionDefault
                 * @static
                 * @param {google.protobuf.FeatureSetDefaults.IFeatureSetEditionDefault} message FeatureSetEditionDefault message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FeatureSetEditionDefault.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.edition != null && Object.hasOwnProperty.call(message, "edition"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.edition);
                    if (message.overridableFeatures != null && Object.hasOwnProperty.call(message, "overridableFeatures"))
                        $root.google.protobuf.FeatureSet.encode(message.overridableFeatures, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.fixedFeatures != null && Object.hasOwnProperty.call(message, "fixedFeatures"))
                        $root.google.protobuf.FeatureSet.encode(message.fixedFeatures, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified FeatureSetEditionDefault message, length delimited. Does not implicitly {@link google.protobuf.FeatureSetDefaults.FeatureSetEditionDefault.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.FeatureSetDefaults.FeatureSetEditionDefault
                 * @static
                 * @param {google.protobuf.FeatureSetDefaults.IFeatureSetEditionDefault} message FeatureSetEditionDefault message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FeatureSetEditionDefault.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a FeatureSetEditionDefault message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.FeatureSetDefaults.FeatureSetEditionDefault
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.FeatureSetDefaults.FeatureSetEditionDefault} FeatureSetEditionDefault
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FeatureSetEditionDefault.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FeatureSetDefaults.FeatureSetEditionDefault();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 3: {
                                message.edition = reader.int32();
                                break;
                            }
                        case 4: {
                                message.overridableFeatures = $root.google.protobuf.FeatureSet.decode(reader, reader.uint32());
                                break;
                            }
                        case 5: {
                                message.fixedFeatures = $root.google.protobuf.FeatureSet.decode(reader, reader.uint32());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a FeatureSetEditionDefault message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.FeatureSetDefaults.FeatureSetEditionDefault
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.FeatureSetDefaults.FeatureSetEditionDefault} FeatureSetEditionDefault
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FeatureSetEditionDefault.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a FeatureSetEditionDefault message.
                 * @function verify
                 * @memberof google.protobuf.FeatureSetDefaults.FeatureSetEditionDefault
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                FeatureSetEditionDefault.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.edition != null && message.hasOwnProperty("edition"))
                        switch (message.edition) {
                        default:
                            return "edition: enum value expected";
                        case 0:
                        case 900:
                        case 998:
                        case 999:
                        case 1000:
                        case 1001:
                        case 1:
                        case 2:
                        case 99997:
                        case 99998:
                        case 99999:
                        case 2147483647:
                            break;
                        }
                    if (message.overridableFeatures != null && message.hasOwnProperty("overridableFeatures")) {
                        let error = $root.google.protobuf.FeatureSet.verify(message.overridableFeatures);
                        if (error)
                            return "overridableFeatures." + error;
                    }
                    if (message.fixedFeatures != null && message.hasOwnProperty("fixedFeatures")) {
                        let error = $root.google.protobuf.FeatureSet.verify(message.fixedFeatures);
                        if (error)
                            return "fixedFeatures." + error;
                    }
                    return null;
                };

                /**
                 * Creates a FeatureSetEditionDefault message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.FeatureSetDefaults.FeatureSetEditionDefault
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.FeatureSetDefaults.FeatureSetEditionDefault} FeatureSetEditionDefault
                 */
                FeatureSetEditionDefault.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.FeatureSetDefaults.FeatureSetEditionDefault)
                        return object;
                    let message = new $root.google.protobuf.FeatureSetDefaults.FeatureSetEditionDefault();
                    switch (object.edition) {
                    default:
                        if (typeof object.edition === "number") {
                            message.edition = object.edition;
                            break;
                        }
                        break;
                    case "EDITION_UNKNOWN":
                    case 0:
                        message.edition = 0;
                        break;
                    case "EDITION_LEGACY":
                    case 900:
                        message.edition = 900;
                        break;
                    case "EDITION_PROTO2":
                    case 998:
                        message.edition = 998;
                        break;
                    case "EDITION_PROTO3":
                    case 999:
                        message.edition = 999;
                        break;
                    case "EDITION_2023":
                    case 1000:
                        message.edition = 1000;
                        break;
                    case "EDITION_2024":
                    case 1001:
                        message.edition = 1001;
                        break;
                    case "EDITION_1_TEST_ONLY":
                    case 1:
                        message.edition = 1;
                        break;
                    case "EDITION_2_TEST_ONLY":
                    case 2:
                        message.edition = 2;
                        break;
                    case "EDITION_99997_TEST_ONLY":
                    case 99997:
                        message.edition = 99997;
                        break;
                    case "EDITION_99998_TEST_ONLY":
                    case 99998:
                        message.edition = 99998;
                        break;
                    case "EDITION_99999_TEST_ONLY":
                    case 99999:
                        message.edition = 99999;
                        break;
                    case "EDITION_MAX":
                    case 2147483647:
                        message.edition = 2147483647;
                        break;
                    }
                    if (object.overridableFeatures != null) {
                        if (typeof object.overridableFeatures !== "object")
                            throw TypeError(".google.protobuf.FeatureSetDefaults.FeatureSetEditionDefault.overridableFeatures: object expected");
                        message.overridableFeatures = $root.google.protobuf.FeatureSet.fromObject(object.overridableFeatures);
                    }
                    if (object.fixedFeatures != null) {
                        if (typeof object.fixedFeatures !== "object")
                            throw TypeError(".google.protobuf.FeatureSetDefaults.FeatureSetEditionDefault.fixedFeatures: object expected");
                        message.fixedFeatures = $root.google.protobuf.FeatureSet.fromObject(object.fixedFeatures);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a FeatureSetEditionDefault message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.FeatureSetDefaults.FeatureSetEditionDefault
                 * @static
                 * @param {google.protobuf.FeatureSetDefaults.FeatureSetEditionDefault} message FeatureSetEditionDefault
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                FeatureSetEditionDefault.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.edition = options.enums === String ? "EDITION_UNKNOWN" : 0;
                        object.overridableFeatures = null;
                        object.fixedFeatures = null;
                    }
                    if (message.edition != null && message.hasOwnProperty("edition"))
                        object.edition = options.enums === String ? $root.google.protobuf.Edition[message.edition] === undefined ? message.edition : $root.google.protobuf.Edition[message.edition] : message.edition;
                    if (message.overridableFeatures != null && message.hasOwnProperty("overridableFeatures"))
                        object.overridableFeatures = $root.google.protobuf.FeatureSet.toObject(message.overridableFeatures, options);
                    if (message.fixedFeatures != null && message.hasOwnProperty("fixedFeatures"))
                        object.fixedFeatures = $root.google.protobuf.FeatureSet.toObject(message.fixedFeatures, options);
                    return object;
                };

                /**
                 * Converts this FeatureSetEditionDefault to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.FeatureSetDefaults.FeatureSetEditionDefault
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                FeatureSetEditionDefault.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for FeatureSetEditionDefault
                 * @function getTypeUrl
                 * @memberof google.protobuf.FeatureSetDefaults.FeatureSetEditionDefault
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                FeatureSetEditionDefault.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/google.protobuf.FeatureSetDefaults.FeatureSetEditionDefault";
                };

                return FeatureSetEditionDefault;
            })();

            return FeatureSetDefaults;
        })();

        protobuf.SourceCodeInfo = (function() {

            /**
             * Properties of a SourceCodeInfo.
             * @memberof google.protobuf
             * @interface ISourceCodeInfo
             * @property {Array.<google.protobuf.SourceCodeInfo.ILocation>|null} [location] SourceCodeInfo location
             */

            /**
             * Constructs a new SourceCodeInfo.
             * @memberof google.protobuf
             * @classdesc Represents a SourceCodeInfo.
             * @implements ISourceCodeInfo
             * @constructor
             * @param {google.protobuf.ISourceCodeInfo=} [properties] Properties to set
             */
            function SourceCodeInfo(properties) {
                this.location = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SourceCodeInfo location.
             * @member {Array.<google.protobuf.SourceCodeInfo.ILocation>} location
             * @memberof google.protobuf.SourceCodeInfo
             * @instance
             */
            SourceCodeInfo.prototype.location = $util.emptyArray;

            /**
             * Creates a new SourceCodeInfo instance using the specified properties.
             * @function create
             * @memberof google.protobuf.SourceCodeInfo
             * @static
             * @param {google.protobuf.ISourceCodeInfo=} [properties] Properties to set
             * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo instance
             */
            SourceCodeInfo.create = function create(properties) {
                return new SourceCodeInfo(properties);
            };

            /**
             * Encodes the specified SourceCodeInfo message. Does not implicitly {@link google.protobuf.SourceCodeInfo.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.SourceCodeInfo
             * @static
             * @param {google.protobuf.ISourceCodeInfo} message SourceCodeInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SourceCodeInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.location != null && message.location.length)
                    for (let i = 0; i < message.location.length; ++i)
                        $root.google.protobuf.SourceCodeInfo.Location.encode(message.location[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified SourceCodeInfo message, length delimited. Does not implicitly {@link google.protobuf.SourceCodeInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.SourceCodeInfo
             * @static
             * @param {google.protobuf.ISourceCodeInfo} message SourceCodeInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SourceCodeInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SourceCodeInfo message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.SourceCodeInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SourceCodeInfo.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.SourceCodeInfo();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.location && message.location.length))
                                message.location = [];
                            message.location.push($root.google.protobuf.SourceCodeInfo.Location.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SourceCodeInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.SourceCodeInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SourceCodeInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SourceCodeInfo message.
             * @function verify
             * @memberof google.protobuf.SourceCodeInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SourceCodeInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.location != null && message.hasOwnProperty("location")) {
                    if (!Array.isArray(message.location))
                        return "location: array expected";
                    for (let i = 0; i < message.location.length; ++i) {
                        let error = $root.google.protobuf.SourceCodeInfo.Location.verify(message.location[i]);
                        if (error)
                            return "location." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a SourceCodeInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.SourceCodeInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo
             */
            SourceCodeInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.SourceCodeInfo)
                    return object;
                let message = new $root.google.protobuf.SourceCodeInfo();
                if (object.location) {
                    if (!Array.isArray(object.location))
                        throw TypeError(".google.protobuf.SourceCodeInfo.location: array expected");
                    message.location = [];
                    for (let i = 0; i < object.location.length; ++i) {
                        if (typeof object.location[i] !== "object")
                            throw TypeError(".google.protobuf.SourceCodeInfo.location: object expected");
                        message.location[i] = $root.google.protobuf.SourceCodeInfo.Location.fromObject(object.location[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a SourceCodeInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.SourceCodeInfo
             * @static
             * @param {google.protobuf.SourceCodeInfo} message SourceCodeInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SourceCodeInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.location = [];
                if (message.location && message.location.length) {
                    object.location = [];
                    for (let j = 0; j < message.location.length; ++j)
                        object.location[j] = $root.google.protobuf.SourceCodeInfo.Location.toObject(message.location[j], options);
                }
                return object;
            };

            /**
             * Converts this SourceCodeInfo to JSON.
             * @function toJSON
             * @memberof google.protobuf.SourceCodeInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SourceCodeInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SourceCodeInfo
             * @function getTypeUrl
             * @memberof google.protobuf.SourceCodeInfo
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SourceCodeInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/google.protobuf.SourceCodeInfo";
            };

            SourceCodeInfo.Location = (function() {

                /**
                 * Properties of a Location.
                 * @memberof google.protobuf.SourceCodeInfo
                 * @interface ILocation
                 * @property {Array.<number>|null} [path] Location path
                 * @property {Array.<number>|null} [span] Location span
                 * @property {string|null} [leadingComments] Location leadingComments
                 * @property {string|null} [trailingComments] Location trailingComments
                 * @property {Array.<string>|null} [leadingDetachedComments] Location leadingDetachedComments
                 */

                /**
                 * Constructs a new Location.
                 * @memberof google.protobuf.SourceCodeInfo
                 * @classdesc Represents a Location.
                 * @implements ILocation
                 * @constructor
                 * @param {google.protobuf.SourceCodeInfo.ILocation=} [properties] Properties to set
                 */
                function Location(properties) {
                    this.path = [];
                    this.span = [];
                    this.leadingDetachedComments = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Location path.
                 * @member {Array.<number>} path
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @instance
                 */
                Location.prototype.path = $util.emptyArray;

                /**
                 * Location span.
                 * @member {Array.<number>} span
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @instance
                 */
                Location.prototype.span = $util.emptyArray;

                /**
                 * Location leadingComments.
                 * @member {string} leadingComments
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @instance
                 */
                Location.prototype.leadingComments = "";

                /**
                 * Location trailingComments.
                 * @member {string} trailingComments
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @instance
                 */
                Location.prototype.trailingComments = "";

                /**
                 * Location leadingDetachedComments.
                 * @member {Array.<string>} leadingDetachedComments
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @instance
                 */
                Location.prototype.leadingDetachedComments = $util.emptyArray;

                /**
                 * Creates a new Location instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @static
                 * @param {google.protobuf.SourceCodeInfo.ILocation=} [properties] Properties to set
                 * @returns {google.protobuf.SourceCodeInfo.Location} Location instance
                 */
                Location.create = function create(properties) {
                    return new Location(properties);
                };

                /**
                 * Encodes the specified Location message. Does not implicitly {@link google.protobuf.SourceCodeInfo.Location.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @static
                 * @param {google.protobuf.SourceCodeInfo.ILocation} message Location message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Location.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.path != null && message.path.length) {
                        writer.uint32(/* id 1, wireType 2 =*/10).fork();
                        for (let i = 0; i < message.path.length; ++i)
                            writer.int32(message.path[i]);
                        writer.ldelim();
                    }
                    if (message.span != null && message.span.length) {
                        writer.uint32(/* id 2, wireType 2 =*/18).fork();
                        for (let i = 0; i < message.span.length; ++i)
                            writer.int32(message.span[i]);
                        writer.ldelim();
                    }
                    if (message.leadingComments != null && Object.hasOwnProperty.call(message, "leadingComments"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.leadingComments);
                    if (message.trailingComments != null && Object.hasOwnProperty.call(message, "trailingComments"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.trailingComments);
                    if (message.leadingDetachedComments != null && message.leadingDetachedComments.length)
                        for (let i = 0; i < message.leadingDetachedComments.length; ++i)
                            writer.uint32(/* id 6, wireType 2 =*/50).string(message.leadingDetachedComments[i]);
                    return writer;
                };

                /**
                 * Encodes the specified Location message, length delimited. Does not implicitly {@link google.protobuf.SourceCodeInfo.Location.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @static
                 * @param {google.protobuf.SourceCodeInfo.ILocation} message Location message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Location.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Location message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.SourceCodeInfo.Location} Location
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Location.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.SourceCodeInfo.Location();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                if (!(message.path && message.path.length))
                                    message.path = [];
                                if ((tag & 7) === 2) {
                                    let end2 = reader.uint32() + reader.pos;
                                    while (reader.pos < end2)
                                        message.path.push(reader.int32());
                                } else
                                    message.path.push(reader.int32());
                                break;
                            }
                        case 2: {
                                if (!(message.span && message.span.length))
                                    message.span = [];
                                if ((tag & 7) === 2) {
                                    let end2 = reader.uint32() + reader.pos;
                                    while (reader.pos < end2)
                                        message.span.push(reader.int32());
                                } else
                                    message.span.push(reader.int32());
                                break;
                            }
                        case 3: {
                                message.leadingComments = reader.string();
                                break;
                            }
                        case 4: {
                                message.trailingComments = reader.string();
                                break;
                            }
                        case 6: {
                                if (!(message.leadingDetachedComments && message.leadingDetachedComments.length))
                                    message.leadingDetachedComments = [];
                                message.leadingDetachedComments.push(reader.string());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Location message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.SourceCodeInfo.Location} Location
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Location.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Location message.
                 * @function verify
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Location.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.path != null && message.hasOwnProperty("path")) {
                        if (!Array.isArray(message.path))
                            return "path: array expected";
                        for (let i = 0; i < message.path.length; ++i)
                            if (!$util.isInteger(message.path[i]))
                                return "path: integer[] expected";
                    }
                    if (message.span != null && message.hasOwnProperty("span")) {
                        if (!Array.isArray(message.span))
                            return "span: array expected";
                        for (let i = 0; i < message.span.length; ++i)
                            if (!$util.isInteger(message.span[i]))
                                return "span: integer[] expected";
                    }
                    if (message.leadingComments != null && message.hasOwnProperty("leadingComments"))
                        if (!$util.isString(message.leadingComments))
                            return "leadingComments: string expected";
                    if (message.trailingComments != null && message.hasOwnProperty("trailingComments"))
                        if (!$util.isString(message.trailingComments))
                            return "trailingComments: string expected";
                    if (message.leadingDetachedComments != null && message.hasOwnProperty("leadingDetachedComments")) {
                        if (!Array.isArray(message.leadingDetachedComments))
                            return "leadingDetachedComments: array expected";
                        for (let i = 0; i < message.leadingDetachedComments.length; ++i)
                            if (!$util.isString(message.leadingDetachedComments[i]))
                                return "leadingDetachedComments: string[] expected";
                    }
                    return null;
                };

                /**
                 * Creates a Location message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.SourceCodeInfo.Location} Location
                 */
                Location.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.SourceCodeInfo.Location)
                        return object;
                    let message = new $root.google.protobuf.SourceCodeInfo.Location();
                    if (object.path) {
                        if (!Array.isArray(object.path))
                            throw TypeError(".google.protobuf.SourceCodeInfo.Location.path: array expected");
                        message.path = [];
                        for (let i = 0; i < object.path.length; ++i)
                            message.path[i] = object.path[i] | 0;
                    }
                    if (object.span) {
                        if (!Array.isArray(object.span))
                            throw TypeError(".google.protobuf.SourceCodeInfo.Location.span: array expected");
                        message.span = [];
                        for (let i = 0; i < object.span.length; ++i)
                            message.span[i] = object.span[i] | 0;
                    }
                    if (object.leadingComments != null)
                        message.leadingComments = String(object.leadingComments);
                    if (object.trailingComments != null)
                        message.trailingComments = String(object.trailingComments);
                    if (object.leadingDetachedComments) {
                        if (!Array.isArray(object.leadingDetachedComments))
                            throw TypeError(".google.protobuf.SourceCodeInfo.Location.leadingDetachedComments: array expected");
                        message.leadingDetachedComments = [];
                        for (let i = 0; i < object.leadingDetachedComments.length; ++i)
                            message.leadingDetachedComments[i] = String(object.leadingDetachedComments[i]);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Location message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @static
                 * @param {google.protobuf.SourceCodeInfo.Location} message Location
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Location.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults) {
                        object.path = [];
                        object.span = [];
                        object.leadingDetachedComments = [];
                    }
                    if (options.defaults) {
                        object.leadingComments = "";
                        object.trailingComments = "";
                    }
                    if (message.path && message.path.length) {
                        object.path = [];
                        for (let j = 0; j < message.path.length; ++j)
                            object.path[j] = message.path[j];
                    }
                    if (message.span && message.span.length) {
                        object.span = [];
                        for (let j = 0; j < message.span.length; ++j)
                            object.span[j] = message.span[j];
                    }
                    if (message.leadingComments != null && message.hasOwnProperty("leadingComments"))
                        object.leadingComments = message.leadingComments;
                    if (message.trailingComments != null && message.hasOwnProperty("trailingComments"))
                        object.trailingComments = message.trailingComments;
                    if (message.leadingDetachedComments && message.leadingDetachedComments.length) {
                        object.leadingDetachedComments = [];
                        for (let j = 0; j < message.leadingDetachedComments.length; ++j)
                            object.leadingDetachedComments[j] = message.leadingDetachedComments[j];
                    }
                    return object;
                };

                /**
                 * Converts this Location to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Location.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for Location
                 * @function getTypeUrl
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                Location.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/google.protobuf.SourceCodeInfo.Location";
                };

                return Location;
            })();

            return SourceCodeInfo;
        })();

        protobuf.GeneratedCodeInfo = (function() {

            /**
             * Properties of a GeneratedCodeInfo.
             * @memberof google.protobuf
             * @interface IGeneratedCodeInfo
             * @property {Array.<google.protobuf.GeneratedCodeInfo.IAnnotation>|null} [annotation] GeneratedCodeInfo annotation
             */

            /**
             * Constructs a new GeneratedCodeInfo.
             * @memberof google.protobuf
             * @classdesc Represents a GeneratedCodeInfo.
             * @implements IGeneratedCodeInfo
             * @constructor
             * @param {google.protobuf.IGeneratedCodeInfo=} [properties] Properties to set
             */
            function GeneratedCodeInfo(properties) {
                this.annotation = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GeneratedCodeInfo annotation.
             * @member {Array.<google.protobuf.GeneratedCodeInfo.IAnnotation>} annotation
             * @memberof google.protobuf.GeneratedCodeInfo
             * @instance
             */
            GeneratedCodeInfo.prototype.annotation = $util.emptyArray;

            /**
             * Creates a new GeneratedCodeInfo instance using the specified properties.
             * @function create
             * @memberof google.protobuf.GeneratedCodeInfo
             * @static
             * @param {google.protobuf.IGeneratedCodeInfo=} [properties] Properties to set
             * @returns {google.protobuf.GeneratedCodeInfo} GeneratedCodeInfo instance
             */
            GeneratedCodeInfo.create = function create(properties) {
                return new GeneratedCodeInfo(properties);
            };

            /**
             * Encodes the specified GeneratedCodeInfo message. Does not implicitly {@link google.protobuf.GeneratedCodeInfo.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.GeneratedCodeInfo
             * @static
             * @param {google.protobuf.IGeneratedCodeInfo} message GeneratedCodeInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GeneratedCodeInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.annotation != null && message.annotation.length)
                    for (let i = 0; i < message.annotation.length; ++i)
                        $root.google.protobuf.GeneratedCodeInfo.Annotation.encode(message.annotation[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GeneratedCodeInfo message, length delimited. Does not implicitly {@link google.protobuf.GeneratedCodeInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.GeneratedCodeInfo
             * @static
             * @param {google.protobuf.IGeneratedCodeInfo} message GeneratedCodeInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GeneratedCodeInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GeneratedCodeInfo message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.GeneratedCodeInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.GeneratedCodeInfo} GeneratedCodeInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GeneratedCodeInfo.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.GeneratedCodeInfo();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.annotation && message.annotation.length))
                                message.annotation = [];
                            message.annotation.push($root.google.protobuf.GeneratedCodeInfo.Annotation.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GeneratedCodeInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.GeneratedCodeInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.GeneratedCodeInfo} GeneratedCodeInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GeneratedCodeInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GeneratedCodeInfo message.
             * @function verify
             * @memberof google.protobuf.GeneratedCodeInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GeneratedCodeInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.annotation != null && message.hasOwnProperty("annotation")) {
                    if (!Array.isArray(message.annotation))
                        return "annotation: array expected";
                    for (let i = 0; i < message.annotation.length; ++i) {
                        let error = $root.google.protobuf.GeneratedCodeInfo.Annotation.verify(message.annotation[i]);
                        if (error)
                            return "annotation." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a GeneratedCodeInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.GeneratedCodeInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.GeneratedCodeInfo} GeneratedCodeInfo
             */
            GeneratedCodeInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.GeneratedCodeInfo)
                    return object;
                let message = new $root.google.protobuf.GeneratedCodeInfo();
                if (object.annotation) {
                    if (!Array.isArray(object.annotation))
                        throw TypeError(".google.protobuf.GeneratedCodeInfo.annotation: array expected");
                    message.annotation = [];
                    for (let i = 0; i < object.annotation.length; ++i) {
                        if (typeof object.annotation[i] !== "object")
                            throw TypeError(".google.protobuf.GeneratedCodeInfo.annotation: object expected");
                        message.annotation[i] = $root.google.protobuf.GeneratedCodeInfo.Annotation.fromObject(object.annotation[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a GeneratedCodeInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.GeneratedCodeInfo
             * @static
             * @param {google.protobuf.GeneratedCodeInfo} message GeneratedCodeInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GeneratedCodeInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.annotation = [];
                if (message.annotation && message.annotation.length) {
                    object.annotation = [];
                    for (let j = 0; j < message.annotation.length; ++j)
                        object.annotation[j] = $root.google.protobuf.GeneratedCodeInfo.Annotation.toObject(message.annotation[j], options);
                }
                return object;
            };

            /**
             * Converts this GeneratedCodeInfo to JSON.
             * @function toJSON
             * @memberof google.protobuf.GeneratedCodeInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GeneratedCodeInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GeneratedCodeInfo
             * @function getTypeUrl
             * @memberof google.protobuf.GeneratedCodeInfo
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GeneratedCodeInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/google.protobuf.GeneratedCodeInfo";
            };

            GeneratedCodeInfo.Annotation = (function() {

                /**
                 * Properties of an Annotation.
                 * @memberof google.protobuf.GeneratedCodeInfo
                 * @interface IAnnotation
                 * @property {Array.<number>|null} [path] Annotation path
                 * @property {string|null} [sourceFile] Annotation sourceFile
                 * @property {number|null} [begin] Annotation begin
                 * @property {number|null} [end] Annotation end
                 * @property {google.protobuf.GeneratedCodeInfo.Annotation.Semantic|null} [semantic] Annotation semantic
                 */

                /**
                 * Constructs a new Annotation.
                 * @memberof google.protobuf.GeneratedCodeInfo
                 * @classdesc Represents an Annotation.
                 * @implements IAnnotation
                 * @constructor
                 * @param {google.protobuf.GeneratedCodeInfo.IAnnotation=} [properties] Properties to set
                 */
                function Annotation(properties) {
                    this.path = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Annotation path.
                 * @member {Array.<number>} path
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @instance
                 */
                Annotation.prototype.path = $util.emptyArray;

                /**
                 * Annotation sourceFile.
                 * @member {string} sourceFile
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @instance
                 */
                Annotation.prototype.sourceFile = "";

                /**
                 * Annotation begin.
                 * @member {number} begin
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @instance
                 */
                Annotation.prototype.begin = 0;

                /**
                 * Annotation end.
                 * @member {number} end
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @instance
                 */
                Annotation.prototype.end = 0;

                /**
                 * Annotation semantic.
                 * @member {google.protobuf.GeneratedCodeInfo.Annotation.Semantic} semantic
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @instance
                 */
                Annotation.prototype.semantic = 0;

                /**
                 * Creates a new Annotation instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @static
                 * @param {google.protobuf.GeneratedCodeInfo.IAnnotation=} [properties] Properties to set
                 * @returns {google.protobuf.GeneratedCodeInfo.Annotation} Annotation instance
                 */
                Annotation.create = function create(properties) {
                    return new Annotation(properties);
                };

                /**
                 * Encodes the specified Annotation message. Does not implicitly {@link google.protobuf.GeneratedCodeInfo.Annotation.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @static
                 * @param {google.protobuf.GeneratedCodeInfo.IAnnotation} message Annotation message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Annotation.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.path != null && message.path.length) {
                        writer.uint32(/* id 1, wireType 2 =*/10).fork();
                        for (let i = 0; i < message.path.length; ++i)
                            writer.int32(message.path[i]);
                        writer.ldelim();
                    }
                    if (message.sourceFile != null && Object.hasOwnProperty.call(message, "sourceFile"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.sourceFile);
                    if (message.begin != null && Object.hasOwnProperty.call(message, "begin"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.begin);
                    if (message.end != null && Object.hasOwnProperty.call(message, "end"))
                        writer.uint32(/* id 4, wireType 0 =*/32).int32(message.end);
                    if (message.semantic != null && Object.hasOwnProperty.call(message, "semantic"))
                        writer.uint32(/* id 5, wireType 0 =*/40).int32(message.semantic);
                    return writer;
                };

                /**
                 * Encodes the specified Annotation message, length delimited. Does not implicitly {@link google.protobuf.GeneratedCodeInfo.Annotation.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @static
                 * @param {google.protobuf.GeneratedCodeInfo.IAnnotation} message Annotation message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Annotation.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an Annotation message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.GeneratedCodeInfo.Annotation} Annotation
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Annotation.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.GeneratedCodeInfo.Annotation();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                if (!(message.path && message.path.length))
                                    message.path = [];
                                if ((tag & 7) === 2) {
                                    let end2 = reader.uint32() + reader.pos;
                                    while (reader.pos < end2)
                                        message.path.push(reader.int32());
                                } else
                                    message.path.push(reader.int32());
                                break;
                            }
                        case 2: {
                                message.sourceFile = reader.string();
                                break;
                            }
                        case 3: {
                                message.begin = reader.int32();
                                break;
                            }
                        case 4: {
                                message.end = reader.int32();
                                break;
                            }
                        case 5: {
                                message.semantic = reader.int32();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an Annotation message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.GeneratedCodeInfo.Annotation} Annotation
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Annotation.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an Annotation message.
                 * @function verify
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Annotation.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.path != null && message.hasOwnProperty("path")) {
                        if (!Array.isArray(message.path))
                            return "path: array expected";
                        for (let i = 0; i < message.path.length; ++i)
                            if (!$util.isInteger(message.path[i]))
                                return "path: integer[] expected";
                    }
                    if (message.sourceFile != null && message.hasOwnProperty("sourceFile"))
                        if (!$util.isString(message.sourceFile))
                            return "sourceFile: string expected";
                    if (message.begin != null && message.hasOwnProperty("begin"))
                        if (!$util.isInteger(message.begin))
                            return "begin: integer expected";
                    if (message.end != null && message.hasOwnProperty("end"))
                        if (!$util.isInteger(message.end))
                            return "end: integer expected";
                    if (message.semantic != null && message.hasOwnProperty("semantic"))
                        switch (message.semantic) {
                        default:
                            return "semantic: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                            break;
                        }
                    return null;
                };

                /**
                 * Creates an Annotation message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.GeneratedCodeInfo.Annotation} Annotation
                 */
                Annotation.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.GeneratedCodeInfo.Annotation)
                        return object;
                    let message = new $root.google.protobuf.GeneratedCodeInfo.Annotation();
                    if (object.path) {
                        if (!Array.isArray(object.path))
                            throw TypeError(".google.protobuf.GeneratedCodeInfo.Annotation.path: array expected");
                        message.path = [];
                        for (let i = 0; i < object.path.length; ++i)
                            message.path[i] = object.path[i] | 0;
                    }
                    if (object.sourceFile != null)
                        message.sourceFile = String(object.sourceFile);
                    if (object.begin != null)
                        message.begin = object.begin | 0;
                    if (object.end != null)
                        message.end = object.end | 0;
                    switch (object.semantic) {
                    default:
                        if (typeof object.semantic === "number") {
                            message.semantic = object.semantic;
                            break;
                        }
                        break;
                    case "NONE":
                    case 0:
                        message.semantic = 0;
                        break;
                    case "SET":
                    case 1:
                        message.semantic = 1;
                        break;
                    case "ALIAS":
                    case 2:
                        message.semantic = 2;
                        break;
                    }
                    return message;
                };

                /**
                 * Creates a plain object from an Annotation message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @static
                 * @param {google.protobuf.GeneratedCodeInfo.Annotation} message Annotation
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Annotation.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.path = [];
                    if (options.defaults) {
                        object.sourceFile = "";
                        object.begin = 0;
                        object.end = 0;
                        object.semantic = options.enums === String ? "NONE" : 0;
                    }
                    if (message.path && message.path.length) {
                        object.path = [];
                        for (let j = 0; j < message.path.length; ++j)
                            object.path[j] = message.path[j];
                    }
                    if (message.sourceFile != null && message.hasOwnProperty("sourceFile"))
                        object.sourceFile = message.sourceFile;
                    if (message.begin != null && message.hasOwnProperty("begin"))
                        object.begin = message.begin;
                    if (message.end != null && message.hasOwnProperty("end"))
                        object.end = message.end;
                    if (message.semantic != null && message.hasOwnProperty("semantic"))
                        object.semantic = options.enums === String ? $root.google.protobuf.GeneratedCodeInfo.Annotation.Semantic[message.semantic] === undefined ? message.semantic : $root.google.protobuf.GeneratedCodeInfo.Annotation.Semantic[message.semantic] : message.semantic;
                    return object;
                };

                /**
                 * Converts this Annotation to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Annotation.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for Annotation
                 * @function getTypeUrl
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                Annotation.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/google.protobuf.GeneratedCodeInfo.Annotation";
                };

                /**
                 * Semantic enum.
                 * @name google.protobuf.GeneratedCodeInfo.Annotation.Semantic
                 * @enum {number}
                 * @property {number} NONE=0 NONE value
                 * @property {number} SET=1 SET value
                 * @property {number} ALIAS=2 ALIAS value
                 */
                Annotation.Semantic = (function() {
                    const valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "NONE"] = 0;
                    values[valuesById[1] = "SET"] = 1;
                    values[valuesById[2] = "ALIAS"] = 2;
                    return values;
                })();

                return Annotation;
            })();

            return GeneratedCodeInfo;
        })();

        /**
         * SymbolVisibility enum.
         * @name google.protobuf.SymbolVisibility
         * @enum {number}
         * @property {number} VISIBILITY_UNSET=0 VISIBILITY_UNSET value
         * @property {number} VISIBILITY_LOCAL=1 VISIBILITY_LOCAL value
         * @property {number} VISIBILITY_EXPORT=2 VISIBILITY_EXPORT value
         */
        protobuf.SymbolVisibility = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "VISIBILITY_UNSET"] = 0;
            values[valuesById[1] = "VISIBILITY_LOCAL"] = 1;
            values[valuesById[2] = "VISIBILITY_EXPORT"] = 2;
            return values;
        })();

        protobuf.Empty = (function() {

            /**
             * Properties of an Empty.
             * @memberof google.protobuf
             * @interface IEmpty
             */

            /**
             * Constructs a new Empty.
             * @memberof google.protobuf
             * @classdesc Represents an Empty.
             * @implements IEmpty
             * @constructor
             * @param {google.protobuf.IEmpty=} [properties] Properties to set
             */
            function Empty(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new Empty instance using the specified properties.
             * @function create
             * @memberof google.protobuf.Empty
             * @static
             * @param {google.protobuf.IEmpty=} [properties] Properties to set
             * @returns {google.protobuf.Empty} Empty instance
             */
            Empty.create = function create(properties) {
                return new Empty(properties);
            };

            /**
             * Encodes the specified Empty message. Does not implicitly {@link google.protobuf.Empty.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.Empty
             * @static
             * @param {google.protobuf.IEmpty} message Empty message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Empty.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified Empty message, length delimited. Does not implicitly {@link google.protobuf.Empty.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.Empty
             * @static
             * @param {google.protobuf.IEmpty} message Empty message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Empty.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Empty message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.Empty
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.Empty} Empty
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Empty.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.Empty();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Empty message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.Empty
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.Empty} Empty
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Empty.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Empty message.
             * @function verify
             * @memberof google.protobuf.Empty
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Empty.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates an Empty message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.Empty
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.Empty} Empty
             */
            Empty.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.Empty)
                    return object;
                return new $root.google.protobuf.Empty();
            };

            /**
             * Creates a plain object from an Empty message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.Empty
             * @static
             * @param {google.protobuf.Empty} message Empty
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Empty.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this Empty to JSON.
             * @function toJSON
             * @memberof google.protobuf.Empty
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Empty.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Empty
             * @function getTypeUrl
             * @memberof google.protobuf.Empty
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Empty.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/google.protobuf.Empty";
            };

            return Empty;
        })();

        return protobuf;
    })();

    return google;
})();

export { $root as default };
